// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 14.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace Genie.Templates.Basic
{
    using System.Linq;
    using System.Text;
    using System.Collections.Generic;
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    
    #line 1 "D:\Projects\Genie\Genie\Templates\Basic\Dapper.tt"
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "14.0.0.0")]
    public partial class Dapper : DapperBase
    {
#line hidden
        /// <summary>
        /// Create the template output
        /// </summary>
        public virtual string TransformText()
        {
            this.Write("\r\n    namespace Dapper\r\n    {\r\n        /// <summary>\r\n        /// Dapper, a light" +
                    " weight object mapper for ADO.NET\r\n        /// </summary>\r\n        static class " +
                    "SqlMapper\r\n        {\r\n            /// <summary>\r\n            /// Implement this " +
                    "interface to pass an arbitrary db specific set of parameters to Dapper\r\n        " +
                    "    /// </summary>\r\n            public interface IDynamicParameters\r\n           " +
                    " {\r\n                /// <summary>\r\n                /// Add all the parameters ne" +
                    "eded to the command just before it executes\r\n                /// </summary>\r\n   " +
                    "             /// <param name=\"command\">The raw command prior to execution</param" +
                    ">\r\n                /// <param name=\"identity\">Information about the query</param" +
                    ">\r\n                void AddParameters(IDbCommand command, Identity identity);\r\n " +
                    "           }\r\n\r\n            /// <summary>\r\n            /// Implement this interf" +
                    "ace to change default mapping of reader columns to type memebers\r\n            //" +
                    "/ </summary>\r\n            public interface ITypeMap\r\n            {\r\n            " +
                    "    /// <summary>\r\n                /// Finds best constructor\r\n                /" +
                    "// </summary>\r\n                /// <param name=\"names\">DataReader column names</" +
                    "param>\r\n                /// <param name=\"types\">DataReader column types</param>\r" +
                    "\n                /// <returns>Matching constructor or default one</returns>\r\n   " +
                    "             ConstructorInfo FindConstructor(string[] names, Type[] types);\r\n\r\n " +
                    "               /// <summary>\r\n                /// Gets mapping for constructor p" +
                    "arameter\r\n                /// </summary>\r\n                /// <param name=\"const" +
                    "ructor\">Constructor to resolve</param>\r\n                /// <param name=\"columnN" +
                    "ame\">DataReader column name</param>\r\n                /// <returns>Mapping implem" +
                    "entation</returns>\r\n                IMemberMap GetConstructorParameter(Construct" +
                    "orInfo constructor, string columnName);\r\n\r\n                /// <summary>\r\n      " +
                    "          /// Gets member mapping for column\r\n                /// </summary>\r\n  " +
                    "              /// <param name=\"columnName\">DataReader column name</param>\r\n     " +
                    "           /// <returns>Mapping implementation</returns>\r\n                IMembe" +
                    "rMap GetMember(string columnName);\r\n            }\r\n\r\n            /// <summary>\r\n" +
                    "            /// Implements this interface to provide custom member mapping\r\n    " +
                    "        /// </summary>\r\n            public interface IMemberMap\r\n            {\r\n" +
                    "                /// <summary>\r\n                /// Source DataReader column name" +
                    "\r\n                /// </summary>\r\n                string ColumnName { get; }\r\n\r\n" +
                    "                /// <summary>\r\n                ///  Target member type\r\n        " +
                    "        /// </summary>\r\n                Type MemberType { get; }\r\n\r\n            " +
                    "    /// <summary>\r\n                /// Target property\r\n                /// </su" +
                    "mmary>\r\n                PropertyInfo Property { get; }\r\n\r\n                /// <s" +
                    "ummary>\r\n                /// Target field\r\n                /// </summary>\r\n     " +
                    "           FieldInfo Field { get; }\r\n\r\n                /// <summary>\r\n          " +
                    "      /// Target constructor parameter\r\n                /// </summary>\r\n        " +
                    "        ParameterInfo Parameter { get; }\r\n            }\r\n\r\n            static Li" +
                    "nk<Type, Action<IDbCommand, bool>> _bindByNameCache;\r\n            static Action<" +
                    "IDbCommand, bool> GetBindByName(Type commandType)\r\n            {\r\n              " +
                    "  if (commandType == null) return null; // GIGO\r\n                Action<IDbComma" +
                    "nd, bool> action;\r\n                if (Link<Type, Action<IDbCommand, bool>>.TryG" +
                    "et(_bindByNameCache, commandType, out action))\r\n                {\r\n             " +
                    "       return action;\r\n                }\r\n                var prop = commandType" +
                    ".GetProperty(\"BindByName\", BindingFlags.Public | BindingFlags.Instance);\r\n      " +
                    "          action = null;\r\n                ParameterInfo[] indexers;\r\n           " +
                    "     MethodInfo setter;\r\n                if (prop != null && prop.CanWrite && pr" +
                    "op.PropertyType == typeof(bool)\r\n                    && ((indexers = prop.GetInd" +
                    "exParameters()) == null || indexers.Length == 0)\r\n                    && (setter" +
                    " = prop.GetSetMethod()) != null\r\n                    )\r\n                {\r\n     " +
                    "               var method = new DynamicMethod(commandType.Name + \"_BindByName\", " +
                    "null, new[] { typeof(IDbCommand), typeof(bool) });\r\n                    var il =" +
                    " method.GetILGenerator();\r\n                    il.Emit(OpCodes.Ldarg_0);\r\n      " +
                    "              il.Emit(OpCodes.Castclass, commandType);\r\n                    il.E" +
                    "mit(OpCodes.Ldarg_1);\r\n                    il.EmitCall(OpCodes.Callvirt, setter," +
                    " null);\r\n                    il.Emit(OpCodes.Ret);\r\n                    action =" +
                    " (Action<IDbCommand, bool>)method.CreateDelegate(typeof(Action<IDbCommand, bool>" +
                    "));\r\n                }\r\n                // cache it            \r\n               " +
                    " Link<Type, Action<IDbCommand, bool>>.TryAdd(ref _bindByNameCache, commandType, " +
                    "ref action);\r\n                return action;\r\n            }\r\n            /// <su" +
                    "mmary>\r\n            /// This is a micro-cache; suitable when the number of terms" +
                    " is controllable (a few hundred, for example),\r\n            /// and strictly app" +
                    "end-only; you cannot change existing values. All key matches are on **REFERENCE*" +
                    "*\r\n            /// equality. The type is fully thread-safe.\r\n            /// </s" +
                    "ummary>\r\n            class Link<TKey, TValue> where TKey : class\r\n            {\r" +
                    "\n                public static bool TryGet(Link<TKey, TValue> link, TKey key, ou" +
                    "t TValue value)\r\n                {\r\n                    while (link != null)\r\n  " +
                    "                  {\r\n                        if ((object)key == (object)link.Key" +
                    ")\r\n                        {\r\n                            value = link.Value;\r\n " +
                    "                           return true;\r\n                        }\r\n            " +
                    "            link = link.Tail;\r\n                    }\r\n                    value " +
                    "= default(TValue);\r\n                    return false;\r\n                }\r\n      " +
                    "          public static bool TryAdd(ref Link<TKey, TValue> head, TKey key, ref T" +
                    "Value value)\r\n                {\r\n                    bool tryAgain;\r\n           " +
                    "         do\r\n                    {\r\n                        var snapshot = Inter" +
                    "locked.CompareExchange(ref head, null, null);\r\n                        TValue fo" +
                    "und;\r\n                        if (TryGet(snapshot, key, out found))\r\n           " +
                    "             { // existing match; report the existing value instead\r\n           " +
                    "                 value = found;\r\n                            return false;\r\n    " +
                    "                    }\r\n                        var newNode = new Link<TKey, TVal" +
                    "ue>(key, value, snapshot);\r\n                        // did somebody move our che" +
                    "ese?\r\n                        tryAgain = Interlocked.CompareExchange(ref head, n" +
                    "ewNode, snapshot) != snapshot;\r\n                    } while (tryAgain);\r\n       " +
                    "             return true;\r\n                }\r\n                private Link(TKey " +
                    "key, TValue value, Link<TKey, TValue> tail)\r\n                {\r\n                " +
                    "    Key = key;\r\n                    Value = value;\r\n                    Tail = t" +
                    "ail;\r\n                }\r\n\r\n                private TKey Key { get; }\r\n          " +
                    "      private TValue Value { get; }\r\n                private Link<TKey, TValue> " +
                    "Tail { get; }\r\n            }\r\n            class CacheInfo\r\n            {\r\n      " +
                    "          public DeserializerState Deserializer { get; set; }\r\n                p" +
                    "ublic Func<IDataReader, object>[] OtherDeserializers { get; set; }\r\n            " +
                    "    public Action<IDbCommand, object> ParamReader { get; set; }\r\n               " +
                    " private int _hitCount;\r\n                public int GetHitCount() { return Inter" +
                    "locked.CompareExchange(ref _hitCount, 0, 0); }\r\n                public void Reco" +
                    "rdHit() { Interlocked.Increment(ref _hitCount); }\r\n            }\r\n            st" +
                    "atic int GetColumnHash(IDataReader reader)\r\n            {\r\n                unche" +
                    "cked\r\n                {\r\n                    int colCount = reader.FieldCount, h" +
                    "ash = colCount;\r\n                    for (int i = 0; i < colCount; i++)\r\n       " +
                    "             {   // binding code is only interested in names - not types\r\n      " +
                    "                  object tmp = reader.GetName(i);\r\n                        hash " +
                    "= (hash * 31) + (tmp == null ? 0 : tmp.GetHashCode());\r\n                    }\r\n " +
                    "                   return hash;\r\n                }\r\n            }\r\n            s" +
                    "truct DeserializerState\r\n            {\r\n                public readonly int Hash" +
                    ";\r\n                public readonly Func<IDataReader, object> Func;\r\n\r\n          " +
                    "      public DeserializerState(int hash, Func<IDataReader, object> func)\r\n      " +
                    "          {\r\n                    Hash = hash;\r\n                    Func = func;\r" +
                    "\n                }\r\n            }\r\n\r\n            /// <summary>\r\n            /// " +
                    "Called if the query cache is purged via PurgeQueryCache\r\n            /// </summa" +
                    "ry>\r\n            public static event EventHandler QueryCachePurged;\r\n           " +
                    " private static void OnQueryCachePurged()\r\n            {\r\n                var ha" +
                    "ndler = QueryCachePurged;\r\n                if (handler != null) handler(null, Ev" +
                    "entArgs.Empty);\r\n            }\r\n#if CSHARP30\r\n        private static readonly Di" +
                    "ctionary<Identity, CacheInfo> _queryCache = new Dictionary<Identity, CacheInfo>(" +
                    ");\r\n        // note: conflicts between readers and writers are so short-lived th" +
                    "at it isn\'t worth the overhead of\r\n        // ReaderWriterLockSlim etc; a simple" +
                    " lock is faster\r\n        private static void SetQueryCache(Identity key, CacheIn" +
                    "fo value)\r\n        {\r\n            lock (_queryCache) { _queryCache[key] = value;" +
                    " }\r\n        }\r\n        private static bool TryGetQueryCache(Identity key, out Ca" +
                    "cheInfo value)\r\n        {\r\n            lock (_queryCache) { return _queryCache.T" +
                    "ryGetValue(key, out value); }\r\n        }\r\n        private static void PurgeQuery" +
                    "CacheByType(Type type)\r\n        {\r\n            lock (_queryCache)\r\n            {" +
                    "\r\n                var toRemove = _queryCache.Keys.Where(id => id.type == type).T" +
                    "oArray();\r\n                foreach (var key in toRemove)\r\n                    _q" +
                    "ueryCache.Remove(key);\r\n            }\r\n        }\r\n        /// <summary>\r\n       " +
                    " /// Purge the query cache \r\n        /// </summary>\r\n        public static void " +
                    "PurgeQueryCache()\r\n        {\r\n            lock (_queryCache)\r\n            {\r\n   " +
                    "              _queryCache.Clear();\r\n            }\r\n            OnQueryCachePurge" +
                    "d();\r\n        }\r\n#else\r\n            static readonly ConcurrentDictionary<Identit" +
                    "y, CacheInfo> QueryCache = new ConcurrentDictionary<Identity, CacheInfo>();\r\n   " +
                    "         private static void SetQueryCache(Identity key, CacheInfo value)\r\n     " +
                    "       {\r\n                if (Interlocked.Increment(ref _collect) == CollectPerI" +
                    "tems)\r\n                {\r\n                    CollectCacheGarbage();\r\n          " +
                    "      }\r\n                QueryCache[key] = value;\r\n            }\r\n\r\n            " +
                    "private static void CollectCacheGarbage()\r\n            {\r\n                try\r\n " +
                    "               {\r\n                    foreach (var pair in QueryCache)\r\n        " +
                    "            {\r\n                        if (pair.Value.GetHitCount() <= CollectHi" +
                    "tCountMin)\r\n                        {\r\n                            CacheInfo cac" +
                    "he;\r\n                            QueryCache.TryRemove(pair.Key, out cache);\r\n   " +
                    "                     }\r\n                    }\r\n                }\r\n\r\n            " +
                    "    finally\r\n                {\r\n                    Interlocked.Exchange(ref _co" +
                    "llect, 0);\r\n                }\r\n            }\r\n\r\n            private const int Co" +
                    "llectPerItems = 1000, CollectHitCountMin = 0;\r\n            private static int _c" +
                    "ollect;\r\n            private static bool TryGetQueryCache(Identity key, out Cach" +
                    "eInfo value)\r\n            {\r\n                if (QueryCache.TryGetValue(key, out" +
                    " value))\r\n                {\r\n                    value.RecordHit();\r\n           " +
                    "         return true;\r\n                }\r\n                return false;\r\n       " +
                    "     }\r\n\r\n            /// <summary>\r\n            /// Purge the query cache \r\n   " +
                    "         /// </summary>\r\n            public static void PurgeQueryCache()\r\n     " +
                    "       {\r\n                QueryCache.Clear();\r\n                OnQueryCachePurge" +
                    "d();\r\n            }\r\n\r\n            private static void PurgeQueryCacheByType(Typ" +
                    "e type)\r\n            {\r\n                foreach (var entry in QueryCache)\r\n     " +
                    "           {\r\n                    CacheInfo cache;\r\n                    if (entr" +
                    "y.Key.type == type)\r\n                        QueryCache.TryRemove(entry.Key, out" +
                    " cache);\r\n                }\r\n            }\r\n\r\n            /// <summary>\r\n       " +
                    "     /// Return a count of all the cached queries by dapper\r\n            /// </s" +
                    "ummary>\r\n            /// <returns></returns>\r\n            public static int GetC" +
                    "achedSQLCount()\r\n            {\r\n                return QueryCache.Count;\r\n      " +
                    "      }\r\n\r\n            /// <summary>\r\n            /// Return a list of all the q" +
                    "ueries cached by dapper\r\n            /// </summary>\r\n            /// <param name" +
                    "=\"ignoreHitCountAbove\"></param>\r\n            /// <returns></returns>\r\n          " +
                    "  public static IEnumerable<Tuple<string, string, int>> GetCachedSQL(int ignoreH" +
                    "itCountAbove = int.MaxValue)\r\n            {\r\n                var data = QueryCac" +
                    "he.Select(pair => Tuple.Create(pair.Key.connectionString, pair.Key.sql, pair.Val" +
                    "ue.GetHitCount()));\r\n                if (ignoreHitCountAbove < int.MaxValue) dat" +
                    "a = data.Where(tuple => tuple.Item3 <= ignoreHitCountAbove);\r\n                re" +
                    "turn data;\r\n            }\r\n\r\n            /// <summary>\r\n            /// Deep dia" +
                    "gnostics only: find any hash collisions in the cache\r\n            /// </summary>" +
                    "\r\n            /// <returns></returns>\r\n            public static IEnumerable<Tup" +
                    "le<int, int>> GetHashCollissions()\r\n            {\r\n                var counts = " +
                    "new Dictionary<int, int>();\r\n                foreach (var key in QueryCache.Keys" +
                    ")\r\n                {\r\n                    int count;\r\n                    if (!c" +
                    "ounts.TryGetValue(key.hashCode, out count))\r\n                    {\r\n            " +
                    "            counts.Add(key.hashCode, 1);\r\n                    }\r\n               " +
                    "     else\r\n                    {\r\n                        counts[key.hashCode] =" +
                    " count + 1;\r\n                    }\r\n                }\r\n                return fr" +
                    "om pair in counts\r\n                       where pair.Value > 1\r\n                " +
                    "       select Tuple.Create(pair.Key, pair.Value);\r\n\r\n            }\r\n#endif\r\n\r\n\r\n" +
                    "            static readonly Dictionary<Type, DbType> typeMap;\r\n\r\n            sta" +
                    "tic SqlMapper()\r\n            {\r\n                typeMap = new Dictionary<Type, D" +
                    "bType>();\r\n                typeMap[typeof(byte)] = DbType.Byte;\r\n               " +
                    " typeMap[typeof(sbyte)] = DbType.SByte;\r\n                typeMap[typeof(short)] " +
                    "= DbType.Int16;\r\n                typeMap[typeof(ushort)] = DbType.UInt16;\r\n     " +
                    "           typeMap[typeof(int)] = DbType.Int32;\r\n                typeMap[typeof(" +
                    "uint)] = DbType.UInt32;\r\n                typeMap[typeof(long)] = DbType.Int64;\r\n" +
                    "                typeMap[typeof(ulong)] = DbType.UInt64;\r\n                typeMap" +
                    "[typeof(float)] = DbType.Single;\r\n                typeMap[typeof(double)] = DbTy" +
                    "pe.Double;\r\n                typeMap[typeof(decimal)] = DbType.Decimal;\r\n        " +
                    "        typeMap[typeof(bool)] = DbType.Boolean;\r\n                typeMap[typeof(" +
                    "string)] = DbType.String;\r\n                typeMap[typeof(char)] = DbType.String" +
                    "FixedLength;\r\n                typeMap[typeof(Guid)] = DbType.Guid;\r\n            " +
                    "    typeMap[typeof(DateTime)] = DbType.DateTime;\r\n                typeMap[typeof" +
                    "(DateTimeOffset)] = DbType.DateTimeOffset;\r\n                typeMap[typeof(TimeS" +
                    "pan)] = DbType.Time;\r\n                typeMap[typeof(byte[])] = DbType.Binary;\r\n" +
                    "                typeMap[typeof(byte?)] = DbType.Byte;\r\n                typeMap[t" +
                    "ypeof(sbyte?)] = DbType.SByte;\r\n                typeMap[typeof(short?)] = DbType" +
                    ".Int16;\r\n                typeMap[typeof(ushort?)] = DbType.UInt16;\r\n            " +
                    "    typeMap[typeof(int?)] = DbType.Int32;\r\n                typeMap[typeof(uint?)" +
                    "] = DbType.UInt32;\r\n                typeMap[typeof(long?)] = DbType.Int64;\r\n    " +
                    "            typeMap[typeof(ulong?)] = DbType.UInt64;\r\n                typeMap[ty" +
                    "peof(float?)] = DbType.Single;\r\n                typeMap[typeof(double?)] = DbTyp" +
                    "e.Double;\r\n                typeMap[typeof(decimal?)] = DbType.Decimal;\r\n        " +
                    "        typeMap[typeof(bool?)] = DbType.Boolean;\r\n                typeMap[typeof" +
                    "(char?)] = DbType.StringFixedLength;\r\n                typeMap[typeof(Guid?)] = D" +
                    "bType.Guid;\r\n                typeMap[typeof(DateTime?)] = DbType.DateTime;\r\n    " +
                    "            typeMap[typeof(DateTimeOffset?)] = DbType.DateTimeOffset;\r\n         " +
                    "       typeMap[typeof(TimeSpan?)] = DbType.Time;\r\n                typeMap[typeof" +
                    "(Object)] = DbType.Object;\r\n            }\r\n            /// <summary>\r\n          " +
                    "  /// Configire the specified type to be mapped to a given db-type\r\n            " +
                    "/// </summary>\r\n            public static void AddTypeMap(Type type, DbType dbTy" +
                    "pe)\r\n            {\r\n                typeMap[type] = dbType;\r\n            }\r\n\r\n  " +
                    "          internal const string LinqBinary = \"System.Data.Linq.Binary\";\r\n       " +
                    "     internal static DbType LookupDbType(Type type, string name)\r\n            {\r" +
                    "\n                DbType dbType;\r\n                var nullUnderlyingType = Nullab" +
                    "le.GetUnderlyingType(type);\r\n                if (nullUnderlyingType != null) typ" +
                    "e = nullUnderlyingType;\r\n                if (type.IsEnum && !typeMap.ContainsKey" +
                    "(type))\r\n                {\r\n                    type = Enum.GetUnderlyingType(ty" +
                    "pe);\r\n                }\r\n                if (typeMap.TryGetValue(type, out dbTyp" +
                    "e))\r\n                {\r\n                    return dbType;\r\n                }\r\n " +
                    "               if (type.FullName == LinqBinary)\r\n                {\r\n            " +
                    "        return DbType.Binary;\r\n                }\r\n                if (typeof(IEn" +
                    "umerable).IsAssignableFrom(type))\r\n                {\r\n                    return" +
                    " DynamicParameters.EnumerableMultiParameter;\r\n                }\r\n\r\n\r\n           " +
                    "     throw new NotSupportedException(string.Format(\"The member {0} of type {1} c" +
                    "annot be used as a parameter value\", name, type));\r\n            }\r\n\r\n\r\n         " +
                    "   /// <summary>\r\n            /// Identity of a cached query in Dapper, used for" +
                    " extensability\r\n            /// </summary>\r\n            public partial class Ide" +
                    "ntity : IEquatable<Identity>\r\n            {\r\n                internal Identity F" +
                    "orGrid(Type primaryType, int gridIndex)\r\n                {\r\n                    " +
                    "return new Identity(sql, commandType, connectionString, primaryType, parametersT" +
                    "ype, null, gridIndex);\r\n                }\r\n\r\n                internal Identity F" +
                    "orGrid(Type primaryType, Type[] otherTypes, int gridIndex)\r\n                {\r\n " +
                    "                   return new Identity(sql, commandType, connectionString, prima" +
                    "ryType, parametersType, otherTypes, gridIndex);\r\n                }\r\n            " +
                    "    /// <summary>\r\n                /// Create an identity for use with DynamicPa" +
                    "rameters, internal use only\r\n                /// </summary>\r\n                ///" +
                    " <param name=\"type\"></param>\r\n                /// <returns></returns>\r\n         " +
                    "       public Identity ForDynamicParameters(Type type)\r\n                {\r\n     " +
                    "               return new Identity(sql, commandType, connectionString, this.type" +
                    ", type, null, -1);\r\n                }\r\n\r\n                internal Identity(strin" +
                    "g sql, CommandType? commandType, IDbConnection connection, Type type, Type param" +
                    "etersType, Type[] otherTypes)\r\n                    : this(sql, commandType, conn" +
                    "ection.ConnectionString, type, parametersType, otherTypes, 0)\r\n                {" +
                    " }\r\n                private Identity(string sql, CommandType? commandType, strin" +
                    "g connectionString, Type type, Type parametersType, Type[] otherTypes, int gridI" +
                    "ndex)\r\n                {\r\n                    this.sql = sql;\r\n                 " +
                    "   this.commandType = commandType;\r\n                    this.connectionString = " +
                    "connectionString;\r\n                    this.type = type;\r\n                    th" +
                    "is.parametersType = parametersType;\r\n                    this.gridIndex = gridIn" +
                    "dex;\r\n                    unchecked\r\n                    {\r\n                    " +
                    "    hashCode = 17; // we *know* we are using this in a dictionary, so pre-comput" +
                    "e this\r\n                        hashCode = hashCode * 23 + commandType.GetHashCo" +
                    "de();\r\n                        hashCode = hashCode * 23 + gridIndex.GetHashCode(" +
                    ");\r\n                        hashCode = hashCode * 23 + (sql == null ? 0 : sql.Ge" +
                    "tHashCode());\r\n                        hashCode = hashCode * 23 + (type == null " +
                    "? 0 : type.GetHashCode());\r\n                        if (otherTypes != null)\r\n   " +
                    "                     {\r\n                            foreach (var t in otherTypes" +
                    ")\r\n                            {\r\n                                hashCode = has" +
                    "hCode * 23 + (t == null ? 0 : t.GetHashCode());\r\n                            }\r\n" +
                    "                        }\r\n                        hashCode = hashCode * 23 + (c" +
                    "onnectionString == null ? 0 : connectionString.GetHashCode());\r\n                " +
                    "        hashCode = hashCode * 23 + (parametersType == null ? 0 : parametersType." +
                    "GetHashCode());\r\n                    }\r\n                }\r\n\r\n                ///" +
                    " <summary>\r\n                /// \r\n                /// </summary>\r\n              " +
                    "  /// <param name=\"obj\"></param>\r\n                /// <returns></returns>\r\n     " +
                    "           public override bool Equals(object obj)\r\n                {\r\n         " +
                    "           return Equals(obj as Identity);\r\n                }\r\n                /" +
                    "// <summary>\r\n                /// The sql\r\n                /// </summary>\r\n     " +
                    "           public readonly string sql;\r\n                /// <summary>\r\n         " +
                    "       /// The command type \r\n                /// </summary>\r\n                pu" +
                    "blic readonly CommandType? commandType;\r\n\r\n                /// <summary>\r\n      " +
                    "          /// \r\n                /// </summary>\r\n                public readonly " +
                    "int hashCode, gridIndex;\r\n                /// <summary>\r\n                /// \r\n " +
                    "               /// </summary>\r\n                public readonly Type type;\r\n     " +
                    "           /// <summary>\r\n                /// \r\n                /// </summary>\r\n" +
                    "                public readonly string connectionString;\r\n                /// <s" +
                    "ummary>\r\n                /// \r\n                /// </summary>\r\n                p" +
                    "ublic readonly Type parametersType;\r\n                /// <summary>\r\n            " +
                    "    /// \r\n                /// </summary>\r\n                /// <returns></returns" +
                    ">\r\n                public override int GetHashCode()\r\n                {\r\n       " +
                    "             return hashCode;\r\n                }\r\n                /// <summary>\r" +
                    "\n                /// Compare 2 Identity objects\r\n                /// </summary>\r" +
                    "\n                /// <param name=\"other\"></param>\r\n                /// <returns>" +
                    "</returns>\r\n                public bool Equals(Identity other)\r\n                " +
                    "{\r\n                    return\r\n                        other != null &&\r\n       " +
                    "                 gridIndex == other.gridIndex &&\r\n                        type =" +
                    "= other.type &&\r\n                        sql == other.sql &&\r\n                  " +
                    "      commandType == other.commandType &&\r\n                        connectionStr" +
                    "ing == other.connectionString &&\r\n                        parametersType == othe" +
                    "r.parametersType;\r\n                }\r\n            }\r\n\r\n#if CSHARP30\r\n        ///" +
                    " <summary>\r\n        /// Execute parameterized SQL  \r\n        /// </summary>\r\n   " +
                    "     /// <returns>Number of rows affected</returns>\r\n        public static int E" +
                    "xecute(this IDbConnection cnn, string sql, object param)\r\n        {\r\n           " +
                    " return Execute(cnn, sql, param, null, null, null);\r\n        }\r\n\r\n        /// <s" +
                    "ummary>\r\n        /// Execute parameterized SQL\r\n        /// </summary>\r\n        " +
                    "/// <returns>Number of rows affected</returns>\r\n        public static int Execut" +
                    "e(this IDbConnection cnn, string sql, object param, IDbTransaction transaction)\r" +
                    "\n        {\r\n            return Execute(cnn, sql, param, transaction, null, null)" +
                    ";\r\n        }\r\n\r\n        /// <summary>\r\n        /// Execute parameterized SQL\r\n  " +
                    "      /// </summary>\r\n        /// <returns>Number of rows affected</returns>\r\n  " +
                    "      public static int Execute(this IDbConnection cnn, string sql, object param" +
                    ", CommandType commandType)\r\n        {\r\n            return Execute(cnn, sql, para" +
                    "m, null, null, commandType);\r\n        }\r\n\r\n        /// <summary>\r\n        /// Ex" +
                    "ecute parameterized SQL\r\n        /// </summary>\r\n        /// <returns>Number of " +
                    "rows affected</returns>\r\n        public static int Execute(this IDbConnection cn" +
                    "n, string sql, object param, IDbTransaction transaction, CommandType commandType" +
                    ")\r\n        {\r\n            return Execute(cnn, sql, param, transaction, null, com" +
                    "mandType);\r\n        }\r\n\r\n        /// <summary>\r\n        /// Executes a query, re" +
                    "turning the data typed as per T\r\n        /// </summary>\r\n        /// <returns>A " +
                    "sequence of data of the supplied type; if a basic type (int, string, etc) is que" +
                    "ried then the data from the first column in assumed, otherwise an instance is\r\n " +
                    "       /// created per row, and a direct column-name===member-name mapping is as" +
                    "sumed (case insensitive).\r\n        /// </returns>\r\n        public static IEnumer" +
                    "able<T> Query<T>(this IDbConnection cnn, string sql, object param)\r\n        {\r\n " +
                    "           return Query<T>(cnn, sql, param, null, true, null, null);\r\n        }\r" +
                    "\n\r\n        /// <summary>\r\n        /// Executes a query, returning the data typed" +
                    " as per T\r\n        /// </summary>\r\n        /// <returns>A sequence of data of th" +
                    "e supplied type; if a basic type (int, string, etc) is queried then the data fro" +
                    "m the first column in assumed, otherwise an instance is\r\n        /// created per" +
                    " row, and a direct column-name===member-name mapping is assumed (case insensitiv" +
                    "e).\r\n        /// </returns>\r\n        public static IEnumerable<T> Query<T>(this " +
                    "IDbConnection cnn, string sql, object param, IDbTransaction transaction)\r\n      " +
                    "  {\r\n            return Query<T>(cnn, sql, param, transaction, true, null, null)" +
                    ";\r\n        }\r\n\r\n        /// <summary>\r\n        /// Executes a query, returning t" +
                    "he data typed as per T\r\n        /// </summary>\r\n        /// <returns>A sequence " +
                    "of data of the supplied type; if a basic type (int, string, etc) is queried then" +
                    " the data from the first column in assumed, otherwise an instance is\r\n        //" +
                    "/ created per row, and a direct column-name===member-name mapping is assumed (ca" +
                    "se insensitive).\r\n        /// </returns>\r\n        public static IEnumerable<T> Q" +
                    "uery<T>(this IDbConnection cnn, string sql, object param, CommandType commandTyp" +
                    "e)\r\n        {\r\n            return Query<T>(cnn, sql, param, null, true, null, co" +
                    "mmandType);\r\n        }\r\n\r\n        /// <summary>\r\n        /// Executes a query, r" +
                    "eturning the data typed as per T\r\n        /// </summary>\r\n        /// <returns>A" +
                    " sequence of data of the supplied type; if a basic type (int, string, etc) is qu" +
                    "eried then the data from the first column in assumed, otherwise an instance is\r\n" +
                    "        /// created per row, and a direct column-name===member-name mapping is a" +
                    "ssumed (case insensitive).\r\n        /// </returns>\r\n        public static IEnume" +
                    "rable<T> Query<T>(this IDbConnection cnn, string sql, object param, IDbTransacti" +
                    "on transaction, CommandType commandType)\r\n        {\r\n            return Query<T>" +
                    "(cnn, sql, param, transaction, true, null, commandType);\r\n        }\r\n\r\n        /" +
                    "// <summary>\r\n        /// Execute a command that returns multiple result sets, a" +
                    "nd access each in turn\r\n        /// </summary>\r\n        public static GridReader" +
                    " QueryMultiple(this IDbConnection cnn, string sql, object param, IDbTransaction " +
                    "transaction) \r\n        {\r\n            return QueryMultiple(cnn, sql, param, tran" +
                    "saction, null, null);\r\n        }\r\n\r\n        /// <summary>\r\n        /// Execute a" +
                    " command that returns multiple result sets, and access each in turn\r\n        ///" +
                    " </summary>\r\n        public static GridReader QueryMultiple(this IDbConnection c" +
                    "nn, string sql, object param, CommandType commandType) \r\n        {\r\n            " +
                    "return QueryMultiple(cnn, sql, param, null, null, commandType);\r\n        }\r\n\r\n  " +
                    "      /// <summary>\r\n        /// Execute a command that returns multiple result " +
                    "sets, and access each in turn\r\n        /// </summary>\r\n        public static Gri" +
                    "dReader QueryMultiple(this IDbConnection cnn, string sql, object param, IDbTrans" +
                    "action transaction, CommandType commandType)\r\n        {\r\n            return Quer" +
                    "yMultiple(cnn, sql, param, transaction, null, commandType);\r\n        }\r\n#endif\r\n" +
                    "            /// <summary>\r\n            /// Execute parameterized SQL  \r\n        " +
                    "    /// </summary>\r\n            /// <returns>Number of rows affected</returns>\r\n" +
                    "            public static int Execute(\r\n#if CSHARP30\r\n            this IDbConnec" +
                    "tion cnn, string sql, object param, IDbTransaction transaction, int? commandTime" +
                    "out, CommandType? commandType\r\n#else\r\nthis IDbConnection cnn, string sql, dynami" +
                    "c param = null, IDbTransaction transaction = null, int? commandTimeout = null, C" +
                    "ommandType? commandType = null\r\n#endif\r\n)\r\n            {\r\n                IEnume" +
                    "rable multiExec = (object)param as IEnumerable;\r\n                Identity identi" +
                    "ty;\r\n                CacheInfo info = null;\r\n                if (multiExec != nu" +
                    "ll && !(multiExec is string))\r\n                {\r\n                    bool isFir" +
                    "st = true;\r\n                    int total = 0;\r\n                    using (var c" +
                    "md = SetupCommand(cnn, transaction, sql, null, null, commandTimeout, commandType" +
                    "))\r\n                    {\r\n\r\n                        string masterSql = null;\r\n " +
                    "                       foreach (var obj in multiExec)\r\n                        {" +
                    "\r\n                            if (isFirst)\r\n                            {\r\n     " +
                    "                           masterSql = cmd.CommandText;\r\n                       " +
                    "         isFirst = false;\r\n                                identity = new Identi" +
                    "ty(sql, cmd.CommandType, cnn, null, obj.GetType(), null);\r\n                     " +
                    "           info = GetCacheInfo(identity);\r\n                            }\r\n      " +
                    "                      else\r\n                            {\r\n                     " +
                    "           cmd.CommandText = masterSql; // because we do magic replaces on \"in\" " +
                    "etc\r\n                                cmd.Parameters.Clear(); // current code is " +
                    "Add-tastic\r\n                            }\r\n                            info.Para" +
                    "mReader(cmd, obj);\r\n                            total += cmd.ExecuteNonQuery();\r" +
                    "\n                        }\r\n                    }\r\n                    return to" +
                    "tal;\r\n                }\r\n\r\n                // nice and simple\r\n                i" +
                    "f ((object)param != null)\r\n                {\r\n                    identity = new" +
                    " Identity(sql, commandType, cnn, null, (object)param == null ? null : ((object)p" +
                    "aram).GetType(), null);\r\n                    info = GetCacheInfo(identity);\r\n   " +
                    "             }\r\n                return ExecuteCommand(cnn, transaction, sql, (ob" +
                    "ject)param == null ? null : info.ParamReader, (object)param, commandTimeout, com" +
                    "mandType);\r\n            }\r\n#if !CSHARP30\r\n            /// <summary>\r\n           " +
                    " /// Return a list of dynamic objects, reader is closed after the call\r\n        " +
                    "    /// </summary>\r\n            public static IEnumerable<dynamic> Query(this ID" +
                    "bConnection cnn, string sql, dynamic param = null, IDbTransaction transaction = " +
                    "null, bool buffered = true, int? commandTimeout = null, CommandType? commandType" +
                    " = null)\r\n            {\r\n                return Query<DapperRow>(cnn, sql, param" +
                    " as object, transaction, buffered, commandTimeout, commandType);\r\n            }\r" +
                    "\n#else\r\n        /// <summary>\r\n        /// Return a list of dynamic objects, rea" +
                    "der is closed after the call\r\n        /// </summary>\r\n        public static IEnu" +
                    "merable<IDictionary<string, object>> Query(this IDbConnection cnn, string sql, o" +
                    "bject param) {\r\n            return Query(cnn, sql, param, null, true, null, null" +
                    ");\r\n        }\r\n\r\n        /// <summary>\r\n        /// Return a list of dynamic obj" +
                    "ects, reader is closed after the call\r\n        /// </summary>\r\n        public st" +
                    "atic IEnumerable<IDictionary<string, object>> Query(this IDbConnection cnn, stri" +
                    "ng sql, object param, IDbTransaction transaction) {\r\n            return Query(cn" +
                    "n, sql, param, transaction, true, null, null);\r\n        }\r\n\r\n        /// <summar" +
                    "y>\r\n        /// Return a list of dynamic objects, reader is closed after the cal" +
                    "l\r\n        /// </summary>\r\n        public static IEnumerable<IDictionary<string," +
                    " object>> Query(this IDbConnection cnn, string sql, object param, CommandType? c" +
                    "ommandType) {\r\n            return Query(cnn, sql, param, null, true, null, comma" +
                    "ndType);\r\n        }\r\n\r\n        /// <summary>\r\n        /// Return a list of dynam" +
                    "ic objects, reader is closed after the call\r\n        /// </summary>\r\n        pub" +
                    "lic static IEnumerable<IDictionary<string, object>> Query(this IDbConnection cnn" +
                    ", string sql, object param, IDbTransaction transaction, CommandType? commandType" +
                    ") {\r\n            return Query(cnn, sql, param, transaction, true, null, commandT" +
                    "ype);\r\n        }\r\n\r\n        /// <summary>\r\n        /// Return a list of dynamic " +
                    "objects, reader is closed after the call\r\n        /// </summary>\r\n        public" +
                    " static IEnumerable<IDictionary<string,object>> Query(this IDbConnection cnn, st" +
                    "ring sql, object param, IDbTransaction transaction, bool buffered, int? commandT" +
                    "imeout, CommandType? commandType) {\r\n            return Query<IDictionary<string" +
                    ", object>>(cnn, sql, param, transaction, buffered, commandTimeout, commandType);" +
                    "\r\n        }\r\n#endif\r\n\r\n            /// <summary>\r\n            /// Executes a que" +
                    "ry, returning the data typed as per T\r\n            /// </summary>\r\n            /" +
                    "// <remarks>the dynamic param may seem a bit odd, but this works around a major " +
                    "usability issue in vs, if it is Object vs completion gets annoying. Eg type new " +
                    "[space] get new object</remarks>\r\n            /// <returns>A sequence of data of" +
                    " the supplied type; if a basic type (int, string, etc) is queried then the data " +
                    "from the first column in assumed, otherwise an instance is\r\n            /// crea" +
                    "ted per row, and a direct column-name===member-name mapping is assumed (case ins" +
                    "ensitive).\r\n            /// </returns>\r\n            public static IEnumerable<T>" +
                    " Query<T>(\r\n#if CSHARP30\r\n            this IDbConnection cnn, string sql, object" +
                    " param, IDbTransaction transaction, bool buffered, int? commandTimeout, CommandT" +
                    "ype? commandType\r\n#else\r\nthis IDbConnection cnn, string sql, dynamic param = nul" +
                    "l, IDbTransaction transaction = null, bool buffered = true, int? commandTimeout " +
                    "= null, CommandType? commandType = null\r\n#endif\r\n)\r\n            {\r\n             " +
                    "   var data = QueryInternal<T>(cnn, sql, param as object, transaction, commandTi" +
                    "meout, commandType);\r\n                return buffered ? data.ToList() : data;\r\n " +
                    "           }\r\n\r\n            /// <summary>\r\n            /// Execute a command tha" +
                    "t returns multiple result sets, and access each in turn\r\n            /// </summa" +
                    "ry>\r\n            public static GridReader QueryMultiple(\r\n#if CSHARP30\r\n        " +
                    "    this IDbConnection cnn, string sql, object param, IDbTransaction transaction" +
                    ", int? commandTimeout, CommandType? commandType\r\n#else\r\n            this IDbConn" +
                    "ection cnn, string sql, dynamic param = null, IDbTransaction transaction = null," +
                    " int? commandTimeout = null, CommandType? commandType = null\r\n#endif\r\n)\r\n       " +
                    "     {\r\n                Identity identity = new Identity(sql, commandType, cnn, " +
                    "typeof(GridReader), (object)param == null ? null : ((object)param).GetType(), nu" +
                    "ll);\r\n                CacheInfo info = GetCacheInfo(identity);\r\n\r\n              " +
                    "  IDbCommand cmd = null;\r\n                IDataReader reader = null;\r\n          " +
                    "      bool wasClosed = cnn.State == ConnectionState.Closed;\r\n                try" +
                    "\r\n                {\r\n                    if (wasClosed) cnn.Open();\r\n           " +
                    "         cmd = SetupCommand(cnn, transaction, sql, info.ParamReader, (object)par" +
                    "am, commandTimeout, commandType);\r\n                    reader = cmd.ExecuteReade" +
                    "r(wasClosed ? CommandBehavior.CloseConnection : CommandBehavior.Default);\r\n\r\n   " +
                    "                 var result = new GridReader(cmd, reader, identity);\r\n          " +
                    "          wasClosed = false; // *if* the connection was closed and we got this f" +
                    "ar, then we now have a reader\r\n                                       // with th" +
                    "e CloseConnection flag, so the reader will deal with the connection; we\r\n       " +
                    "                                // still need something in the \"finally\" to ensu" +
                    "re that broken SQL still results\r\n                                       // in t" +
                    "he connection closing itself\r\n                    return result;\r\n              " +
                    "  }\r\n                catch\r\n                {\r\n                    if (reader !=" +
                    " null)\r\n                    {\r\n                        if (!reader.IsClosed) try" +
                    " { cmd.Cancel(); }\r\n                            catch { /* don\'t spoil the exist" +
                    "ing exception */ }\r\n                        reader.Dispose();\r\n                 " +
                    "   }\r\n                    if (cmd != null) cmd.Dispose();\r\n                    i" +
                    "f (wasClosed) cnn.Close();\r\n                    throw;\r\n                }\r\n     " +
                    "       }\r\n\r\n            /// <summary>\r\n            /// Return a typed list of ob" +
                    "jects, reader is closed after the call\r\n            /// </summary>\r\n            " +
                    "private static IEnumerable<T> QueryInternal<T>(this IDbConnection cnn, string sq" +
                    "l, object param, IDbTransaction transaction, int? commandTimeout, CommandType? c" +
                    "ommandType)\r\n            {\r\n                var identity = new Identity(sql, com" +
                    "mandType, cnn, typeof(T), param == null ? null : param.GetType(), null);\r\n      " +
                    "          var info = GetCacheInfo(identity);\r\n\r\n                IDbCommand cmd =" +
                    " null;\r\n                IDataReader reader = null;\r\n\r\n                bool wasCl" +
                    "osed = cnn.State == ConnectionState.Closed;\r\n                try\r\n              " +
                    "  {\r\n                    cmd = SetupCommand(cnn, transaction, sql, info.ParamRea" +
                    "der, param, commandTimeout, commandType);\r\n\r\n                    if (wasClosed) " +
                    "cnn.Open();\r\n                    reader = cmd.ExecuteReader(wasClosed ? CommandB" +
                    "ehavior.CloseConnection : CommandBehavior.Default);\r\n                    wasClos" +
                    "ed = false; // *if* the connection was closed and we got this far, then we now h" +
                    "ave a reader\r\n                                       // with the CloseConnection" +
                    " flag, so the reader will deal with the connection; we\r\n                        " +
                    "               // still need something in the \"finally\" to ensure that broken SQ" +
                    "L still results\r\n                                       // in the connection clo" +
                    "sing itself\r\n                    var tuple = info.Deserializer;\r\n               " +
                    "     int hash = GetColumnHash(reader);\r\n                    if (tuple.Func == nu" +
                    "ll || tuple.Hash != hash)\r\n                    {\r\n                        tuple " +
                    "= info.Deserializer = new DeserializerState(hash, GetDeserializer(typeof(T), rea" +
                    "der, 0, -1, false));\r\n                        SetQueryCache(identity, info);\r\n  " +
                    "                  }\r\n\r\n                    var func = tuple.Func;\r\n\r\n           " +
                    "         while (reader.Read())\r\n                    {\r\n                        y" +
                    "ield return (T)func(reader);\r\n                    }\r\n                    // happ" +
                    "y path; close the reader cleanly - no\r\n                    // need for \"Cancel\" " +
                    "etc\r\n                    reader.Dispose();\r\n                    reader = null;\r\n" +
                    "                }\r\n                finally\r\n                {\r\n                 " +
                    "   if (reader != null)\r\n                    {\r\n                        if (!read" +
                    "er.IsClosed) try { cmd.Cancel(); }\r\n                            catch { /* don\'t" +
                    " spoil the existing exception */ }\r\n                        reader.Dispose();\r\n " +
                    "                   }\r\n                    if (wasClosed) cnn.Close();\r\n         " +
                    "           if (cmd != null) cmd.Dispose();\r\n                }\r\n            }\r\n\r\n" +
                    "            /// <summary>\r\n            /// Maps a query to objects\r\n            " +
                    "/// </summary>\r\n            /// <typeparam name=\"TFirst\">The first type in the r" +
                    "ecordset</typeparam>\r\n            /// <typeparam name=\"TSecond\">The second type " +
                    "in the recordset</typeparam>\r\n            /// <typeparam name=\"TReturn\">The retu" +
                    "rn type</typeparam>\r\n            /// <param name=\"cnn\"></param>\r\n            ///" +
                    " <param name=\"sql\"></param>\r\n            /// <param name=\"map\"></param>\r\n       " +
                    "     /// <param name=\"param\"></param>\r\n            /// <param name=\"transaction\"" +
                    "></param>\r\n            /// <param name=\"buffered\"></param>\r\n            /// <par" +
                    "am name=\"splitOn\">The Field we should split and read the second object from (def" +
                    "ault: id)</param>\r\n            /// <param name=\"commandTimeout\">Number of second" +
                    "s before command execution timeout</param>\r\n            /// <param name=\"command" +
                    "Type\">Is it a stored proc or a batch?</param>\r\n            /// <returns></return" +
                    "s>\r\n            public static IEnumerable<TReturn> Query<TFirst, TSecond, TRetur" +
                    "n>(\r\n#if CSHARP30\r\n            this IDbConnection cnn, string sql, Func<TFirst, " +
                    "TSecond, TReturn> map, object param, IDbTransaction transaction, bool buffered, " +
                    "string splitOn, int? commandTimeout, CommandType? commandType\r\n#else\r\nthis IDbCo" +
                    "nnection cnn, string sql, Func<TFirst, TSecond, TReturn> map, dynamic param = nu" +
                    "ll, IDbTransaction transaction = null, bool buffered = true, string splitOn = \"I" +
                    "d\", int? commandTimeout = null, CommandType? commandType = null\r\n#endif\r\n)\r\n    " +
                    "        {\r\n                return MultiMap<TFirst, TSecond, DontMap, DontMap, Do" +
                    "ntMap, TReturn>(cnn, sql, map, param as object, transaction, buffered, splitOn, " +
                    "commandTimeout, commandType);\r\n            }\r\n\r\n            /// <summary>\r\n     " +
                    "       /// Maps a query to objects\r\n            /// </summary>\r\n            /// " +
                    "<typeparam name=\"TFirst\"></typeparam>\r\n            /// <typeparam name=\"TSecond\"" +
                    "></typeparam>\r\n            /// <typeparam name=\"TThird\"></typeparam>\r\n          " +
                    "  /// <typeparam name=\"TReturn\"></typeparam>\r\n            /// <param name=\"cnn\">" +
                    "</param>\r\n            /// <param name=\"sql\"></param>\r\n            /// <param nam" +
                    "e=\"map\"></param>\r\n            /// <param name=\"param\"></param>\r\n            /// " +
                    "<param name=\"transaction\"></param>\r\n            /// <param name=\"buffered\"></par" +
                    "am>\r\n            /// <param name=\"splitOn\">The Field we should split and read th" +
                    "e second object from (default: id)</param>\r\n            /// <param name=\"command" +
                    "Timeout\">Number of seconds before command execution timeout</param>\r\n           " +
                    " /// <param name=\"commandType\"></param>\r\n            /// <returns></returns>\r\n  " +
                    "          public static IEnumerable<TReturn> Query<TFirst, TSecond, TThird, TRet" +
                    "urn>(\r\n#if CSHARP30\r\n            this IDbConnection cnn, string sql, Func<TFirst" +
                    ", TSecond, TThird, TReturn> map, object param, IDbTransaction transaction, bool " +
                    "buffered, string splitOn, int? commandTimeout, CommandType? commandType\r\n#else\r\n" +
                    "this IDbConnection cnn, string sql, Func<TFirst, TSecond, TThird, TReturn> map, " +
                    "dynamic param = null, IDbTransaction transaction = null, bool buffered = true, s" +
                    "tring splitOn = \"Id\", int? commandTimeout = null, CommandType? commandType = nul" +
                    "l\r\n#endif\r\n)\r\n            {\r\n                return MultiMap<TFirst, TSecond, TT" +
                    "hird, DontMap, DontMap, TReturn>(cnn, sql, map, param as object, transaction, bu" +
                    "ffered, splitOn, commandTimeout, commandType);\r\n            }\r\n\r\n            ///" +
                    " <summary>\r\n            /// Perform a multi mapping query with 4 input parameter" +
                    "s\r\n            /// </summary>\r\n            /// <typeparam name=\"TFirst\"></typepa" +
                    "ram>\r\n            /// <typeparam name=\"TSecond\"></typeparam>\r\n            /// <t" +
                    "ypeparam name=\"TThird\"></typeparam>\r\n            /// <typeparam name=\"TFourth\"><" +
                    "/typeparam>\r\n            /// <typeparam name=\"TReturn\"></typeparam>\r\n           " +
                    " /// <param name=\"cnn\"></param>\r\n            /// <param name=\"sql\"></param>\r\n   " +
                    "         /// <param name=\"map\"></param>\r\n            /// <param name=\"param\"></p" +
                    "aram>\r\n            /// <param name=\"transaction\"></param>\r\n            /// <para" +
                    "m name=\"buffered\"></param>\r\n            /// <param name=\"splitOn\"></param>\r\n    " +
                    "        /// <param name=\"commandTimeout\"></param>\r\n            /// <param name=\"" +
                    "commandType\"></param>\r\n            /// <returns></returns>\r\n            public s" +
                    "tatic IEnumerable<TReturn> Query<TFirst, TSecond, TThird, TFourth, TReturn>(\r\n#i" +
                    "f CSHARP30\r\n            this IDbConnection cnn, string sql, Func<TFirst, TSecond" +
                    ", TThird, TFourth, TReturn> map, object param, IDbTransaction transaction, bool " +
                    "buffered, string splitOn, int? commandTimeout, CommandType? commandType\r\n#else\r\n" +
                    "this IDbConnection cnn, string sql, Func<TFirst, TSecond, TThird, TFourth, TRetu" +
                    "rn> map, dynamic param = null, IDbTransaction transaction = null, bool buffered " +
                    "= true, string splitOn = \"Id\", int? commandTimeout = null, CommandType? commandT" +
                    "ype = null\r\n#endif\r\n)\r\n            {\r\n                return MultiMap<TFirst, TS" +
                    "econd, TThird, TFourth, DontMap, TReturn>(cnn, sql, map, param as object, transa" +
                    "ction, buffered, splitOn, commandTimeout, commandType);\r\n            }\r\n#if !CSH" +
                    "ARP30\r\n            /// <summary>\r\n            /// Perform a multi mapping query " +
                    "with 5 input parameters\r\n            /// </summary>\r\n            /// <typeparam " +
                    "name=\"TFirst\"></typeparam>\r\n            /// <typeparam name=\"TSecond\"></typepara" +
                    "m>\r\n            /// <typeparam name=\"TThird\"></typeparam>\r\n            /// <type" +
                    "param name=\"TFourth\"></typeparam>\r\n            /// <typeparam name=\"TFifth\"></ty" +
                    "peparam>\r\n            /// <typeparam name=\"TReturn\"></typeparam>\r\n            //" +
                    "/ <param name=\"cnn\"></param>\r\n            /// <param name=\"sql\"></param>\r\n      " +
                    "      /// <param name=\"map\"></param>\r\n            /// <param name=\"param\"></para" +
                    "m>\r\n            /// <param name=\"transaction\"></param>\r\n            /// <param n" +
                    "ame=\"buffered\"></param>\r\n            /// <param name=\"splitOn\"></param>\r\n       " +
                    "     /// <param name=\"commandTimeout\"></param>\r\n            /// <param name=\"com" +
                    "mandType\"></param>\r\n            /// <returns></returns>\r\n            public stat" +
                    "ic IEnumerable<TReturn> Query<TFirst, TSecond, TThird, TFourth, TFifth, TReturn>" +
                    "(this IDbConnection cnn, string sql, Func<TFirst, TSecond, TThird, TFourth, TFif" +
                    "th, TReturn> map, dynamic param = null, IDbTransaction transaction = null, bool " +
                    "buffered = true, string splitOn = \"Id\", int? commandTimeout = null, CommandType?" +
                    " commandType = null)\r\n            {\r\n                return MultiMap<TFirst, TSe" +
                    "cond, TThird, TFourth, TFifth, TReturn>(cnn, sql, map, param as object, transact" +
                    "ion, buffered, splitOn, commandTimeout, commandType);\r\n            }\r\n#endif\r\n  " +
                    "          partial class DontMap { }\r\n            static IEnumerable<TReturn> Mul" +
                    "tiMap<TFirst, TSecond, TThird, TFourth, TFifth, TReturn>(\r\n                this " +
                    "IDbConnection cnn, string sql, object map, object param, IDbTransaction transact" +
                    "ion, bool buffered, string splitOn, int? commandTimeout, CommandType? commandTyp" +
                    "e)\r\n            {\r\n                var results = MultiMapImpl<TFirst, TSecond, T" +
                    "Third, TFourth, TFifth, TReturn>(cnn, sql, map, param, transaction, splitOn, com" +
                    "mandTimeout, commandType, null, null);\r\n                return buffered ? result" +
                    "s.ToList() : results;\r\n            }\r\n\r\n\r\n            static IEnumerable<TReturn" +
                    "> MultiMapImpl<TFirst, TSecond, TThird, TFourth, TFifth, TReturn>(this IDbConnec" +
                    "tion cnn, string sql, object map, object param, IDbTransaction transaction, stri" +
                    "ng splitOn, int? commandTimeout, CommandType? commandType, IDataReader reader, I" +
                    "dentity identity)\r\n            {\r\n                identity = identity ?? new Ide" +
                    "ntity(sql, commandType, cnn, typeof(TFirst), (object)param == null ? null : ((ob" +
                    "ject)param).GetType(), new[] { typeof(TFirst), typeof(TSecond), typeof(TThird), " +
                    "typeof(TFourth), typeof(TFifth) });\r\n                CacheInfo cinfo = GetCacheI" +
                    "nfo(identity);\r\n\r\n                IDbCommand ownedCommand = null;\r\n             " +
                    "   IDataReader ownedReader = null;\r\n\r\n                try\r\n                {\r\n  " +
                    "                  if (reader == null)\r\n                    {\r\n                  " +
                    "      ownedCommand = SetupCommand(cnn, transaction, sql, cinfo.ParamReader, (obj" +
                    "ect)param, commandTimeout, commandType);\r\n                        ownedReader = " +
                    "ownedCommand.ExecuteReader();\r\n                        reader = ownedReader;\r\n  " +
                    "                  }\r\n                    DeserializerState deserializer = defaul" +
                    "t(DeserializerState);\r\n                    Func<IDataReader, object>[] otherDese" +
                    "rializers = null;\r\n\r\n                    int hash = GetColumnHash(reader);\r\n    " +
                    "                if ((deserializer = cinfo.Deserializer).Func == null || (otherDe" +
                    "serializers = cinfo.OtherDeserializers) == null || hash != deserializer.Hash)\r\n " +
                    "                   {\r\n                        var deserializers = GenerateDeseri" +
                    "alizers(new Type[] { typeof(TFirst), typeof(TSecond), typeof(TThird), typeof(TFo" +
                    "urth), typeof(TFifth) }, splitOn, reader);\r\n                        deserializer" +
                    " = cinfo.Deserializer = new DeserializerState(hash, deserializers[0]);\r\n        " +
                    "                otherDeserializers = cinfo.OtherDeserializers = deserializers.Sk" +
                    "ip(1).ToArray();\r\n                        SetQueryCache(identity, cinfo);\r\n     " +
                    "               }\r\n\r\n                    Func<IDataReader, TReturn> mapIt = Gener" +
                    "ateMapper<TFirst, TSecond, TThird, TFourth, TFifth, TReturn>(deserializer.Func, " +
                    "otherDeserializers, map);\r\n\r\n                    if (mapIt != null)\r\n           " +
                    "         {\r\n                        while (reader.Read())\r\n                     " +
                    "   {\r\n                            yield return mapIt(reader);\r\n                 " +
                    "       }\r\n                    }\r\n                }\r\n                finally\r\n   " +
                    "             {\r\n                    try\r\n                    {\r\n                " +
                    "        if (ownedReader != null)\r\n                        {\r\n                   " +
                    "         ownedReader.Dispose();\r\n                        }\r\n                    " +
                    "}\r\n                    finally\r\n                    {\r\n                        i" +
                    "f (ownedCommand != null)\r\n                        {\r\n                           " +
                    " ownedCommand.Dispose();\r\n                        }\r\n                    }\r\n    " +
                    "            }\r\n            }\r\n\r\n            private static Func<IDataReader, TRe" +
                    "turn> GenerateMapper<TFirst, TSecond, TThird, TFourth, TFifth, TReturn>(Func<IDa" +
                    "taReader, object> deserializer, Func<IDataReader, object>[] otherDeserializers, " +
                    "object map)\r\n            {\r\n                switch (otherDeserializers.Length)\r\n" +
                    "                {\r\n                    case 1:\r\n                        return r" +
                    " => ((Func<TFirst, TSecond, TReturn>)map)((TFirst)deserializer(r), (TSecond)othe" +
                    "rDeserializers[0](r));\r\n                    case 2:\r\n                        ret" +
                    "urn r => ((Func<TFirst, TSecond, TThird, TReturn>)map)((TFirst)deserializer(r), " +
                    "(TSecond)otherDeserializers[0](r), (TThird)otherDeserializers[1](r));\r\n         " +
                    "           case 3:\r\n                        return r => ((Func<TFirst, TSecond, " +
                    "TThird, TFourth, TReturn>)map)((TFirst)deserializer(r), (TSecond)otherDeserializ" +
                    "ers[0](r), (TThird)otherDeserializers[1](r), (TFourth)otherDeserializers[2](r));" +
                    "\r\n#if !CSHARP30\r\n                    case 4:\r\n                        return r =" +
                    "> ((Func<TFirst, TSecond, TThird, TFourth, TFifth, TReturn>)map)((TFirst)deseria" +
                    "lizer(r), (TSecond)otherDeserializers[0](r), (TThird)otherDeserializers[1](r), (" +
                    "TFourth)otherDeserializers[2](r), (TFifth)otherDeserializers[3](r));\r\n#endif\r\n  " +
                    "                  default:\r\n                        throw new NotSupportedExcept" +
                    "ion();\r\n                }\r\n            }\r\n\r\n            private static Func<IDat" +
                    "aReader, object>[] GenerateDeserializers(Type[] types, string splitOn, IDataRead" +
                    "er reader)\r\n            {\r\n                int current = 0;\r\n                var" +
                    " splits = splitOn.Split(\',\').ToArray();\r\n                var splitIndex = 0;\r\n\r\n" +
                    "                Func<Type, int> nextSplit = type =>\r\n                {\r\n        " +
                    "            var currentSplit = splits[splitIndex].Trim();\r\n                    i" +
                    "f (splits.Length > splitIndex + 1)\r\n                    {\r\n                     " +
                    "   splitIndex++;\r\n                    }\r\n\r\n                    bool skipFirst = " +
                    "false;\r\n                    int startingPos = current + 1;\r\n                    " +
                    "// if our current type has the split, skip the first time you see it. \r\n        " +
                    "            if (type != typeof(Object))\r\n                    {\r\n                " +
                    "        var props = DefaultTypeMap.GetSettableProps(type);\r\n                    " +
                    "    var fields = DefaultTypeMap.GetSettableFields(type);\r\n\r\n                    " +
                    "    foreach (var name in props.Select(p => p.Name).Concat(fields.Select(f => f.N" +
                    "ame)))\r\n                        {\r\n                            if (string.Equals" +
                    "(name, currentSplit, StringComparison.OrdinalIgnoreCase))\r\n                     " +
                    "       {\r\n                                skipFirst = true;\r\n                   " +
                    "             startingPos = current;\r\n                                break;\r\n   " +
                    "                         }\r\n                        }\r\n\r\n                    }\r\n" +
                    "\r\n                    int pos;\r\n                    for (pos = startingPos; pos " +
                    "< reader.FieldCount; pos++)\r\n                    {\r\n                        // s" +
                    "ome people like ID some id ... assuming case insensitive splits for now\r\n       " +
                    "                 if (splitOn == \"*\")\r\n                        {\r\n               " +
                    "             break;\r\n                        }\r\n                        if (stri" +
                    "ng.Equals(reader.GetName(pos), currentSplit, StringComparison.OrdinalIgnoreCase)" +
                    ")\r\n                        {\r\n                            if (skipFirst)\r\n      " +
                    "                      {\r\n                                skipFirst = false;\r\n   " +
                    "                         }\r\n                            else\r\n                  " +
                    "          {\r\n                                break;\r\n                           " +
                    " }\r\n                        }\r\n                    }\r\n                    curren" +
                    "t = pos;\r\n                    return pos;\r\n                };\r\n\r\n               " +
                    " var deserializers = new List<Func<IDataReader, object>>();\r\n                int" +
                    " split = 0;\r\n                bool first = true;\r\n                foreach (var ty" +
                    "pe in types)\r\n                {\r\n                    if (type != typeof(DontMap)" +
                    ")\r\n                    {\r\n                        int next = nextSplit(type);\r\n " +
                    "                       deserializers.Add(GetDeserializer(type, reader, split, ne" +
                    "xt - split, /* returnNullIfFirstMissing: */ !first));\r\n                        f" +
                    "irst = false;\r\n                        split = next;\r\n                    }\r\n   " +
                    "             }\r\n\r\n                return deserializers.ToArray();\r\n            }" +
                    "\r\n\r\n            private static CacheInfo GetCacheInfo(Identity identity)\r\n      " +
                    "      {\r\n                CacheInfo info;\r\n                if (!TryGetQueryCache(" +
                    "identity, out info))\r\n                {\r\n                    info = new CacheInf" +
                    "o();\r\n                    if (identity.parametersType != null)\r\n                " +
                    "    {\r\n                        if (typeof(IDynamicParameters).IsAssignableFrom(i" +
                    "dentity.parametersType))\r\n                        {\r\n                           " +
                    " info.ParamReader = (cmd, obj) => { (obj as IDynamicParameters).AddParameters(cm" +
                    "d, identity); };\r\n                        }\r\n#if !CSHARP30\r\n                    " +
                    "    else if (typeof(IEnumerable<KeyValuePair<string, object>>).IsAssignableFrom(" +
                    "identity.parametersType) && typeof(System.Dynamic.IDynamicMetaObjectProvider).Is" +
                    "AssignableFrom(identity.parametersType))\r\n                        {\r\n           " +
                    "                 info.ParamReader = (cmd, obj) =>\r\n                            {" +
                    "\r\n                                IDynamicParameters mapped = new DynamicParamet" +
                    "ers(obj);\r\n                                mapped.AddParameters(cmd, identity);\r" +
                    "\n                            };\r\n                        }\r\n#endif\r\n            " +
                    "            else\r\n                        {\r\n                            info.Pa" +
                    "ramReader = CreateParamInfoGenerator(identity, false);\r\n                        " +
                    "}\r\n                    }\r\n                    SetQueryCache(identity, info);\r\n  " +
                    "              }\r\n                return info;\r\n            }\r\n\r\n            priv" +
                    "ate static Func<IDataReader, object> GetDeserializer(Type type, IDataReader read" +
                    "er, int startBound, int length, bool returnNullIfFirstMissing)\r\n            {\r\n#" +
                    "if !CSHARP30\r\n                // dynamic is passed in as Object ... by c# design" +
                    "\r\n                if (type == typeof(object)\r\n                    || type == typ" +
                    "eof(DapperRow))\r\n                {\r\n                    return GetDapperRowDeser" +
                    "ializer(reader, startBound, length, returnNullIfFirstMissing);\r\n                " +
                    "}\r\n#else\r\n            if(type.IsAssignableFrom(typeof(Dictionary<string,object>)" +
                    "))\r\n            {\r\n                return GetDictionaryDeserializer(reader, star" +
                    "tBound, length, returnNullIfFirstMissing);\r\n            }\r\n#endif\r\n             " +
                    "   Type underlyingType = null;\r\n                if (!(typeMap.ContainsKey(type) " +
                    "|| type.IsEnum || type.FullName == LinqBinary ||\r\n                    (type.IsVa" +
                    "lueType && (underlyingType = Nullable.GetUnderlyingType(type)) != null && underl" +
                    "yingType.IsEnum)))\r\n                {\r\n                    return GetTypeDeseria" +
                    "lizer(type, reader, startBound, length, returnNullIfFirstMissing);\r\n            " +
                    "    }\r\n                return GetStructDeserializer(type, underlyingType ?? type" +
                    ", startBound);\r\n\r\n            }\r\n\r\n#if !CSHARP30\r\n            sealed partial cla" +
                    "ss DapperTable\r\n            {\r\n                string[] fieldNames;\r\n           " +
                    "     readonly Dictionary<string, int> fieldNameLookup;\r\n\r\n                intern" +
                    "al string[] FieldNames { get { return fieldNames; } }\r\n\r\n                public " +
                    "DapperTable(string[] fieldNames)\r\n                {\r\n                    if (fie" +
                    "ldNames == null) throw new ArgumentNullException(\"fieldNames\");\r\n               " +
                    "     this.fieldNames = fieldNames;\r\n\r\n                    fieldNameLookup = new " +
                    "Dictionary<string, int>(fieldNames.Length, StringComparer.Ordinal);\r\n           " +
                    "         // if there are dups, we want the **first** key to be the \"winner\" - so" +
                    " iterate backwards\r\n                    for (int i = fieldNames.Length - 1; i >=" +
                    " 0; i--)\r\n                    {\r\n                        string key = fieldNames" +
                    "[i];\r\n                        if (key != null) fieldNameLookup[key] = i;\r\n      " +
                    "              }\r\n                }\r\n\r\n                internal int IndexOfName(s" +
                    "tring name)\r\n                {\r\n                    int result;\r\n               " +
                    "     return (name != null && fieldNameLookup.TryGetValue(name, out result)) ? re" +
                    "sult : -1;\r\n                }\r\n                internal int AddField(string name" +
                    ")\r\n                {\r\n                    if (name == null) throw new ArgumentNu" +
                    "llException(\"name\");\r\n                    if (fieldNameLookup.ContainsKey(name))" +
                    " throw new InvalidOperationException(\"Field already exists: \" + name);\r\n        " +
                    "            int oldLen = fieldNames.Length;\r\n                    Array.Resize(re" +
                    "f fieldNames, oldLen + 1); // yes, this is sub-optimal, but this is not the expe" +
                    "cted common case\r\n                    fieldNameLookup[name] = oldLen;\r\n         " +
                    "           return oldLen;\r\n                }\r\n\r\n\r\n                internal bool " +
                    "FieldExists(string key)\r\n                {\r\n                    return key != nu" +
                    "ll && fieldNameLookup.ContainsKey(key);\r\n                }\r\n\r\n                pu" +
                    "blic int FieldCount { get { return fieldNames.Length; } }\r\n            }\r\n\r\n    " +
                    "        sealed partial class DapperRowMetaObject : System.Dynamic.DynamicMetaObj" +
                    "ect\r\n            {\r\n                static readonly MethodInfo getValueMethod = " +
                    "typeof(IDictionary<string, object>).GetProperty(\"Item\").GetGetMethod();\r\n       " +
                    "         static readonly MethodInfo setValueMethod = typeof(DapperRow).GetMethod" +
                    "(\"SetValue\");\r\n\r\n                public DapperRowMetaObject(\r\n                  " +
                    "  System.Linq.Expressions.Expression expression,\r\n                    System.Dyn" +
                    "amic.BindingRestrictions restrictions\r\n                    )\r\n                  " +
                    "  : base(expression, restrictions)\r\n                {\r\n                }\r\n\r\n    " +
                    "            public DapperRowMetaObject(\r\n                    System.Linq.Express" +
                    "ions.Expression expression,\r\n                    System.Dynamic.BindingRestricti" +
                    "ons restrictions,\r\n                    object value\r\n                    )\r\n    " +
                    "                : base(expression, restrictions, value)\r\n                {\r\n    " +
                    "            }\r\n\r\n                System.Dynamic.DynamicMetaObject CallMethod(\r\n " +
                    "                   MethodInfo method,\r\n                    System.Linq.Expressio" +
                    "ns.Expression[] parameters\r\n                    )\r\n                {\r\n          " +
                    "          var callMethod = new System.Dynamic.DynamicMetaObject(\r\n              " +
                    "          System.Linq.Expressions.Expression.Call(\r\n                            " +
                    "System.Linq.Expressions.Expression.Convert(Expression, LimitType),\r\n            " +
                    "                method,\r\n                            parameters),\r\n             " +
                    "           System.Dynamic.BindingRestrictions.GetTypeRestriction(Expression, Lim" +
                    "itType)\r\n                        );\r\n                    return callMethod;\r\n   " +
                    "             }\r\n\r\n                public override System.Dynamic.DynamicMetaObje" +
                    "ct BindGetMember(System.Dynamic.GetMemberBinder binder)\r\n                {\r\n    " +
                    "                var parameters = new System.Linq.Expressions.Expression[]\r\n     " +
                    "                                    {\r\n                                         " +
                    "System.Linq.Expressions.Expression.Constant(binder.Name)\r\n                      " +
                    "                   };\r\n\r\n                    var callMethod = CallMethod(getValu" +
                    "eMethod, parameters);\r\n\r\n                    return callMethod;\r\n               " +
                    " }\r\n\r\n                public override System.Dynamic.DynamicMetaObject BindSetMe" +
                    "mber(System.Dynamic.SetMemberBinder binder, System.Dynamic.DynamicMetaObject val" +
                    "ue)\r\n                {\r\n                    var parameters = new System.Linq.Exp" +
                    "ressions.Expression[]\r\n                                         {\r\n             " +
                    "                            System.Linq.Expressions.Expression.Constant(binder.N" +
                    "ame),\r\n                                         value.Expression,\r\n             " +
                    "                            };\r\n\r\n                    var callMethod = CallMetho" +
                    "d(setValueMethod, parameters);\r\n\r\n                    return callMethod;\r\n      " +
                    "          }\r\n            }\r\n\r\n            sealed partial class DapperRow\r\n      " +
                    "          : System.Dynamic.IDynamicMetaObjectProvider\r\n                , IDictio" +
                    "nary<string, object>\r\n            {\r\n                readonly DapperTable table;" +
                    "\r\n                object[] values;\r\n\r\n                public DapperRow(DapperTab" +
                    "le table, object[] values)\r\n                {\r\n                    if (table == " +
                    "null) throw new ArgumentNullException(\"table\");\r\n                    if (values " +
                    "== null) throw new ArgumentNullException(\"values\");\r\n                    this.ta" +
                    "ble = table;\r\n                    this.values = values;\r\n                }\r\n    " +
                    "            private sealed class DeadValue\r\n                {\r\n                 " +
                    "   public static readonly DeadValue Default = new DeadValue();\r\n                " +
                    "    private DeadValue() { }\r\n                }\r\n                int ICollection<" +
                    "KeyValuePair<string, object>>.Count\r\n                {\r\n                    get\r" +
                    "\n                    {\r\n                        int count = 0;\r\n                " +
                    "        for (int i = 0; i < values.Length; i++)\r\n                        {\r\n    " +
                    "                        if (!(values[i] is DeadValue)) count++;\r\n               " +
                    "         }\r\n                        return count;\r\n                    }\r\n      " +
                    "          }\r\n\r\n                public bool TryGetValue(string name, out object v" +
                    "alue)\r\n                {\r\n                    var index = table.IndexOfName(name" +
                    ");\r\n                    if (index < 0)\r\n                    { // doesn\'t exist\r\n" +
                    "                        value = null;\r\n                        return false;\r\n  " +
                    "                  }\r\n                    // exists, **even if** we don\'t have a " +
                    "value; consider table rows heterogeneous\r\n                    value = index < va" +
                    "lues.Length ? values[index] : null;\r\n                    if (value is DeadValue)" +
                    "\r\n                    { // pretend it isn\'t here\r\n                        value " +
                    "= null;\r\n                        return false;\r\n                    }\r\n         " +
                    "           return true;\r\n                }\r\n\r\n                public override st" +
                    "ring ToString()\r\n                {\r\n                    var sb = new StringBuild" +
                    "er(\"{DapperRow\");\r\n                    foreach (var kv in this)\r\n               " +
                    "     {\r\n                        var value = kv.Value;\r\n                        s" +
                    "b.Append(\", \").Append(kv.Key);\r\n                        if (value != null)\r\n    " +
                    "                    {\r\n                            sb.Append(\" = \'\").Append(kv.V" +
                    "alue).Append(\'\\\'\');\r\n                        }\r\n                        else\r\n  " +
                    "                      {\r\n                            sb.Append(\" = NULL\");\r\n    " +
                    "                    }\r\n                    }\r\n\r\n                    return sb.Ap" +
                    "pend(\'}\').ToString();\r\n                }\r\n\r\n                System.Dynamic.Dynam" +
                    "icMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(\r\n         " +
                    "           System.Linq.Expressions.Expression parameter)\r\n                {\r\n   " +
                    "                 return new DapperRowMetaObject(parameter, System.Dynamic.Bindin" +
                    "gRestrictions.Empty, this);\r\n                }\r\n\r\n                public IEnumer" +
                    "ator<KeyValuePair<string, object>> GetEnumerator()\r\n                {\r\n         " +
                    "           var names = table.FieldNames;\r\n                    for (var i = 0; i " +
                    "< names.Length; i++)\r\n                    {\r\n                        object valu" +
                    "e = i < values.Length ? values[i] : null;\r\n                        if (!(value i" +
                    "s DeadValue))\r\n                        {\r\n                            yield retu" +
                    "rn new KeyValuePair<string, object>(names[i], value);\r\n                        }" +
                    "\r\n                    }\r\n                }\r\n\r\n                IEnumerator IEnume" +
                    "rable.GetEnumerator()\r\n                {\r\n                    return GetEnumerat" +
                    "or();\r\n                }\r\n\r\n                #region Implementation of ICollectio" +
                    "n<KeyValuePair<string,object>>\r\n\r\n                void ICollection<KeyValuePair<" +
                    "string, object>>.Add(KeyValuePair<string, object> item)\r\n                {\r\n    " +
                    "                IDictionary<string, object> dic = this;\r\n                    dic" +
                    ".Add(item.Key, item.Value);\r\n                }\r\n\r\n                void ICollecti" +
                    "on<KeyValuePair<string, object>>.Clear()\r\n                { // removes values fo" +
                    "r **this row**, but doesn\'t change the fundamental table\r\n                    fo" +
                    "r (int i = 0; i < values.Length; i++)\r\n                        values[i] = DeadV" +
                    "alue.Default;\r\n                }\r\n\r\n                bool ICollection<KeyValuePai" +
                    "r<string, object>>.Contains(KeyValuePair<string, object> item)\r\n                " +
                    "{\r\n                    object value;\r\n                    return TryGetValue(ite" +
                    "m.Key, out value) && Equals(value, item.Value);\r\n                }\r\n\r\n          " +
                    "      void ICollection<KeyValuePair<string, object>>.CopyTo(KeyValuePair<string," +
                    " object>[] array, int arrayIndex)\r\n                {\r\n                    foreac" +
                    "h (var kv in this)\r\n                    {\r\n                        array[arrayIn" +
                    "dex++] = kv; // if they didn\'t leave enough space; not our fault\r\n              " +
                    "      }\r\n                }\r\n\r\n                bool ICollection<KeyValuePair<stri" +
                    "ng, object>>.Remove(KeyValuePair<string, object> item)\r\n                {\r\n     " +
                    "               IDictionary<string, object> dic = this;\r\n                    retu" +
                    "rn dic.Remove(item.Key);\r\n                }\r\n\r\n                bool ICollection<" +
                    "KeyValuePair<string, object>>.IsReadOnly\r\n                {\r\n                   " +
                    " get { return false; }\r\n                }\r\n\r\n                #endregion\r\n\r\n     " +
                    "           #region Implementation of IDictionary<string,object>\r\n\r\n             " +
                    "   bool IDictionary<string, object>.ContainsKey(string key)\r\n                {\r\n" +
                    "                    int index = table.IndexOfName(key);\r\n                    if " +
                    "(index < 0 || index >= values.Length || values[index] is DeadValue) return false" +
                    ";\r\n                    return true;\r\n                }\r\n\r\n                void I" +
                    "Dictionary<string, object>.Add(string key, object value)\r\n                {\r\n   " +
                    "                 IDictionary<string, object> dic = this;\r\n                    di" +
                    "c[key] = value;\r\n                }\r\n\r\n                bool IDictionary<string, o" +
                    "bject>.Remove(string key)\r\n                {\r\n                    int index = ta" +
                    "ble.IndexOfName(key);\r\n                    if (index < 0 || index >= values.Leng" +
                    "th || values[index] is DeadValue) return false;\r\n                    values[inde" +
                    "x] = DeadValue.Default;\r\n                    return true;\r\n                }\r\n\r\n" +
                    "                object IDictionary<string, object>.this[string key]\r\n           " +
                    "     {\r\n                    get { object val; TryGetValue(key, out val); return " +
                    "val; }\r\n                    set { SetValue(key, value); }\r\n                }\r\n  " +
                    "              public object SetValue(string key, object value)\r\n                " +
                    "{\r\n                    if (key == null) throw new ArgumentNullException(\"key\");\r" +
                    "\n                    int index = table.IndexOfName(key);\r\n                    if" +
                    " (index < 0)\r\n                    {\r\n                        index = table.AddFi" +
                    "eld(key);\r\n                    }\r\n                    if (values.Length <= index" +
                    ")\r\n                    {   // we\'ll assume they\'re doing lots of things, and\r\n  " +
                    "                      // grow it to the full width of the table\r\n               " +
                    "         Array.Resize(ref values, table.FieldCount);\r\n                    }\r\n   " +
                    "                 return values[index] = value;\r\n                }\r\n\r\n           " +
                    "     ICollection<string> IDictionary<string, object>.Keys\r\n                {\r\n  " +
                    "                  get { return this.Select(kv => kv.Key).ToArray(); }\r\n         " +
                    "       }\r\n\r\n                ICollection<object> IDictionary<string, object>.Valu" +
                    "es\r\n                {\r\n                    get { return this.Select(kv => kv.Val" +
                    "ue).ToArray(); }\r\n                }\r\n\r\n                #endregion\r\n            }" +
                    "\r\n#endif\r\n\r\n#if !CSHARP30\r\n            internal static Func<IDataReader, object>" +
                    " GetDapperRowDeserializer(IDataRecord reader, int startBound, int length, bool r" +
                    "eturnNullIfFirstMissing)\r\n            {\r\n                var fieldCount = reader" +
                    ".FieldCount;\r\n                if (length == -1)\r\n                {\r\n            " +
                    "        length = fieldCount - startBound;\r\n                }\r\n\r\n                " +
                    "if (fieldCount <= startBound)\r\n                {\r\n                    throw new " +
                    "ArgumentException(\"When using the multi-mapping APIs ensure you set the splitOn " +
                    "param if you have keys other than Id\", \"splitOn\");\r\n                }\r\n\r\n       " +
                    "         var effectiveFieldCount = fieldCount - startBound;\r\n\r\n                D" +
                    "apperTable table = null;\r\n\r\n                return\r\n                    r =>\r\n  " +
                    "                  {\r\n                        if (table == null)\r\n               " +
                    "         {\r\n                            string[] names = new string[effectiveFie" +
                    "ldCount];\r\n                            for (int i = 0; i < effectiveFieldCount; " +
                    "i++)\r\n                            {\r\n                                names[i] = " +
                    "r.GetName(i + startBound);\r\n                            }\r\n                     " +
                    "       table = new DapperTable(names);\r\n                        }\r\n\r\n           " +
                    "             var values = new object[effectiveFieldCount];\r\n\r\n                  " +
                    "      if (returnNullIfFirstMissing)\r\n                        {\r\n                " +
                    "            values[0] = r.GetValue(startBound);\r\n                            if " +
                    "(values[0] is DBNull)\r\n                            {\r\n                          " +
                    "      return null;\r\n                            }\r\n                        }\r\n\r\n" +
                    "                        if (startBound == 0)\r\n                        {\r\n       " +
                    "                     r.GetValues(values);\r\n                        }\r\n          " +
                    "              else\r\n                        {\r\n                            var b" +
                    "egin = returnNullIfFirstMissing ? 1 : 0;\r\n                            for (var i" +
                    "ter = begin; iter < effectiveFieldCount; ++iter)\r\n                            {\r" +
                    "\n                                values[iter] = r.GetValue(iter + startBound);\r\n" +
                    "                            }\r\n                        }\r\n                      " +
                    "  return new DapperRow(table, values);\r\n                    };\r\n            }\r\n#" +
                    "else\r\n        internal static Func<IDataReader, object> GetDictionaryDeserialize" +
                    "r(IDataRecord reader, int startBound, int length, bool returnNullIfFirstMissing)" +
                    "\r\n        {\r\n            var fieldCount = reader.FieldCount;\r\n            if (le" +
                    "ngth == -1)\r\n            {\r\n                length = fieldCount - startBound;\r\n " +
                    "           }\r\n\r\n            if (fieldCount <= startBound)\r\n            {\r\n      " +
                    "          throw new ArgumentException(\"When using the multi-mapping APIs ensure " +
                    "you set the splitOn param if you have keys other than Id\", \"splitOn\");\r\n        " +
                    "    }\r\n\r\n            return\r\n                 r =>\r\n                 {\r\n        " +
                    "             IDictionary<string, object> row = new Dictionary<string, object>(le" +
                    "ngth);\r\n                     for (var i = startBound; i < startBound + length; i" +
                    "++)\r\n                     {\r\n                         var tmp = r.GetValue(i);\r\n" +
                    "                         tmp = tmp == DBNull.Value ? null : tmp;\r\n              " +
                    "           row[r.GetName(i)] = tmp;\r\n                         if (returnNullIfFi" +
                    "rstMissing && i == startBound && tmp == null)\r\n                         {\r\n     " +
                    "                        return null;\r\n                         }\r\n              " +
                    "       }\r\n                     return row;\r\n                 };\r\n        }\r\n#end" +
                    "if\r\n            /// <summary>\r\n            /// Internal use only\r\n            //" +
                    "/ </summary>\r\n            /// <param name=\"value\"></param>\r\n            /// <ret" +
                    "urns></returns>\r\n            [Browsable(false), EditorBrowsable(EditorBrowsableS" +
                    "tate.Never)]\r\n            [Obsolete(\"This method is for internal usage only\", fa" +
                    "lse)]\r\n            public static char ReadChar(object value)\r\n            {\r\n   " +
                    "             if (value == null || value is DBNull) throw new ArgumentNullExcepti" +
                    "on(\"value\");\r\n                string s = value as string;\r\n                if (s" +
                    " == null || s.Length != 1) throw new ArgumentException(\"A single-character was e" +
                    "xpected\", \"value\");\r\n                return s[0];\r\n            }\r\n\r\n            " +
                    "/// <summary>\r\n            /// Internal use only\r\n            /// </summary>\r\n  " +
                    "          [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]\r\n     " +
                    "       [Obsolete(\"This method is for internal usage only\", false)]\r\n            " +
                    "public static char? ReadNullableChar(object value)\r\n            {\r\n             " +
                    "   if (value == null || value is DBNull) return null;\r\n                string s " +
                    "= value as string;\r\n                if (s == null || s.Length != 1) throw new Ar" +
                    "gumentException(\"A single-character was expected\", \"value\");\r\n                re" +
                    "turn s[0];\r\n            }\r\n\r\n\r\n            /// <summary>\r\n            /// Intern" +
                    "al use only\r\n            /// </summary>\r\n            [Browsable(false), EditorBr" +
                    "owsable(EditorBrowsableState.Never)]\r\n            [Obsolete(\"This method is for " +
                    "internal usage only\", true)]\r\n            public static IDbDataParameter FindOrA" +
                    "ddParameter(IDataParameterCollection parameters, IDbCommand command, string name" +
                    ")\r\n            {\r\n                IDbDataParameter result;\r\n                if (" +
                    "parameters.Contains(name))\r\n                {\r\n                    result = (IDb" +
                    "DataParameter)parameters[name];\r\n                }\r\n                else\r\n      " +
                    "          {\r\n                    result = command.CreateParameter();\r\n          " +
                    "          result.ParameterName = name;\r\n                    parameters.Add(resul" +
                    "t);\r\n                }\r\n                return result;\r\n            }\r\n\r\n       " +
                    "     /// <summary>\r\n            /// Internal use only\r\n            /// </summary" +
                    ">\r\n            [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]\r\n" +
                    "            [Obsolete(\"This method is for internal usage only\", false)]\r\n       " +
                    "     public static void PackListParameters(IDbCommand command, string namePrefix" +
                    ", object value)\r\n            {\r\n                // initially we tried TVP, howev" +
                    "er it performs quite poorly.\r\n                // keep in mind SQL support up to " +
                    "2000 params easily in sp_executesql, needing more is rare\r\n\r\n                var" +
                    " list = value as IEnumerable;\r\n                var count = 0;\r\n\r\n               " +
                    " if (list != null)\r\n                {\r\n                    if (FeatureSupport.Ge" +
                    "t(command.Connection).Arrays)\r\n                    {\r\n                        va" +
                    "r arrayParm = command.CreateParameter();\r\n                        arrayParm.Valu" +
                    "e = list;\r\n                        arrayParm.ParameterName = namePrefix;\r\n      " +
                    "                  command.Parameters.Add(arrayParm);\r\n                    }\r\n   " +
                    "                 else\r\n                    {\r\n                        bool isStr" +
                    "ing = value is IEnumerable<string>;\r\n                        bool isDbString = v" +
                    "alue is IEnumerable<DbString>;\r\n                        foreach (var item in lis" +
                    "t)\r\n                        {\r\n                            count++;\r\n           " +
                    "                 var listParam = command.CreateParameter();\r\n                   " +
                    "         listParam.ParameterName = namePrefix + count;\r\n                        " +
                    "    listParam.Value = item ?? DBNull.Value;\r\n                            if (isS" +
                    "tring)\r\n                            {\r\n                                listParam" +
                    ".Size = 4000;\r\n                                if (item != null && ((string)item" +
                    ").Length > 4000)\r\n                                {\r\n                           " +
                    "         listParam.Size = -1;\r\n                                }\r\n              " +
                    "              }\r\n                            if (isDbString && item as DbString " +
                    "!= null)\r\n                            {\r\n                                var str" +
                    " = item as DbString;\r\n                                str.AddParameter(command, " +
                    "listParam.ParameterName);\r\n                            }\r\n                      " +
                    "      else\r\n                            {\r\n                                comma" +
                    "nd.Parameters.Add(listParam);\r\n                            }\r\n                  " +
                    "      }\r\n\r\n                        if (count == 0)\r\n                        {\r\n " +
                    "                           command.CommandText = Regex.Replace(command.CommandTe" +
                    "xt, @\"[?@:]\" + Regex.Escape(namePrefix), \"(SELECT NULL WHERE 1 = 0)\");\r\n        " +
                    "                }\r\n                        else\r\n                        {\r\n    " +
                    "                        command.CommandText = Regex.Replace(command.CommandText," +
                    " @\"[?@:]\" + Regex.Escape(namePrefix), match =>\r\n                            {\r\n " +
                    "                               var grp = match.Value;\r\n                         " +
                    "       var sb = new StringBuilder(\"(\").Append(grp).Append(1);\r\n                 " +
                    "               for (int i = 2; i <= count; i++)\r\n                               " +
                    " {\r\n                                    sb.Append(\',\').Append(grp).Append(i);\r\n " +
                    "                               }\r\n                                return sb.Appe" +
                    "nd(\')\').ToString();\r\n                            });\r\n                        }\r" +
                    "\n                    }\r\n                }\r\n\r\n            }\r\n\r\n            privat" +
                    "e static IEnumerable<PropertyInfo> FilterParameters(IEnumerable<PropertyInfo> pa" +
                    "rameters, string sql)\r\n            {\r\n                return parameters.Where(p " +
                    "=> Regex.IsMatch(sql, \"[@:]\" + p.Name + \"([^a-zA-Z0-9_]+|$)\", RegexOptions.Ignor" +
                    "eCase | RegexOptions.Multiline));\r\n            }\r\n\r\n            /// <summary>\r\n " +
                    "           /// Internal use only\r\n            /// </summary>\r\n            public" +
                    " static Action<IDbCommand, object> CreateParamInfoGenerator(Identity identity, b" +
                    "ool checkForDuplicates)\r\n            {\r\n                Type type = identity.par" +
                    "ametersType;\r\n                bool filterParams = identity.commandType.GetValueO" +
                    "rDefault(CommandType.Text) == CommandType.Text;\r\n                var dm = new Dy" +
                    "namicMethod(string.Format(\"ParamInfo{0}\", Guid.NewGuid()), null, new[] { typeof(" +
                    "IDbCommand), typeof(object) }, type, true);\r\n\r\n                var il = dm.GetIL" +
                    "Generator();\r\n\r\n                il.DeclareLocal(type); // 0\r\n                boo" +
                    "l haveInt32Arg1 = false;\r\n                il.Emit(OpCodes.Ldarg_1); // stack is " +
                    "now [untyped-param]\r\n                il.Emit(OpCodes.Unbox_Any, type); // stack " +
                    "is now [typed-param]\r\n                il.Emit(OpCodes.Stloc_0);// stack is now e" +
                    "mpty\r\n\r\n                il.Emit(OpCodes.Ldarg_0); // stack is now [command]\r\n   " +
                    "             il.EmitCall(OpCodes.Callvirt, typeof(IDbCommand).GetProperty(\"Param" +
                    "eters\").GetGetMethod(), null); // stack is now [parameters]\r\n\r\n                I" +
                    "Enumerable<PropertyInfo> props = type.GetProperties().Where(p => p.GetIndexParam" +
                    "eters().Length == 0).OrderBy(p => p.Name);\r\n                if (filterParams)\r\n " +
                    "               {\r\n                    props = FilterParameters(props, identity.s" +
                    "ql);\r\n                }\r\n                foreach (var prop in props)\r\n          " +
                    "      {\r\n                    if (filterParams)\r\n                    {\r\n         " +
                    "               if (identity.sql.IndexOf(\"@\" + prop.Name, StringComparison.Invari" +
                    "antCultureIgnoreCase) < 0\r\n                            && identity.sql.IndexOf(\"" +
                    ":\" + prop.Name, StringComparison.InvariantCultureIgnoreCase) < 0)\r\n             " +
                    "           { // can\'t see the parameter in the text (even in a comment, etc) - b" +
                    "urn it with fire\r\n                            continue;\r\n                       " +
                    " }\r\n                    }\r\n                    if (prop.PropertyType == typeof(D" +
                    "bString))\r\n                    {\r\n                        il.Emit(OpCodes.Ldloc_" +
                    "0); // stack is now [parameters] [typed-param]\r\n                        il.Emit(" +
                    "OpCodes.Callvirt, prop.GetGetMethod()); // stack is [parameters] [dbstring]\r\n   " +
                    "                     il.Emit(OpCodes.Ldarg_0); // stack is now [parameters] [dbs" +
                    "tring] [command]\r\n                        il.Emit(OpCodes.Ldstr, prop.Name); // " +
                    "stack is now [parameters] [dbstring] [command] [name]\r\n                        i" +
                    "l.EmitCall(OpCodes.Callvirt, typeof(DbString).GetMethod(\"AddParameter\"), null); " +
                    "// stack is now [parameters]\r\n                        continue;\r\n               " +
                    "     }\r\n                    DbType dbType = LookupDbType(prop.PropertyType, prop" +
                    ".Name);\r\n                    if (dbType == DynamicParameters.EnumerableMultiPara" +
                    "meter)\r\n                    {\r\n                        // this actually represen" +
                    "ts special handling for list types;\r\n                        il.Emit(OpCodes.Lda" +
                    "rg_0); // stack is now [parameters] [command]\r\n                        il.Emit(O" +
                    "pCodes.Ldstr, prop.Name); // stack is now [parameters] [command] [name]\r\n       " +
                    "                 il.Emit(OpCodes.Ldloc_0); // stack is now [parameters] [command" +
                    "] [name] [typed-param]\r\n                        il.Emit(OpCodes.Callvirt, prop.G" +
                    "etGetMethod()); // stack is [parameters] [command] [name] [typed-value]\r\n       " +
                    "                 if (prop.PropertyType.IsValueType)\r\n                        {\r\n" +
                    "                            il.Emit(OpCodes.Box, prop.PropertyType); // stack is" +
                    " [parameters] [command] [name] [boxed-value]\r\n                        }\r\n       " +
                    "                 il.EmitCall(OpCodes.Call, typeof(SqlMapper).GetMethod(\"PackList" +
                    "Parameters\"), null); // stack is [parameters]\r\n                        continue;" +
                    "\r\n                    }\r\n                    il.Emit(OpCodes.Dup); // stack is n" +
                    "ow [parameters] [parameters]\r\n\r\n                    il.Emit(OpCodes.Ldarg_0); //" +
                    " stack is now [parameters] [parameters] [command]\r\n\r\n                    if (che" +
                    "ckForDuplicates)\r\n                    {\r\n                        // need to be a" +
                    " little careful about adding; use a utility method\r\n                        il.E" +
                    "mit(OpCodes.Ldstr, prop.Name); // stack is now [parameters] [parameters] [comman" +
                    "d] [name]\r\n                        il.EmitCall(OpCodes.Call, typeof(SqlMapper).G" +
                    "etMethod(\"FindOrAddParameter\"), null); // stack is [parameters] [parameter]\r\n   " +
                    "                 }\r\n                    else\r\n                    {\r\n           " +
                    "             // no risk of duplicates; just blindly add\r\n                       " +
                    " il.EmitCall(OpCodes.Callvirt, typeof(IDbCommand).GetMethod(\"CreateParameter\"), " +
                    "null);// stack is now [parameters] [parameters] [parameter]\r\n\r\n                 " +
                    "       il.Emit(OpCodes.Dup);// stack is now [parameters] [parameters] [parameter" +
                    "] [parameter]\r\n                        il.Emit(OpCodes.Ldstr, prop.Name); // sta" +
                    "ck is now [parameters] [parameters] [parameter] [parameter] [name]\r\n            " +
                    "            il.EmitCall(OpCodes.Callvirt, typeof(IDataParameter).GetProperty(\"Pa" +
                    "rameterName\").GetSetMethod(), null);// stack is now [parameters] [parameters] [p" +
                    "arameter]\r\n                    }\r\n                    if (dbType != DbType.Time)" +
                    " // https://connect.microsoft.com/VisualStudio/feedback/details/381934/sqlparame" +
                    "ter-dbtype-dbtype-time-sets-the-parameter-to-sqldbtype-datetime-instead-of-sqldb" +
                    "type-time\r\n                    {\r\n                        il.Emit(OpCodes.Dup);/" +
                    "/ stack is now [parameters] [[parameters]] [parameter] [parameter]\r\n            " +
                    "            EmitInt32(il, (int)dbType);// stack is now [parameters] [[parameters" +
                    "]] [parameter] [parameter] [db-type]\r\n\r\n                        il.EmitCall(OpCo" +
                    "des.Callvirt, typeof(IDataParameter).GetProperty(\"DbType\").GetSetMethod(), null)" +
                    ";// stack is now [parameters] [[parameters]] [parameter]\r\n                    }\r" +
                    "\n\r\n                    il.Emit(OpCodes.Dup);// stack is now [parameters] [[param" +
                    "eters]] [parameter] [parameter]\r\n                    EmitInt32(il, (int)Paramete" +
                    "rDirection.Input);// stack is now [parameters] [[parameters]] [parameter] [param" +
                    "eter] [dir]\r\n                    il.EmitCall(OpCodes.Callvirt, typeof(IDataParam" +
                    "eter).GetProperty(\"Direction\").GetSetMethod(), null);// stack is now [parameters" +
                    "] [[parameters]] [parameter]\r\n\r\n                    il.Emit(OpCodes.Dup);// stac" +
                    "k is now [parameters] [[parameters]] [parameter] [parameter]\r\n                  " +
                    "  il.Emit(OpCodes.Ldloc_0); // stack is now [parameters] [[parameters]] [paramet" +
                    "er] [parameter] [typed-param]\r\n                    il.Emit(OpCodes.Callvirt, pro" +
                    "p.GetGetMethod()); // stack is [parameters] [[parameters]] [parameter] [paramete" +
                    "r] [typed-value]\r\n                    bool checkForNull = true;\r\n               " +
                    "     if (prop.PropertyType.IsValueType)\r\n                    {\r\n                " +
                    "        il.Emit(OpCodes.Box, prop.PropertyType); // stack is [parameters] [[para" +
                    "meters]] [parameter] [parameter] [boxed-value]\r\n                        if (Null" +
                    "able.GetUnderlyingType(prop.PropertyType) == null)\r\n                        {   " +
                    "// struct but not Nullable<T>; boxed value cannot be null\r\n                     " +
                    "       checkForNull = false;\r\n                        }\r\n                    }\r\n" +
                    "                    if (checkForNull)\r\n                    {\r\n                  " +
                    "      if (dbType == DbType.String && !haveInt32Arg1)\r\n                        {\r" +
                    "\n                            il.DeclareLocal(typeof(int));\r\n                    " +
                    "        haveInt32Arg1 = true;\r\n                        }\r\n                      " +
                    "  // relative stack: [boxed value]\r\n                        il.Emit(OpCodes.Dup)" +
                    ";// relative stack: [boxed value] [boxed value]\r\n                        Label n" +
                    "otNull = il.DefineLabel();\r\n                        Label? allDone = dbType == D" +
                    "bType.String ? il.DefineLabel() : (Label?)null;\r\n                        il.Emit" +
                    "(OpCodes.Brtrue_S, notNull);\r\n                        // relative stack [boxed v" +
                    "alue = null]\r\n                        il.Emit(OpCodes.Pop); // relative stack em" +
                    "pty\r\n                        il.Emit(OpCodes.Ldsfld, typeof(DBNull).GetField(\"Va" +
                    "lue\")); // relative stack [DBNull]\r\n                        if (dbType == DbType" +
                    ".String)\r\n                        {\r\n                            EmitInt32(il, 0" +
                    ");\r\n                            il.Emit(OpCodes.Stloc_1);\r\n                     " +
                    "   }\r\n                        if (allDone != null) il.Emit(OpCodes.Br_S, allDone" +
                    ".Value);\r\n                        il.MarkLabel(notNull);\r\n                      " +
                    "  if (prop.PropertyType == typeof(string))\r\n                        {\r\n         " +
                    "                   il.Emit(OpCodes.Dup); // [string] [string]\r\n                 " +
                    "           il.EmitCall(OpCodes.Callvirt, typeof(string).GetProperty(\"Length\").Ge" +
                    "tGetMethod(), null); // [string] [length]\r\n                            EmitInt32" +
                    "(il, 4000); // [string] [length] [4000]\r\n                            il.Emit(OpC" +
                    "odes.Cgt); // [string] [0 or 1]\r\n                            Label isLong = il.D" +
                    "efineLabel(), lenDone = il.DefineLabel();\r\n                            il.Emit(O" +
                    "pCodes.Brtrue_S, isLong);\r\n                            EmitInt32(il, 4000); // [" +
                    "string] [4000]\r\n                            il.Emit(OpCodes.Br_S, lenDone);\r\n   " +
                    "                         il.MarkLabel(isLong);\r\n                            Emit" +
                    "Int32(il, -1); // [string] [-1]\r\n                            il.MarkLabel(lenDon" +
                    "e);\r\n                            il.Emit(OpCodes.Stloc_1); // [string] \r\n       " +
                    "                 }\r\n                        if (prop.PropertyType.FullName == Li" +
                    "nqBinary)\r\n                        {\r\n                            il.EmitCall(Op" +
                    "Codes.Callvirt, prop.PropertyType.GetMethod(\"ToArray\", BindingFlags.Public | Bin" +
                    "dingFlags.Instance), null);\r\n                        }\r\n                        " +
                    "if (allDone != null) il.MarkLabel(allDone.Value);\r\n                        // re" +
                    "lative stack [boxed value or DBNull]\r\n                    }\r\n                   " +
                    " il.EmitCall(OpCodes.Callvirt, typeof(IDataParameter).GetProperty(\"Value\").GetSe" +
                    "tMethod(), null);// stack is now [parameters] [[parameters]] [parameter]\r\n\r\n    " +
                    "                if (prop.PropertyType == typeof(string))\r\n                    {\r" +
                    "\n                        var endOfSize = il.DefineLabel();\r\n                    " +
                    "    // don\'t set if 0\r\n                        il.Emit(OpCodes.Ldloc_1); // [par" +
                    "ameters] [[parameters]] [parameter] [size]\r\n                        il.Emit(OpCo" +
                    "des.Brfalse_S, endOfSize); // [parameters] [[parameters]] [parameter]\r\n\r\n       " +
                    "                 il.Emit(OpCodes.Dup);// stack is now [parameters] [[parameters]" +
                    "] [parameter] [parameter]\r\n                        il.Emit(OpCodes.Ldloc_1); // " +
                    "stack is now [parameters] [[parameters]] [parameter] [parameter] [size]\r\n       " +
                    "                 il.EmitCall(OpCodes.Callvirt, typeof(IDbDataParameter).GetPrope" +
                    "rty(\"Size\").GetSetMethod(), null); // stack is now [parameters] [[parameters]] [" +
                    "parameter]\r\n\r\n                        il.MarkLabel(endOfSize);\r\n                " +
                    "    }\r\n                    if (checkForDuplicates)\r\n                    {\r\n     " +
                    "                   // stack is now [parameters] [parameter]\r\n                   " +
                    "     il.Emit(OpCodes.Pop); // don\'t need parameter any more\r\n                   " +
                    " }\r\n                    else\r\n                    {\r\n                        // " +
                    "stack is now [parameters] [parameters] [parameter]\r\n                        // b" +
                    "lindly add\r\n                        il.EmitCall(OpCodes.Callvirt, typeof(IList)." +
                    "GetMethod(\"Add\"), null); // stack is now [parameters]\r\n                        i" +
                    "l.Emit(OpCodes.Pop); // IList.Add returns the new index (int); we don\'t care\r\n  " +
                    "                  }\r\n                }\r\n                // stack is currently [p" +
                    "arameters]\r\n                il.Emit(OpCodes.Pop); // stack is now empty\r\n       " +
                    "         il.Emit(OpCodes.Ret);\r\n                return (Action<IDbCommand, objec" +
                    "t>)dm.CreateDelegate(typeof(Action<IDbCommand, object>));\r\n            }\r\n\r\n    " +
                    "        private static IDbCommand SetupCommand(IDbConnection cnn, IDbTransaction" +
                    " transaction, string sql, Action<IDbCommand, object> paramReader, object obj, in" +
                    "t? commandTimeout, CommandType? commandType)\r\n            {\r\n                var" +
                    " cmd = cnn.CreateCommand();\r\n                var bindByName = GetBindByName(cmd." +
                    "GetType());\r\n                if (bindByName != null) bindByName(cmd, true);\r\n   " +
                    "             if (transaction != null)\r\n                    cmd.Transaction = tra" +
                    "nsaction;\r\n                cmd.CommandText = sql;\r\n                if (commandTi" +
                    "meout.HasValue)\r\n                    cmd.CommandTimeout = commandTimeout.Value;\r" +
                    "\n                if (commandType.HasValue)\r\n                    cmd.CommandType " +
                    "= commandType.Value;\r\n                if (paramReader != null)\r\n                " +
                    "{\r\n                    paramReader(cmd, obj);\r\n                }\r\n              " +
                    "  return cmd;\r\n            }\r\n\r\n\r\n            private static int ExecuteCommand(" +
                    "IDbConnection cnn, IDbTransaction transaction, string sql, Action<IDbCommand, ob" +
                    "ject> paramReader, object obj, int? commandTimeout, CommandType? commandType)\r\n " +
                    "           {\r\n                IDbCommand cmd = null;\r\n                bool wasCl" +
                    "osed = cnn.State == ConnectionState.Closed;\r\n                try\r\n              " +
                    "  {\r\n                    cmd = SetupCommand(cnn, transaction, sql, paramReader, " +
                    "obj, commandTimeout, commandType);\r\n                    if (wasClosed) cnn.Open(" +
                    ");\r\n                    return cmd.ExecuteNonQuery();\r\n                }\r\n      " +
                    "          finally\r\n                {\r\n                    if (wasClosed) cnn.Clo" +
                    "se();\r\n                    if (cmd != null) cmd.Dispose();\r\n                }\r\n " +
                    "           }\r\n\r\n            private static Func<IDataReader, object> GetStructDe" +
                    "serializer(Type type, Type effectiveType, int index)\r\n            {\r\n           " +
                    "     // no point using special per-type handling here; it boils down to the same" +
                    ", plus not all are supported anyway (see: SqlDataReader.GetChar - not supported!" +
                    ")\r\n#pragma warning disable 618\r\n                if (type == typeof(char))\r\n     " +
                    "           { // this *does* need special handling, though\r\n                    r" +
                    "eturn r => SqlMapper.ReadChar(r.GetValue(index));\r\n                }\r\n          " +
                    "      if (type == typeof(char?))\r\n                {\r\n                    return " +
                    "r => SqlMapper.ReadNullableChar(r.GetValue(index));\r\n                }\r\n        " +
                    "        if (type.FullName == LinqBinary)\r\n                {\r\n                   " +
                    " return r => Activator.CreateInstance(type, r.GetValue(index));\r\n               " +
                    " }\r\n#pragma warning restore 618\r\n\r\n                if (effectiveType.IsEnum)\r\n  " +
                    "              {   // assume the value is returned as the correct type (int/byte/" +
                    "etc), but box back to the typed enum\r\n                    return r =>\r\n         " +
                    "           {\r\n                        var val = r.GetValue(index);\r\n            " +
                    "            return val is DBNull ? null : Enum.ToObject(effectiveType, val);\r\n  " +
                    "                  };\r\n                }\r\n                return r =>\r\n          " +
                    "      {\r\n                    var val = r.GetValue(index);\r\n                    r" +
                    "eturn val is DBNull ? null : val;\r\n                };\r\n            }\r\n\r\n        " +
                    "    static readonly MethodInfo\r\n                        enumParse = typeof(Enum)" +
                    ".GetMethod(\"Parse\", new Type[] { typeof(Type), typeof(string), typeof(bool) }),\r" +
                    "\n                        getItem = typeof(IDataRecord).GetProperties(BindingFlag" +
                    "s.Instance | BindingFlags.Public)\r\n                            .Where(p => p.Get" +
                    "IndexParameters().Any() && p.GetIndexParameters()[0].ParameterType == typeof(int" +
                    "))\r\n                            .Select(p => p.GetGetMethod()).First();\r\n\r\n     " +
                    "       /// <summary>\r\n            /// Gets type-map for the given type\r\n        " +
                    "    /// </summary>\r\n            /// <returns>Type map implementation, DefaultTyp" +
                    "eMap instance if no override present</returns>\r\n            public static ITypeM" +
                    "ap GetTypeMap(Type type)\r\n            {\r\n                if (type == null) throw" +
                    " new ArgumentNullException(\"type\");\r\n                var map = (ITypeMap)_typeMa" +
                    "ps[type];\r\n                if (map == null)\r\n                {\r\n                " +
                    "    lock (_typeMaps)\r\n                    {   // double-checked; store this to a" +
                    "void reflection next time we see this type\r\n                        // since mul" +
                    "tiple queries commonly use the same domain-entity/DTO/view-model type\r\n         " +
                    "               map = (ITypeMap)_typeMaps[type];\r\n                        if (map" +
                    " == null)\r\n                        {\r\n                            map = new Defa" +
                    "ultTypeMap(type);\r\n                            _typeMaps[type] = map;\r\n         " +
                    "               }\r\n                    }\r\n                }\r\n                retu" +
                    "rn map;\r\n            }\r\n\r\n            // use Hashtable to get free lockless read" +
                    "ing\r\n            private static readonly Hashtable _typeMaps = new Hashtable();\r" +
                    "\n\r\n            /// <summary>\r\n            /// Set custom mapping for type deseri" +
                    "alizers\r\n            /// </summary>\r\n            /// <param name=\"type\">Entity t" +
                    "ype to override</param>\r\n            /// <param name=\"map\">Mapping rules impemen" +
                    "tation, null to remove custom map</param>\r\n            public static void SetTyp" +
                    "eMap(Type type, ITypeMap map)\r\n            {\r\n                if (type == null)\r" +
                    "\n                    throw new ArgumentNullException(\"type\");\r\n\r\n               " +
                    " if (map == null || map is DefaultTypeMap)\r\n                {\r\n                 " +
                    "   lock (_typeMaps)\r\n                    {\r\n                        _typeMaps.Re" +
                    "move(type);\r\n                    }\r\n                }\r\n                else\r\n   " +
                    "             {\r\n                    lock (_typeMaps)\r\n                    {\r\n   " +
                    "                     _typeMaps[type] = map;\r\n                    }\r\n            " +
                    "    }\r\n\r\n                PurgeQueryCacheByType(type);\r\n            }\r\n\r\n        " +
                    "    /// <summary>\r\n            /// Internal use only\r\n            /// </summary>" +
                    "\r\n            /// <param name=\"type\"></param>\r\n            /// <param name=\"read" +
                    "er\"></param>\r\n            /// <param name=\"startBound\"></param>\r\n            ///" +
                    " <param name=\"length\"></param>\r\n            /// <param name=\"returnNullIfFirstMi" +
                    "ssing\"></param>\r\n            /// <returns></returns>\r\n            public static " +
                    "Func<IDataReader, object> GetTypeDeserializer(\r\n#if CSHARP30\r\n            Type t" +
                    "ype, IDataReader reader, int startBound, int length, bool returnNullIfFirstMissi" +
                    "ng\r\n#else\r\nType type, IDataReader reader, int startBound = 0, int length = -1, b" +
                    "ool returnNullIfFirstMissing = false\r\n#endif\r\n)\r\n            {\r\n\r\n              " +
                    "  var dm = new DynamicMethod(string.Format(\"Deserialize{0}\", Guid.NewGuid()), ty" +
                    "peof(object), new[] { typeof(IDataReader) }, true);\r\n                var il = dm" +
                    ".GetILGenerator();\r\n                il.DeclareLocal(typeof(int));\r\n             " +
                    "   il.DeclareLocal(type);\r\n                il.Emit(OpCodes.Ldc_I4_0);\r\n         " +
                    "       il.Emit(OpCodes.Stloc_0);\r\n\r\n                if (length == -1)\r\n         " +
                    "       {\r\n                    length = reader.FieldCount - startBound;\r\n        " +
                    "        }\r\n\r\n                if (reader.FieldCount <= startBound)\r\n             " +
                    "   {\r\n                    throw new ArgumentException(\"When using the multi-mapp" +
                    "ing APIs ensure you set the splitOn param if you have keys other than Id\", \"spli" +
                    "tOn\");\r\n                }\r\n\r\n                var names = Enumerable.Range(startB" +
                    "ound, length).Select(i => reader.GetName(i)).ToArray();\r\n\r\n                IType" +
                    "Map typeMap = GetTypeMap(type);\r\n\r\n                int index = startBound;\r\n\r\n  " +
                    "              ConstructorInfo specializedConstructor = null;\r\n\r\n                " +
                    "if (type.IsValueType)\r\n                {\r\n                    il.Emit(OpCodes.Ld" +
                    "loca_S, (byte)1);\r\n                    il.Emit(OpCodes.Initobj, type);\r\n        " +
                    "        }\r\n                else\r\n                {\r\n                    var type" +
                    "s = new Type[length];\r\n                    for (int i = startBound; i < startBou" +
                    "nd + length; i++)\r\n                    {\r\n                        types[i - star" +
                    "tBound] = reader.GetFieldType(i);\r\n                    }\r\n\r\n                    " +
                    "if (type.IsValueType)\r\n                    {\r\n                        il.Emit(Op" +
                    "Codes.Ldloca_S, (byte)1);\r\n                        il.Emit(OpCodes.Initobj, type" +
                    ");\r\n                    }\r\n                    else\r\n                    {\r\n    " +
                    "                    var ctor = typeMap.FindConstructor(names, types);\r\n         " +
                    "               if (ctor == null)\r\n                        {\r\n                   " +
                    "         string proposedTypes = \"(\" + String.Join(\", \", types.Select((t, i) => t" +
                    ".FullName + \" \" + names[i]).ToArray()) + \")\";\r\n                            throw" +
                    " new InvalidOperationException(String.Format(\"A parameterless default constructo" +
                    "r or one matching signature {0} is required for {1} materialization\", proposedTy" +
                    "pes, type.FullName));\r\n                        }\r\n\r\n                        if (" +
                    "ctor.GetParameters().Length == 0)\r\n                        {\r\n                  " +
                    "          il.Emit(OpCodes.Newobj, ctor);\r\n                            il.Emit(Op" +
                    "Codes.Stloc_1);\r\n                        }\r\n                        else\r\n      " +
                    "                      specializedConstructor = ctor;\r\n                    }\r\n   " +
                    "             }\r\n\r\n                il.BeginExceptionBlock();\r\n                if " +
                    "(type.IsValueType)\r\n                {\r\n                    il.Emit(OpCodes.Ldloc" +
                    "a_S, (byte)1);// [target]\r\n                }\r\n                else if (specializ" +
                    "edConstructor == null)\r\n                {\r\n                    il.Emit(OpCodes.L" +
                    "dloc_1);// [target]\r\n                }\r\n\r\n                var members = (special" +
                    "izedConstructor != null\r\n                    ? names.Select(n => typeMap.GetCons" +
                    "tructorParameter(specializedConstructor, n))\r\n                    : names.Select" +
                    "(n => typeMap.GetMember(n))).ToList();\r\n\r\n                // stack is now [targe" +
                    "t]\r\n\r\n                bool first = true;\r\n                var allDone = il.Defin" +
                    "eLabel();\r\n                int enumDeclareLocal = -1;\r\n                foreach (" +
                    "var item in members)\r\n                {\r\n                    if (item != null)\r\n" +
                    "                    {\r\n                        if (specializedConstructor == nul" +
                    "l)\r\n                            il.Emit(OpCodes.Dup); // stack is now [target][t" +
                    "arget]\r\n                        Label isDbNullLabel = il.DefineLabel();\r\n       " +
                    "                 Label finishLabel = il.DefineLabel();\r\n\r\n                      " +
                    "  il.Emit(OpCodes.Ldarg_0); // stack is now [target][target][reader]\r\n          " +
                    "              EmitInt32(il, index); // stack is now [target][target][reader][ind" +
                    "ex]\r\n                        il.Emit(OpCodes.Dup);// stack is now [target][targe" +
                    "t][reader][index][index]\r\n                        il.Emit(OpCodes.Stloc_0);// st" +
                    "ack is now [target][target][reader][index]\r\n                        il.Emit(OpCo" +
                    "des.Callvirt, getItem); // stack is now [target][target][value-as-object]\r\n\r\n   " +
                    "                     Type memberType = item.MemberType;\r\n\r\n                     " +
                    "   if (memberType == typeof(char) || memberType == typeof(char?))\r\n             " +
                    "           {\r\n                            il.EmitCall(OpCodes.Call, typeof(SqlMa" +
                    "pper).GetMethod(\r\n                                memberType == typeof(char) ? \"" +
                    "ReadChar\" : \"ReadNullableChar\", BindingFlags.Static | BindingFlags.Public), null" +
                    "); // stack is now [target][target][typed-value]\r\n                        }\r\n   " +
                    "                     else\r\n                        {\r\n                          " +
                    "  il.Emit(OpCodes.Dup); // stack is now [target][target][value][value]\r\n        " +
                    "                    il.Emit(OpCodes.Isinst, typeof(DBNull)); // stack is now [ta" +
                    "rget][target][value-as-object][DBNull or null]\r\n                            il.E" +
                    "mit(OpCodes.Brtrue_S, isDbNullLabel); // stack is now [target][target][value-as-" +
                    "object]\r\n\r\n                            // unbox nullable enums as the primitive," +
                    " i.e. byte etc\r\n\r\n                            var nullUnderlyingType = Nullable." +
                    "GetUnderlyingType(memberType);\r\n                            var unboxType = null" +
                    "UnderlyingType != null && nullUnderlyingType.IsEnum ? nullUnderlyingType : membe" +
                    "rType;\r\n\r\n                            if (unboxType.IsEnum)\r\n                   " +
                    "         {\r\n                                if (enumDeclareLocal == -1)\r\n       " +
                    "                         {\r\n                                    enumDeclareLocal" +
                    " = il.DeclareLocal(typeof(string)).LocalIndex;\r\n                                " +
                    "}\r\n\r\n                                Label isNotString = il.DefineLabel();\r\n    " +
                    "                            il.Emit(OpCodes.Dup); // stack is now [target][targe" +
                    "t][value][value]\r\n                                il.Emit(OpCodes.Isinst, typeof" +
                    "(string)); // stack is now [target][target][value-as-object][string or null]\r\n  " +
                    "                              il.Emit(OpCodes.Dup);// stack is now [target][targ" +
                    "et][value-as-object][string or null][string or null]\r\n                          " +
                    "      StoreLocal(il, enumDeclareLocal); // stack is now [target][target][value-a" +
                    "s-object][string or null]\r\n                                il.Emit(OpCodes.Brfal" +
                    "se_S, isNotString); // stack is now [target][target][value-as-object]\r\n\r\n       " +
                    "                         il.Emit(OpCodes.Pop); // stack is now [target][target]\r" +
                    "\n\r\n                                il.Emit(OpCodes.Ldtoken, unboxType); // stack" +
                    " is now [target][target][enum-type-token]\r\n                                il.Em" +
                    "itCall(OpCodes.Call, typeof(Type).GetMethod(\"GetTypeFromHandle\"), null);// stack" +
                    " is now [target][target][enum-type]\r\n                                il.Emit(OpC" +
                    "odes.Ldloc_2); // stack is now [target][target][enum-type][string]\r\n            " +
                    "                    il.Emit(OpCodes.Ldc_I4_1); // stack is now [target][target][" +
                    "enum-type][string][true]\r\n                                il.EmitCall(OpCodes.Ca" +
                    "ll, enumParse, null); // stack is now [target][target][enum-as-object]\r\n\r\n      " +
                    "                          il.MarkLabel(isNotString);\r\n\r\n                        " +
                    "        il.Emit(OpCodes.Unbox_Any, unboxType); // stack is now [target][target][" +
                    "typed-value]\r\n\r\n                                if (nullUnderlyingType != null)\r" +
                    "\n                                {\r\n                                    il.Emit(" +
                    "OpCodes.Newobj, memberType.GetConstructor(new[] { nullUnderlyingType })); // sta" +
                    "ck is now [target][target][enum-value]\r\n                                }\r\n     " +
                    "                       }\r\n                            else if (memberType.FullNa" +
                    "me == LinqBinary)\r\n                            {\r\n                              " +
                    "  il.Emit(OpCodes.Unbox_Any, typeof(byte[])); // stack is now [target][target][b" +
                    "yte-array]\r\n                                il.Emit(OpCodes.Newobj, memberType.G" +
                    "etConstructor(new Type[] { typeof(byte[]) }));// stack is now [target][target][b" +
                    "inary]\r\n                            }\r\n                            else\r\n       " +
                    "                     {\r\n                                Type dataType = reader.G" +
                    "etFieldType(index);\r\n                                TypeCode dataTypeCode = Typ" +
                    "e.GetTypeCode(dataType), unboxTypeCode = Type.GetTypeCode(unboxType);\r\n         " +
                    "                       if (dataType == unboxType || dataTypeCode == unboxTypeCod" +
                    "e || dataTypeCode == Type.GetTypeCode(nullUnderlyingType))\r\n                    " +
                    "            {\r\n                                    il.Emit(OpCodes.Unbox_Any, un" +
                    "boxType); // stack is now [target][target][typed-value]\r\n                       " +
                    "         }\r\n                                else\r\n                              " +
                    "  {\r\n                                    // not a direct match; need to tweak th" +
                    "e unbox\r\n                                    bool handled = true;\r\n             " +
                    "                       OpCode opCode = default(OpCode);\r\n                       " +
                    "             if (dataTypeCode == TypeCode.Decimal || unboxTypeCode == TypeCode.D" +
                    "ecimal)\r\n                                    {   // no IL level conversions to/f" +
                    "rom decimal; I guess we could use the static operators, but\r\n                   " +
                    "                     // this feels an edge-case\r\n                               " +
                    "         handled = false;\r\n                                    }\r\n              " +
                    "                      else\r\n                                    {\r\n             " +
                    "                           switch (unboxTypeCode)\r\n                             " +
                    "           {\r\n                                            case TypeCode.Byte:\r\n " +
                    "                                               opCode = OpCodes.Conv_Ovf_I1_Un; " +
                    "break;\r\n                                            case TypeCode.SByte:\r\n      " +
                    "                                          opCode = OpCodes.Conv_Ovf_I1; break;\r\n" +
                    "                                            case TypeCode.UInt16:\r\n             " +
                    "                                   opCode = OpCodes.Conv_Ovf_I2_Un; break;\r\n    " +
                    "                                        case TypeCode.Int16:\r\n                  " +
                    "                              opCode = OpCodes.Conv_Ovf_I2; break;\r\n            " +
                    "                                case TypeCode.UInt32:\r\n                         " +
                    "                       opCode = OpCodes.Conv_Ovf_I4_Un; break;\r\n                " +
                    "                            case TypeCode.Boolean: // boolean is basically an in" +
                    "t, at least at this level\r\n                                            case Type" +
                    "Code.Int32:\r\n                                                opCode = OpCodes.Co" +
                    "nv_Ovf_I4; break;\r\n                                            case TypeCode.UIn" +
                    "t64:\r\n                                                opCode = OpCodes.Conv_Ovf_" +
                    "I8_Un; break;\r\n                                            case TypeCode.Int64:\r" +
                    "\n                                                opCode = OpCodes.Conv_Ovf_I8; b" +
                    "reak;\r\n                                            case TypeCode.Single:\r\n      " +
                    "                                          opCode = OpCodes.Conv_R4; break;\r\n    " +
                    "                                        case TypeCode.Double:\r\n                 " +
                    "                               opCode = OpCodes.Conv_R8; break;\r\n               " +
                    "                             default:\r\n                                         " +
                    "       handled = false;\r\n                                                break;\r" +
                    "\n                                        }\r\n                                    " +
                    "}\r\n                                    if (handled)\r\n                           " +
                    "         { // unbox as the data-type, then use IL-level convert\r\n               " +
                    "                         il.Emit(OpCodes.Unbox_Any, dataType); // stack is now [" +
                    "target][target][data-typed-value]\r\n                                        il.Em" +
                    "it(opCode); // stack is now [target][target][typed-value]\r\n                     " +
                    "                   if (unboxTypeCode == TypeCode.Boolean)\r\n                     " +
                    "                   { // compare to zero; I checked \"csc\" - this is the trick it " +
                    "uses; nice\r\n                                            il.Emit(OpCodes.Ldc_I4_0" +
                    ");\r\n                                            il.Emit(OpCodes.Ceq);\r\n         " +
                    "                                   il.Emit(OpCodes.Ldc_I4_0);\r\n                 " +
                    "                           il.Emit(OpCodes.Ceq);\r\n                              " +
                    "          }\r\n                                    }\r\n                            " +
                    "        else\r\n                                    { // use flexible conversion\r\n" +
                    "                                        il.Emit(OpCodes.Ldtoken, unboxType); // " +
                    "stack is now [target][target][value][member-type-token]\r\n                       " +
                    "                 il.EmitCall(OpCodes.Call, typeof(Type).GetMethod(\"GetTypeFromHa" +
                    "ndle\"), null); // stack is now [target][target][value][member-type]\r\n           " +
                    "                             il.EmitCall(OpCodes.Call, typeof(Convert).GetMethod" +
                    "(\"ChangeType\", new Type[] { typeof(object), typeof(Type) }), null); // stack is " +
                    "now [target][target][boxed-member-type-value]\r\n                                 " +
                    "       il.Emit(OpCodes.Unbox_Any, unboxType); // stack is now [target][target][t" +
                    "yped-value]\r\n                                    }\r\n\r\n                          " +
                    "      }\r\n\r\n                            }\r\n                        }\r\n           " +
                    "             if (specializedConstructor == null)\r\n                        {\r\n   " +
                    "                         // Store the value in the property/field\r\n             " +
                    "               if (item.Property != null)\r\n                            {\r\n      " +
                    "                          if (type.IsValueType)\r\n                               " +
                    " {\r\n                                    il.Emit(OpCodes.Call, DefaultTypeMap.Get" +
                    "PropertySetter(item.Property, type)); // stack is now [target]\r\n                " +
                    "                }\r\n                                else\r\n                       " +
                    "         {\r\n                                    il.Emit(OpCodes.Callvirt, Defaul" +
                    "tTypeMap.GetPropertySetter(item.Property, type)); // stack is now [target]\r\n    " +
                    "                            }\r\n                            }\r\n                  " +
                    "          else\r\n                            {\r\n                                i" +
                    "l.Emit(OpCodes.Stfld, item.Field); // stack is now [target]\r\n                   " +
                    "         }\r\n                        }\r\n\r\n                        il.Emit(OpCodes" +
                    ".Br_S, finishLabel); // stack is now [target]\r\n\r\n                        il.Mark" +
                    "Label(isDbNullLabel); // incoming stack: [target][target][value]\r\n              " +
                    "          if (specializedConstructor != null)\r\n                        {\r\n      " +
                    "                      il.Emit(OpCodes.Pop);\r\n                            if (ite" +
                    "m.MemberType.IsValueType)\r\n                            {\r\n                      " +
                    "          int localIndex = il.DeclareLocal(item.MemberType).LocalIndex;\r\n       " +
                    "                         LoadLocalAddress(il, localIndex);\r\n                    " +
                    "            il.Emit(OpCodes.Initobj, item.MemberType);\r\n                        " +
                    "        LoadLocal(il, localIndex);\r\n                            }\r\n             " +
                    "               else\r\n                            {\r\n                            " +
                    "    il.Emit(OpCodes.Ldnull);\r\n                            }\r\n                   " +
                    "     }\r\n                        else\r\n                        {\r\n               " +
                    "             il.Emit(OpCodes.Pop); // stack is now [target][target]\r\n           " +
                    "                 il.Emit(OpCodes.Pop); // stack is now [target]\r\n               " +
                    "         }\r\n\r\n                        if (first && returnNullIfFirstMissing)\r\n  " +
                    "                      {\r\n                            il.Emit(OpCodes.Pop);\r\n    " +
                    "                        il.Emit(OpCodes.Ldnull); // stack is now [null]\r\n       " +
                    "                     il.Emit(OpCodes.Stloc_1);\r\n                            il.E" +
                    "mit(OpCodes.Br, allDone);\r\n                        }\r\n\r\n                        " +
                    "il.MarkLabel(finishLabel);\r\n                    }\r\n                    first = f" +
                    "alse;\r\n                    index += 1;\r\n                }\r\n                if (t" +
                    "ype.IsValueType)\r\n                {\r\n                    il.Emit(OpCodes.Pop);\r\n" +
                    "                }\r\n                else\r\n                {\r\n                    " +
                    "if (specializedConstructor != null)\r\n                    {\r\n                    " +
                    "    il.Emit(OpCodes.Newobj, specializedConstructor);\r\n                    }\r\n   " +
                    "                 il.Emit(OpCodes.Stloc_1); // stack is empty\r\n                }\r" +
                    "\n                il.MarkLabel(allDone);\r\n                il.BeginCatchBlock(type" +
                    "of(Exception)); // stack is Exception\r\n                il.Emit(OpCodes.Ldloc_0);" +
                    " // stack is Exception, index\r\n                il.Emit(OpCodes.Ldarg_0); // stac" +
                    "k is Exception, index, reader\r\n                il.EmitCall(OpCodes.Call, typeof(" +
                    "SqlMapper).GetMethod(\"ThrowDataException\"), null);\r\n                il.EndExcept" +
                    "ionBlock();\r\n\r\n                il.Emit(OpCodes.Ldloc_1); // stack is [rval]\r\n   " +
                    "             if (type.IsValueType)\r\n                {\r\n                    il.Em" +
                    "it(OpCodes.Box, type);\r\n                }\r\n                il.Emit(OpCodes.Ret);" +
                    "\r\n\r\n                return (Func<IDataReader, object>)dm.CreateDelegate(typeof(F" +
                    "unc<IDataReader, object>));\r\n            }\r\n\r\n            private static void Lo" +
                    "adLocal(ILGenerator il, int index)\r\n            {\r\n                if (index < 0" +
                    " || index >= short.MaxValue) throw new ArgumentNullException(\"index\");\r\n        " +
                    "        switch (index)\r\n                {\r\n                    case 0: il.Emit(O" +
                    "pCodes.Ldloc_0); break;\r\n                    case 1: il.Emit(OpCodes.Ldloc_1); b" +
                    "reak;\r\n                    case 2: il.Emit(OpCodes.Ldloc_2); break;\r\n           " +
                    "         case 3: il.Emit(OpCodes.Ldloc_3); break;\r\n                    default:\r" +
                    "\n                        if (index <= 255)\r\n                        {\r\n         " +
                    "                   il.Emit(OpCodes.Ldloc_S, (byte)index);\r\n                     " +
                    "   }\r\n                        else\r\n                        {\r\n                 " +
                    "           il.Emit(OpCodes.Ldloc, (short)index);\r\n                        }\r\n   " +
                    "                     break;\r\n                }\r\n            }\r\n            priva" +
                    "te static void StoreLocal(ILGenerator il, int index)\r\n            {\r\n           " +
                    "     if (index < 0 || index >= short.MaxValue) throw new ArgumentNullException(\"" +
                    "index\");\r\n                switch (index)\r\n                {\r\n                   " +
                    " case 0: il.Emit(OpCodes.Stloc_0); break;\r\n                    case 1: il.Emit(O" +
                    "pCodes.Stloc_1); break;\r\n                    case 2: il.Emit(OpCodes.Stloc_2); b" +
                    "reak;\r\n                    case 3: il.Emit(OpCodes.Stloc_3); break;\r\n           " +
                    "         default:\r\n                        if (index <= 255)\r\n                  " +
                    "      {\r\n                            il.Emit(OpCodes.Stloc_S, (byte)index);\r\n   " +
                    "                     }\r\n                        else\r\n                        {\r" +
                    "\n                            il.Emit(OpCodes.Stloc, (short)index);\r\n            " +
                    "            }\r\n                        break;\r\n                }\r\n            }\r" +
                    "\n            private static void LoadLocalAddress(ILGenerator il, int index)\r\n  " +
                    "          {\r\n                if (index < 0 || index >= short.MaxValue) throw new" +
                    " ArgumentNullException(\"index\");\r\n\r\n                if (index <= 255)\r\n         " +
                    "       {\r\n                    il.Emit(OpCodes.Ldloca_S, (byte)index);\r\n         " +
                    "       }\r\n                else\r\n                {\r\n                    il.Emit(O" +
                    "pCodes.Ldloca, (short)index);\r\n                }\r\n            }\r\n            ///" +
                    " <summary>\r\n            /// Throws a data exception, only used internally\r\n     " +
                    "       /// </summary>\r\n            /// <param name=\"ex\"></param>\r\n            //" +
                    "/ <param name=\"index\"></param>\r\n            /// <param name=\"reader\"></param>\r\n " +
                    "           public static void ThrowDataException(Exception ex, int index, IDataR" +
                    "eader reader)\r\n            {\r\n                Exception toThrow;\r\n              " +
                    "  try\r\n                {\r\n                    string name = \"(n/a)\", value = \"(n" +
                    "/a)\";\r\n                    if (reader != null && index >= 0 && index < reader.Fi" +
                    "eldCount)\r\n                    {\r\n                        name = reader.GetName(" +
                    "index);\r\n                        object val = reader.GetValue(index);\r\n         " +
                    "               if (val == null || val is DBNull)\r\n                        {\r\n   " +
                    "                         value = \"<null>\";\r\n                        }\r\n         " +
                    "               else\r\n                        {\r\n                            valu" +
                    "e = Convert.ToString(val) + \" - \" + Type.GetTypeCode(val.GetType());\r\n          " +
                    "              }\r\n                    }\r\n                    toThrow = new DataEx" +
                    "ception(string.Format(\"Error parsing column {0} ({1}={2})\", index, name, value)," +
                    " ex);\r\n                }\r\n                catch\r\n                { // throw the " +
                    "**original** exception, wrapped as DataException\r\n                    toThrow = " +
                    "new DataException(ex.Message, ex);\r\n                }\r\n                throw toT" +
                    "hrow;\r\n            }\r\n            private static void EmitInt32(ILGenerator il, " +
                    "int value)\r\n            {\r\n                switch (value)\r\n                {\r\n  " +
                    "                  case -1: il.Emit(OpCodes.Ldc_I4_M1); break;\r\n                 " +
                    "   case 0: il.Emit(OpCodes.Ldc_I4_0); break;\r\n                    case 1: il.Emi" +
                    "t(OpCodes.Ldc_I4_1); break;\r\n                    case 2: il.Emit(OpCodes.Ldc_I4_" +
                    "2); break;\r\n                    case 3: il.Emit(OpCodes.Ldc_I4_3); break;\r\n     " +
                    "               case 4: il.Emit(OpCodes.Ldc_I4_4); break;\r\n                    ca" +
                    "se 5: il.Emit(OpCodes.Ldc_I4_5); break;\r\n                    case 6: il.Emit(OpC" +
                    "odes.Ldc_I4_6); break;\r\n                    case 7: il.Emit(OpCodes.Ldc_I4_7); b" +
                    "reak;\r\n                    case 8: il.Emit(OpCodes.Ldc_I4_8); break;\r\n          " +
                    "          default:\r\n                        if (value >= -128 && value <= 127)\r\n" +
                    "                        {\r\n                            il.Emit(OpCodes.Ldc_I4_S," +
                    " (sbyte)value);\r\n                        }\r\n                        else\r\n      " +
                    "                  {\r\n                            il.Emit(OpCodes.Ldc_I4, value);" +
                    "\r\n                        }\r\n                        break;\r\n                }\r\n" +
                    "            }\r\n\r\n            /// <summary>\r\n            /// The grid reader prov" +
                    "ides interfaces for reading multiple result sets from a Dapper query \r\n         " +
                    "   /// </summary>\r\n            public partial class GridReader : IDisposable\r\n  " +
                    "          {\r\n                private IDataReader reader;\r\n                privat" +
                    "e IDbCommand command;\r\n                private Identity identity;\r\n\r\n           " +
                    "     internal GridReader(IDbCommand command, IDataReader reader, Identity identi" +
                    "ty)\r\n                {\r\n                    this.command = command;\r\n           " +
                    "         this.reader = reader;\r\n                    this.identity = identity;\r\n " +
                    "               }\r\n\r\n#if !CSHARP30\r\n\r\n                /// <summary>\r\n            " +
                    "    /// Read the next grid of results, returned as a dynamic object\r\n           " +
                    "     /// </summary>\r\n                public IEnumerable<dynamic> Read(bool buffe" +
                    "red = true)\r\n                {\r\n                    return Read<DapperRow>(buffe" +
                    "red);\r\n                }\r\n#endif\r\n\r\n#if CSHARP30\r\n            /// <summary>\r\n   " +
                    "         /// Read the next grid of results\r\n            /// </summary>\r\n        " +
                    "    public IEnumerable<T> Read<T>()\r\n            {\r\n                return Read<" +
                    "T>(true);\r\n            }\r\n#endif\r\n                /// <summary>\r\n               " +
                    " /// Read the next grid of results\r\n                /// </summary>\r\n#if CSHARP30" +
                    "\r\n            public IEnumerable<T> Read<T>(bool buffered)\r\n#else\r\n             " +
                    "   public IEnumerable<T> Read<T>(bool buffered = true)\r\n#endif\r\n                " +
                    "{\r\n                    if (reader == null) throw new ObjectDisposedException(Get" +
                    "Type().FullName, \"The reader has been disposed; this can happen after all data h" +
                    "as been consumed\");\r\n                    if (consumed) throw new InvalidOperatio" +
                    "nException(\"Query results must be consumed in the correct order, and each result" +
                    " can only be consumed once\");\r\n                    var typedIdentity = identity." +
                    "ForGrid(typeof(T), gridIndex);\r\n                    CacheInfo cache = GetCacheIn" +
                    "fo(typedIdentity);\r\n                    var deserializer = cache.Deserializer;\r\n" +
                    "\r\n                    int hash = GetColumnHash(reader);\r\n                    if " +
                    "(deserializer.Func == null || deserializer.Hash != hash)\r\n                    {\r" +
                    "\n                        deserializer = new DeserializerState(hash, GetDeseriali" +
                    "zer(typeof(T), reader, 0, -1, false));\r\n                        cache.Deserializ" +
                    "er = deserializer;\r\n                    }\r\n                    consumed = true;\r" +
                    "\n                    var result = ReadDeferred<T>(gridIndex, deserializer.Func, " +
                    "typedIdentity);\r\n                    return buffered ? result.ToList() : result;" +
                    "\r\n                }\r\n\r\n                private IEnumerable<TReturn> MultiReadInt" +
                    "ernal<TFirst, TSecond, TThird, TFourth, TFifth, TReturn>(object func, string spl" +
                    "itOn)\r\n                {\r\n                    var identity = this.identity.ForGr" +
                    "id(typeof(TReturn), new Type[] {\r\n                    typeof(TFirst),\r\n         " +
                    "           typeof(TSecond),\r\n                    typeof(TThird),\r\n              " +
                    "      typeof(TFourth),\r\n                    typeof(TFifth)\r\n                }, g" +
                    "ridIndex);\r\n                    try\r\n                    {\r\n                    " +
                    "    foreach (var r in SqlMapper.MultiMapImpl<TFirst, TSecond, TThird, TFourth, T" +
                    "Fifth, TReturn>(null, null, func, null, null, splitOn, null, null, reader, ident" +
                    "ity))\r\n                        {\r\n                            yield return r;\r\n " +
                    "                       }\r\n                    }\r\n                    finally\r\n  " +
                    "                  {\r\n                        NextResult();\r\n                    " +
                    "}\r\n                }\r\n\r\n#if CSHARP30\r\n            /// <summary>\r\n            ///" +
                    " Read multiple objects from a single recordset on the grid\r\n            /// </su" +
                    "mmary>\r\n            public IEnumerable<TReturn> Read<TFirst, TSecond, TReturn>(F" +
                    "unc<TFirst, TSecond, TReturn> func, string splitOn)\r\n            {\r\n            " +
                    "    return Read<TFirst, TSecond, TReturn>(func, splitOn, true);\r\n            }\r\n" +
                    "#endif\r\n                /// <summary>\r\n                /// Read multiple objects" +
                    " from a single recordset on the grid\r\n                /// </summary>\r\n#if CSHARP" +
                    "30\r\n            public IEnumerable<TReturn> Read<TFirst, TSecond, TReturn>(Func<" +
                    "TFirst, TSecond, TReturn> func, string splitOn, bool buffered)\r\n#else\r\n         " +
                    "       public IEnumerable<TReturn> Read<TFirst, TSecond, TReturn>(Func<TFirst, T" +
                    "Second, TReturn> func, string splitOn = \"id\", bool buffered = true)\r\n#endif\r\n   " +
                    "             {\r\n                    var result = MultiReadInternal<TFirst, TSeco" +
                    "nd, DontMap, DontMap, DontMap, TReturn>(func, splitOn);\r\n                    ret" +
                    "urn buffered ? result.ToList() : result;\r\n                }\r\n\r\n#if CSHARP30\r\n   " +
                    "         /// <summary>\r\n            /// Read multiple objects from a single reco" +
                    "rdset on the grid\r\n            /// </summary>\r\n            public IEnumerable<TR" +
                    "eturn> Read<TFirst, TSecond, TThird, TReturn>(Func<TFirst, TSecond, TThird, TRet" +
                    "urn> func, string splitOn)\r\n            {\r\n                return Read<TFirst, T" +
                    "Second, TThird, TReturn>(func, splitOn, true);\r\n            }\r\n#endif\r\n         " +
                    "       /// <summary>\r\n                /// Read multiple objects from a single re" +
                    "cordset on the grid\r\n                /// </summary>\r\n#if CSHARP30\r\n            p" +
                    "ublic IEnumerable<TReturn> Read<TFirst, TSecond, TThird, TReturn>(Func<TFirst, T" +
                    "Second, TThird, TReturn> func, string splitOn, bool buffered)\r\n#else\r\n          " +
                    "      public IEnumerable<TReturn> Read<TFirst, TSecond, TThird, TReturn>(Func<TF" +
                    "irst, TSecond, TThird, TReturn> func, string splitOn = \"id\", bool buffered = tru" +
                    "e)\r\n#endif\r\n                {\r\n                    var result = MultiReadInterna" +
                    "l<TFirst, TSecond, TThird, DontMap, DontMap, TReturn>(func, splitOn);\r\n         " +
                    "           return buffered ? result.ToList() : result;\r\n                }\r\n\r\n#if" +
                    " CSHARP30\r\n            /// <summary>\r\n            /// Read multiple objects from" +
                    " a single record set on the grid\r\n            /// </summary>\r\n            public" +
                    " IEnumerable<TReturn> Read<TFirst, TSecond, TThird, TFourth, TReturn>(Func<TFirs" +
                    "t, TSecond, TThird, TFourth, TReturn> func, string splitOn)\r\n            {\r\n    " +
                    "            return Read<TFirst, TSecond, TThird, TFourth, TReturn>(func, splitOn" +
                    ", true);\r\n            }\r\n#endif\r\n\r\n                /// <summary>\r\n              " +
                    "  /// Read multiple objects from a single record set on the grid\r\n              " +
                    "  /// </summary>\r\n#if CSHARP30\r\n            public IEnumerable<TReturn> Read<TFi" +
                    "rst, TSecond, TThird, TFourth, TReturn>(Func<TFirst, TSecond, TThird, TFourth, T" +
                    "Return> func, string splitOn, bool buffered)\r\n#else\r\n                public IEnu" +
                    "merable<TReturn> Read<TFirst, TSecond, TThird, TFourth, TReturn>(Func<TFirst, TS" +
                    "econd, TThird, TFourth, TReturn> func, string splitOn = \"id\", bool buffered = tr" +
                    "ue)\r\n#endif\r\n                {\r\n                    var result = MultiReadIntern" +
                    "al<TFirst, TSecond, TThird, TFourth, DontMap, TReturn>(func, splitOn);\r\n        " +
                    "            return buffered ? result.ToList() : result;\r\n                }\r\n\r\n\r\n" +
                    "\r\n#if !CSHARP30\r\n                /// <summary>\r\n                /// Read multipl" +
                    "e objects from a single record set on the grid\r\n                /// </summary>\r\n" +
                    "                public IEnumerable<TReturn> Read<TFirst, TSecond, TThird, TFourt" +
                    "h, TFifth, TReturn>(Func<TFirst, TSecond, TThird, TFourth, TFifth, TReturn> func" +
                    ", string splitOn = \"id\", bool buffered = true)\r\n                {\r\n             " +
                    "       var result = MultiReadInternal<TFirst, TSecond, TThird, TFourth, TFifth, " +
                    "TReturn>(func, splitOn);\r\n                    return buffered ? result.ToList() " +
                    ": result;\r\n                }\r\n#endif\r\n\r\n                private IEnumerable<T> R" +
                    "eadDeferred<T>(int index, Func<IDataReader, object> deserializer, Identity typed" +
                    "Identity)\r\n                {\r\n                    try\r\n                    {\r\n  " +
                    "                      while (index == gridIndex && reader.Read())\r\n             " +
                    "           {\r\n                            yield return (T)deserializer(reader);\r" +
                    "\n                        }\r\n                    }\r\n                    finally /" +
                    "/ finally so that First etc progresses things even when multiple rows\r\n         " +
                    "           {\r\n                        if (index == gridIndex)\r\n                 " +
                    "       {\r\n                            NextResult();\r\n                        }\r\n" +
                    "                    }\r\n                }\r\n                private int gridIndex," +
                    " readCount;\r\n                private bool consumed;\r\n                private voi" +
                    "d NextResult()\r\n                {\r\n                    if (reader.NextResult())\r" +
                    "\n                    {\r\n                        readCount++;\r\n                  " +
                    "      gridIndex++;\r\n                        consumed = false;\r\n                 " +
                    "   }\r\n                    else\r\n                    {\r\n                        /" +
                    "/ happy path; close the reader cleanly - no\r\n                        // need for" +
                    " \"Cancel\" etc\r\n                        reader.Dispose();\r\n                      " +
                    "  reader = null;\r\n\r\n                        Dispose();\r\n                    }\r\n\r" +
                    "\n                }\r\n                /// <summary>\r\n                /// Dispose t" +
                    "he grid, closing and disposing both the underlying reader and command.\r\n        " +
                    "        /// </summary>\r\n                public void Dispose()\r\n                {" +
                    "\r\n                    if (reader != null)\r\n                    {\r\n              " +
                    "          if (!reader.IsClosed && command != null) command.Cancel();\r\n          " +
                    "              reader.Dispose();\r\n                        reader = null;\r\n       " +
                    "             }\r\n                    if (command != null)\r\n                    {\r" +
                    "\n                        command.Dispose();\r\n                        command = n" +
                    "ull;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n    " +
                    "    /// <summary>\r\n        /// A bag of parameters that can be passed to the Dap" +
                    "per Query and Execute methods\r\n        /// </summary>\r\n        public partial cl" +
                    "ass DynamicParameters : SqlMapper.IDynamicParameters\r\n        {\r\n            int" +
                    "ernal const DbType EnumerableMultiParameter = (DbType)(-1);\r\n            static " +
                    "Dictionary<SqlMapper.Identity, Action<IDbCommand, object>> paramReaderCache = ne" +
                    "w Dictionary<SqlMapper.Identity, Action<IDbCommand, object>>();\r\n\r\n            D" +
                    "ictionary<string, ParamInfo> parameters = new Dictionary<string, ParamInfo>();\r\n" +
                    "            List<object> templates;\r\n\r\n            partial class ParamInfo\r\n    " +
                    "        {\r\n                public string Name { get; set; }\r\n                pub" +
                    "lic object Value { get; set; }\r\n                public ParameterDirection Parame" +
                    "terDirection { get; set; }\r\n                public DbType? DbType { get; set; }\r" +
                    "\n                public int? Size { get; set; }\r\n                public IDbDataP" +
                    "arameter AttachedParam { get; set; }\r\n            }\r\n\r\n            /// <summary>" +
                    "\r\n            /// construct a dynamic parameter bag\r\n            /// </summary>\r" +
                    "\n            public DynamicParameters() { }\r\n\r\n            /// <summary>\r\n      " +
                    "      /// construct a dynamic parameter bag\r\n            /// </summary>\r\n       " +
                    "     /// <param name=\"template\">can be an anonymous type or a DynamicParameters " +
                    "bag</param>\r\n            public DynamicParameters(object template)\r\n            " +
                    "{\r\n                AddDynamicParams(template);\r\n            }\r\n\r\n            ///" +
                    " <summary>\r\n            /// Append a whole object full of params to the dynamic\r" +
                    "\n            /// EG: AddDynamicParams(new {A = 1, B = 2}) // will add property A" +
                    " and B to the dynamic\r\n            /// </summary>\r\n            /// <param name=\"" +
                    "param\"></param>\r\n            public void AddDynamicParams(\r\n#if CSHARP30\r\n      " +
                    "      object param\r\n#else\r\ndynamic param\r\n#endif\r\n)\r\n            {\r\n            " +
                    "    var obj = param as object;\r\n                if (obj != null)\r\n              " +
                    "  {\r\n                    var subDynamic = obj as DynamicParameters;\r\n           " +
                    "         if (subDynamic == null)\r\n                    {\r\n                       " +
                    " var dictionary = obj as IEnumerable<KeyValuePair<string, object>>;\r\n           " +
                    "             if (dictionary == null)\r\n                        {\r\n               " +
                    "             templates = templates ?? new List<object>();\r\n                     " +
                    "       templates.Add(obj);\r\n                        }\r\n                        e" +
                    "lse\r\n                        {\r\n                            foreach (var kvp in " +
                    "dictionary)\r\n                            {\r\n#if CSHARP30\r\n                      " +
                    "      Add(kvp.Key, kvp.Value, null, null, null);\r\n#else\r\n                       " +
                    "         Add(kvp.Key, kvp.Value);\r\n#endif\r\n                            }\r\n      " +
                    "                  }\r\n                    }\r\n                    else\r\n          " +
                    "          {\r\n                        if (subDynamic.parameters != null)\r\n       " +
                    "                 {\r\n                            foreach (var kvp in subDynamic.p" +
                    "arameters)\r\n                            {\r\n                                param" +
                    "eters.Add(kvp.Key, kvp.Value);\r\n                            }\r\n                 " +
                    "       }\r\n\r\n                        if (subDynamic.templates != null)\r\n         " +
                    "               {\r\n                            templates = templates ?? new List<" +
                    "object>();\r\n                            foreach (var t in subDynamic.templates)\r" +
                    "\n                            {\r\n                                templates.Add(t)" +
                    ";\r\n                            }\r\n                        }\r\n                   " +
                    " }\r\n                }\r\n            }\r\n\r\n            /// <summary>\r\n            /" +
                    "// Add a parameter to this dynamic parameter list\r\n            /// </summary>\r\n " +
                    "           /// <param name=\"name\"></param>\r\n            /// <param name=\"value\">" +
                    "</param>\r\n            /// <param name=\"dbType\"></param>\r\n            /// <param " +
                    "name=\"direction\"></param>\r\n            /// <param name=\"size\"></param>\r\n        " +
                    "    public void Add(\r\n#if CSHARP30\r\n            string name, object value, DbTyp" +
                    "e? dbType, ParameterDirection? direction, int? size\r\n#else\r\nstring name, object " +
                    "value = null, DbType? dbType = null, ParameterDirection? direction = null, int? " +
                    "size = null\r\n#endif\r\n)\r\n            {\r\n                parameters[Clean(name)] =" +
                    " new ParamInfo() { Name = name, Value = value, ParameterDirection = direction ??" +
                    " ParameterDirection.Input, DbType = dbType, Size = size };\r\n            }\r\n\r\n   " +
                    "         static string Clean(string name)\r\n            {\r\n                if (!s" +
                    "tring.IsNullOrEmpty(name))\r\n                {\r\n                    switch (name[" +
                    "0])\r\n                    {\r\n                        case \'@\':\r\n                 " +
                    "       case \':\':\r\n                        case \'?\':\r\n                           " +
                    " return name.Substring(1);\r\n                    }\r\n                }\r\n          " +
                    "      return name;\r\n            }\r\n\r\n            void SqlMapper.IDynamicParamete" +
                    "rs.AddParameters(IDbCommand command, SqlMapper.Identity identity)\r\n            {" +
                    "\r\n                AddParameters(command, identity);\r\n            }\r\n\r\n          " +
                    "  /// <summary>\r\n            /// Add all the parameters needed to the command ju" +
                    "st before it executes\r\n            /// </summary>\r\n            /// <param name=\"" +
                    "command\">The raw command prior to execution</param>\r\n            /// <param name" +
                    "=\"identity\">Information about the query</param>\r\n            void AddParameters(" +
                    "IDbCommand command, SqlMapper.Identity identity)\r\n            {\r\n               " +
                    " if (templates != null)\r\n                {\r\n                    foreach (var tem" +
                    "plate in templates)\r\n                    {\r\n                        var newIdent" +
                    " = identity.ForDynamicParameters(template.GetType());\r\n                        A" +
                    "ction<IDbCommand, object> appender;\r\n\r\n                        lock (paramReader" +
                    "Cache)\r\n                        {\r\n                            if (!paramReaderC" +
                    "ache.TryGetValue(newIdent, out appender))\r\n                            {\r\n      " +
                    "                          appender = SqlMapper.CreateParamInfoGenerator(newIdent" +
                    ", true);\r\n                                paramReaderCache[newIdent] = appender;" +
                    "\r\n                            }\r\n                        }\r\n\r\n                  " +
                    "      appender(command, template);\r\n                    }\r\n                }\r\n\r\n" +
                    "                foreach (var param in parameters.Values)\r\n                {\r\n   " +
                    "                 var dbType = param.DbType;\r\n                    var val = param" +
                    ".Value;\r\n                    string name = Clean(param.Name);\r\n\r\n               " +
                    "     if (dbType == null && val != null) dbType = SqlMapper.LookupDbType(val.GetT" +
                    "ype(), name);\r\n\r\n                    if (dbType == DynamicParameters.EnumerableM" +
                    "ultiParameter)\r\n                    {\r\n#pragma warning disable 612, 618\r\n       " +
                    "                 SqlMapper.PackListParameters(command, name, val);\r\n#pragma warn" +
                    "ing restore 612, 618\r\n                    }\r\n                    else\r\n         " +
                    "           {\r\n\r\n                        bool add = !command.Parameters.Contains(" +
                    "name);\r\n                        IDbDataParameter p;\r\n                        if " +
                    "(add)\r\n                        {\r\n                            p = command.Create" +
                    "Parameter();\r\n                            p.ParameterName = name;\r\n             " +
                    "           }\r\n                        else\r\n                        {\r\n         " +
                    "                   p = (IDbDataParameter)command.Parameters[name];\r\n            " +
                    "            }\r\n\r\n                        p.Value = val ?? DBNull.Value;\r\n       " +
                    "                 p.Direction = param.ParameterDirection;\r\n                      " +
                    "  var s = val as string;\r\n                        if (s != null)\r\n              " +
                    "          {\r\n                            if (s.Length <= 4000)\r\n                " +
                    "            {\r\n                                p.Size = 4000;\r\n                 " +
                    "           }\r\n                        }\r\n                        if (param.Size " +
                    "!= null)\r\n                        {\r\n                            p.Size = param." +
                    "Size.Value;\r\n                        }\r\n                        if (dbType != nu" +
                    "ll)\r\n                        {\r\n                            p.DbType = dbType.Va" +
                    "lue;\r\n                        }\r\n                        if (add)\r\n             " +
                    "           {\r\n                            command.Parameters.Add(p);\r\n          " +
                    "              }\r\n                        param.AttachedParam = p;\r\n             " +
                    "       }\r\n\r\n                }\r\n            }\r\n\r\n            /// <summary>\r\n     " +
                    "       /// All the names of the param in the bag, use Get to yank them out\r\n    " +
                    "        /// </summary>\r\n            public IEnumerable<string> ParameterNames\r\n " +
                    "           {\r\n                get\r\n                {\r\n                    return" +
                    " parameters.Select(p => p.Key);\r\n                }\r\n            }\r\n\r\n\r\n         " +
                    "   /// <summary>\r\n            /// Get the value of a parameter\r\n            /// " +
                    "</summary>\r\n            /// <typeparam name=\"T\"></typeparam>\r\n            /// <p" +
                    "aram name=\"name\"></param>\r\n            /// <returns>The value, note DBNull.Value" +
                    " is not returned, instead the value is returned as null</returns>\r\n            p" +
                    "ublic T Get<T>(string name)\r\n            {\r\n                var val = parameters" +
                    "[Clean(name)].AttachedParam.Value;\r\n                if (val == DBNull.Value)\r\n  " +
                    "              {\r\n                    if (default(T) != null)\r\n                  " +
                    "  {\r\n                        throw new ApplicationException(\"Attempting to cast " +
                    "a DBNull to a non nullable type!\");\r\n                    }\r\n                    " +
                    "return default(T);\r\n                }\r\n                return (T)val;\r\n         " +
                    "   }\r\n        }\r\n\r\n        /// <summary>\r\n        /// This class represents a SQ" +
                    "L string, it can be used if you need to denote your parameter is a Char vs VarCh" +
                    "ar vs nVarChar vs nChar\r\n        /// </summary>\r\n        sealed partial class Db" +
                    "String\r\n        {\r\n            /// <summary>\r\n            /// Create a new DbStr" +
                    "ing\r\n            /// </summary>\r\n            public DbString() { Length = -1; }\r" +
                    "\n            /// <summary>\r\n            /// Ansi vs Unicode \r\n            /// </" +
                    "summary>\r\n            public bool IsAnsi { get; set; }\r\n            /// <summary" +
                    ">\r\n            /// Fixed length \r\n            /// </summary>\r\n            public" +
                    " bool IsFixedLength { get; set; }\r\n            /// <summary>\r\n            /// Le" +
                    "ngth of the string -1 for max\r\n            /// </summary>\r\n            public in" +
                    "t Length { get; set; }\r\n            /// <summary>\r\n            /// The value of " +
                    "the string\r\n            /// </summary>\r\n            public string Value { get; s" +
                    "et; }\r\n            /// <summary>\r\n            /// Add the parameter to the comma" +
                    "nd... internal use only\r\n            /// </summary>\r\n            /// <param name" +
                    "=\"command\"></param>\r\n            /// <param name=\"name\"></param>\r\n            pu" +
                    "blic void AddParameter(IDbCommand command, string name)\r\n            {\r\n        " +
                    "        if (IsFixedLength && Length == -1)\r\n                {\r\n                 " +
                    "   throw new InvalidOperationException(\"If specifying IsFixedLength,  a Length m" +
                    "ust also be specified\");\r\n                }\r\n                var param = command" +
                    ".CreateParameter();\r\n                param.ParameterName = name;\r\n              " +
                    "  param.Value = (object)Value ?? DBNull.Value;\r\n                if (Length == -1" +
                    " && Value != null && Value.Length <= 4000)\r\n                {\r\n                 " +
                    "   param.Size = 4000;\r\n                }\r\n                else\r\n                " +
                    "{\r\n                    param.Size = Length;\r\n                }\r\n                " +
                    "param.DbType = IsAnsi ? (IsFixedLength ? DbType.AnsiStringFixedLength : DbType.A" +
                    "nsiString) : (IsFixedLength ? DbType.StringFixedLength : DbType.String);\r\n      " +
                    "          command.Parameters.Add(param);\r\n            }\r\n        }\r\n\r\n        //" +
                    "/ <summary>\r\n        /// Handles variances in features per DBMS\r\n        /// </s" +
                    "ummary>\r\n        partial class FeatureSupport\r\n        {\r\n            /// <summa" +
                    "ry>\r\n            /// Dictionary of supported features index by connection type n" +
                    "ame\r\n            /// </summary>\r\n            private static readonly Dictionary<" +
                    "string, FeatureSupport> FeatureList = new Dictionary<string, FeatureSupport>(Str" +
                    "ingComparer.InvariantCultureIgnoreCase) {\r\n                {\"sqlserverconnection" +
                    "\", new FeatureSupport { Arrays = false}},\r\n                {\"npgsqlconnection\", " +
                    "new FeatureSupport {Arrays = true}}\r\n        };\r\n\r\n            /// <summary>\r\n  " +
                    "          /// Gets the featureset based on the passed connection\r\n            //" +
                    "/ </summary>\r\n            public static FeatureSupport Get(IDbConnection connect" +
                    "ion)\r\n            {\r\n                string name = connection.GetType().Name;\r\n " +
                    "               FeatureSupport features;\r\n                return FeatureList.TryG" +
                    "etValue(name, out features) ? features : FeatureList.Values.First();\r\n          " +
                    "  }\r\n\r\n            /// <summary>\r\n            /// True if the db supports array " +
                    "columns e.g. Postgresql\r\n            /// </summary>\r\n            public bool Arr" +
                    "ays { get; set; }\r\n        }\r\n\r\n        /// <summary>\r\n        /// Represents si" +
                    "mple memeber map for one of target parameter or property or field to source Data" +
                    "Reader column\r\n        /// </summary>\r\n        sealed partial class SimpleMember" +
                    "Map : SqlMapper.IMemberMap\r\n        {\r\n            private readonly string _colu" +
                    "mnName;\r\n            private readonly PropertyInfo _property;\r\n            priva" +
                    "te readonly FieldInfo _field;\r\n            private readonly ParameterInfo _param" +
                    "eter;\r\n\r\n            /// <summary>\r\n            /// Creates instance for simple " +
                    "property mapping\r\n            /// </summary>\r\n            /// <param name=\"colum" +
                    "nName\">DataReader column name</param>\r\n            /// <param name=\"property\">Ta" +
                    "rget property</param>\r\n            public SimpleMemberMap(string columnName, Pro" +
                    "pertyInfo property)\r\n            {\r\n                if (columnName == null)\r\n   " +
                    "                 throw new ArgumentNullException(\"columnName\");\r\n\r\n             " +
                    "   if (property == null)\r\n                    throw new ArgumentNullException(\"p" +
                    "roperty\");\r\n\r\n                _columnName = columnName;\r\n                _proper" +
                    "ty = property;\r\n            }\r\n\r\n            /// <summary>\r\n            /// Crea" +
                    "tes instance for simple field mapping\r\n            /// </summary>\r\n            /" +
                    "// <param name=\"columnName\">DataReader column name</param>\r\n            /// <par" +
                    "am name=\"field\">Target property</param>\r\n            public SimpleMemberMap(stri" +
                    "ng columnName, FieldInfo field)\r\n            {\r\n                if (columnName =" +
                    "= null)\r\n                    throw new ArgumentNullException(\"columnName\");\r\n\r\n " +
                    "               if (field == null)\r\n                    throw new ArgumentNullExc" +
                    "eption(\"field\");\r\n\r\n                _columnName = columnName;\r\n                _" +
                    "field = field;\r\n            }\r\n\r\n            /// <summary>\r\n            /// Crea" +
                    "tes instance for simple constructor parameter mapping\r\n            /// </summary" +
                    ">\r\n            /// <param name=\"columnName\">DataReader column name</param>\r\n    " +
                    "        /// <param name=\"parameter\">Target constructor parameter</param>\r\n      " +
                    "      public SimpleMemberMap(string columnName, ParameterInfo parameter)\r\n      " +
                    "      {\r\n                if (columnName == null)\r\n                    throw new " +
                    "ArgumentNullException(\"columnName\");\r\n\r\n                if (parameter == null)\r\n" +
                    "                    throw new ArgumentNullException(\"parameter\");\r\n\r\n           " +
                    "     _columnName = columnName;\r\n                _parameter = parameter;\r\n       " +
                    "     }\r\n\r\n            /// <summary>\r\n            /// DataReader column name\r\n   " +
                    "         /// </summary>\r\n            public string ColumnName\r\n            {\r\n  " +
                    "              get { return _columnName; }\r\n            }\r\n\r\n            /// <sum" +
                    "mary>\r\n            /// Target member type\r\n            /// </summary>\r\n         " +
                    "   public Type MemberType\r\n            {\r\n                get\r\n                {" +
                    "\r\n                    if (_field != null)\r\n                        return _field" +
                    ".FieldType;\r\n\r\n                    if (_property != null)\r\n                     " +
                    "   return _property.PropertyType;\r\n\r\n                    if (_parameter != null)" +
                    "\r\n                        return _parameter.ParameterType;\r\n\r\n                  " +
                    "  return null;\r\n                }\r\n            }\r\n\r\n            /// <summary>\r\n " +
                    "           /// Target property\r\n            /// </summary>\r\n            public P" +
                    "ropertyInfo Property\r\n            {\r\n                get { return _property; }\r\n" +
                    "            }\r\n\r\n            /// <summary>\r\n            /// Target field\r\n      " +
                    "      /// </summary>\r\n            public FieldInfo Field\r\n            {\r\n       " +
                    "         get { return _field; }\r\n            }\r\n\r\n            /// <summary>\r\n   " +
                    "         /// Target constructor parameter\r\n            /// </summary>\r\n         " +
                    "   public ParameterInfo Parameter\r\n            {\r\n                get { return _" +
                    "parameter; }\r\n            }\r\n        }\r\n\r\n        /// <summary>\r\n        /// Rep" +
                    "resents default type mapping strategy used by Dapper\r\n        /// </summary>\r\n  " +
                    "      sealed partial class DefaultTypeMap : SqlMapper.ITypeMap\r\n        {\r\n     " +
                    "       private readonly List<FieldInfo> _fields;\r\n            private readonly L" +
                    "ist<PropertyInfo> _properties;\r\n            private readonly Type _type;\r\n\r\n    " +
                    "        /// <summary>\r\n            /// Creates default type map\r\n            ///" +
                    " </summary>\r\n            /// <param name=\"type\">Entity type</param>\r\n           " +
                    " public DefaultTypeMap(Type type)\r\n            {\r\n                if (type == nu" +
                    "ll)\r\n                    throw new ArgumentNullException(\"type\");\r\n\r\n           " +
                    "     _fields = GetSettableFields(type);\r\n                _properties = GetSettab" +
                    "leProps(type);\r\n                _type = type;\r\n            }\r\n\r\n            inte" +
                    "rnal static MethodInfo GetPropertySetter(PropertyInfo propertyInfo, Type type)\r\n" +
                    "            {\r\n                return propertyInfo.DeclaringType == type ?\r\n    " +
                    "                propertyInfo.GetSetMethod(true) :\r\n                    propertyI" +
                    "nfo.DeclaringType.GetProperty(propertyInfo.Name, BindingFlags.Public | BindingFl" +
                    "ags.NonPublic | BindingFlags.Instance).GetSetMethod(true);\r\n            }\r\n\r\n   " +
                    "         internal static List<PropertyInfo> GetSettableProps(Type t)\r\n          " +
                    "  {\r\n                return t\r\n                      .GetProperties(BindingFlags" +
                    ".Public | BindingFlags.NonPublic | BindingFlags.Instance)\r\n                     " +
                    " .Where(p => GetPropertySetter(p, t) != null)\r\n                      .ToList();\r" +
                    "\n            }\r\n\r\n            internal static List<FieldInfo> GetSettableFields(" +
                    "Type t)\r\n            {\r\n                return t.GetFields(BindingFlags.Public |" +
                    " BindingFlags.NonPublic | BindingFlags.Instance).ToList();\r\n            }\r\n\r\n   " +
                    "         /// <summary>\r\n            /// Finds best constructor\r\n            /// " +
                    "</summary>\r\n            /// <param name=\"names\">DataReader column names</param>\r" +
                    "\n            /// <param name=\"types\">DataReader column types</param>\r\n          " +
                    "  /// <returns>Matching constructor or default one</returns>\r\n            public" +
                    " ConstructorInfo FindConstructor(string[] names, Type[] types)\r\n            {\r\n " +
                    "               var constructors = _type.GetConstructors(BindingFlags.Instance | " +
                    "BindingFlags.Public | BindingFlags.NonPublic);\r\n                foreach (Constru" +
                    "ctorInfo ctor in constructors.OrderBy(c => c.IsPublic ? 0 : (c.IsPrivate ? 2 : 1" +
                    ")).ThenBy(c => c.GetParameters().Length))\r\n                {\r\n                  " +
                    "  ParameterInfo[] ctorParameters = ctor.GetParameters();\r\n                    if" +
                    " (ctorParameters.Length == 0)\r\n                        return ctor;\r\n\r\n         " +
                    "           if (ctorParameters.Length != types.Length)\r\n                        c" +
                    "ontinue;\r\n\r\n                    int i = 0;\r\n                    for (; i < ctorP" +
                    "arameters.Length; i++)\r\n                    {\r\n                        if (!Stri" +
                    "ng.Equals(ctorParameters[i].Name, names[i], StringComparison.OrdinalIgnoreCase))" +
                    "\r\n                            break;\r\n                        if (types[i] == ty" +
                    "peof(byte[]) && ctorParameters[i].ParameterType.FullName == SqlMapper.LinqBinary" +
                    ")\r\n                            continue;\r\n                        var unboxedTyp" +
                    "e = Nullable.GetUnderlyingType(ctorParameters[i].ParameterType) ?? ctorParameter" +
                    "s[i].ParameterType;\r\n                        if (unboxedType != types[i]\r\n      " +
                    "                      && !(unboxedType.IsEnum && Enum.GetUnderlyingType(unboxedT" +
                    "ype) == types[i])\r\n                            && !(unboxedType == typeof(char) " +
                    "&& types[i] == typeof(string)))\r\n                            break;\r\n           " +
                    "         }\r\n\r\n                    if (i == ctorParameters.Length)\r\n             " +
                    "           return ctor;\r\n                }\r\n\r\n                return null;\r\n    " +
                    "        }\r\n\r\n            /// <summary>\r\n            /// Gets mapping for constru" +
                    "ctor parameter\r\n            /// </summary>\r\n            /// <param name=\"constru" +
                    "ctor\">Constructor to resolve</param>\r\n            /// <param name=\"columnName\">D" +
                    "ataReader column name</param>\r\n            /// <returns>Mapping implementation</" +
                    "returns>\r\n            public SqlMapper.IMemberMap GetConstructorParameter(Constr" +
                    "uctorInfo constructor, string columnName)\r\n            {\r\n                var pa" +
                    "rameters = constructor.GetParameters();\r\n\r\n                return new SimpleMemb" +
                    "erMap(columnName, parameters.FirstOrDefault(p => string.Equals(p.Name, columnNam" +
                    "e, StringComparison.OrdinalIgnoreCase)));\r\n            }\r\n\r\n            /// <sum" +
                    "mary>\r\n            /// Gets member mapping for column\r\n            /// </summary" +
                    ">\r\n            /// <param name=\"columnName\">DataReader column name</param>\r\n    " +
                    "        /// <returns>Mapping implementation</returns>\r\n            public SqlMap" +
                    "per.IMemberMap GetMember(string columnName)\r\n            {\r\n                var " +
                    "property = _properties.FirstOrDefault(p => string.Equals(p.Name, columnName, Str" +
                    "ingComparison.Ordinal))\r\n                   ?? _properties.FirstOrDefault(p => s" +
                    "tring.Equals(p.Name, columnName, StringComparison.OrdinalIgnoreCase));\r\n\r\n      " +
                    "          if (property != null)\r\n                    return new SimpleMemberMap(" +
                    "columnName, property);\r\n\r\n                var field = _fields.FirstOrDefault(p =" +
                    "> string.Equals(p.Name, columnName, StringComparison.Ordinal))\r\n                " +
                    "   ?? _fields.FirstOrDefault(p => string.Equals(p.Name, columnName, StringCompar" +
                    "ison.OrdinalIgnoreCase));\r\n\r\n                if (field != null)\r\n               " +
                    "     return new SimpleMemberMap(columnName, field);\r\n\r\n                return nu" +
                    "ll;\r\n            }\r\n        }\r\n\r\n        /// <summary>\r\n        /// Implements c" +
                    "ustom property mapping by user provided criteria (usually presence of some custo" +
                    "m attribute with column to member mapping)\r\n        /// </summary>\r\n        seal" +
                    "ed partial class CustomPropertyTypeMap : SqlMapper.ITypeMap\r\n        {\r\n        " +
                    "    private readonly Type _type;\r\n            private readonly Func<Type, string" +
                    ", PropertyInfo> _propertySelector;\r\n\r\n            /// <summary>\r\n            ///" +
                    " Creates custom property mapping\r\n            /// </summary>\r\n            /// <p" +
                    "aram name=\"type\">Target entity type</param>\r\n            /// <param name=\"proper" +
                    "tySelector\">Property selector based on target type and DataReader column name</p" +
                    "aram>\r\n            public CustomPropertyTypeMap(Type type, Func<Type, string, Pr" +
                    "opertyInfo> propertySelector)\r\n            {\r\n                if (type == null)\r" +
                    "\n                    throw new ArgumentNullException(\"type\");\r\n\r\n               " +
                    " if (propertySelector == null)\r\n                    throw new ArgumentNullExcept" +
                    "ion(\"propertySelector\");\r\n\r\n                _type = type;\r\n                _prop" +
                    "ertySelector = propertySelector;\r\n            }\r\n\r\n            /// <summary>\r\n  " +
                    "          /// Always returns default constructor\r\n            /// </summary>\r\n  " +
                    "          /// <param name=\"names\">DataReader column names</param>\r\n            /" +
                    "// <param name=\"types\">DataReader column types</param>\r\n            /// <returns" +
                    ">Default constructor</returns>\r\n            public ConstructorInfo FindConstruct" +
                    "or(string[] names, Type[] types)\r\n            {\r\n                return _type.Ge" +
                    "tConstructor(new Type[0]);\r\n            }\r\n\r\n            /// <summary>\r\n        " +
                    "    /// Not impelmeneted as far as default constructor used for all cases\r\n     " +
                    "       /// </summary>\r\n            /// <param name=\"constructor\"></param>\r\n     " +
                    "       /// <param name=\"columnName\"></param>\r\n            /// <returns></returns" +
                    ">\r\n            public SqlMapper.IMemberMap GetConstructorParameter(ConstructorIn" +
                    "fo constructor, string columnName)\r\n            {\r\n                throw new Not" +
                    "SupportedException();\r\n            }\r\n\r\n            /// <summary>\r\n            /" +
                    "// Returns property based on selector strategy\r\n            /// </summary>\r\n    " +
                    "        /// <param name=\"columnName\">DataReader column name</param>\r\n           " +
                    " /// <returns>Poperty member map</returns>\r\n            public SqlMapper.IMember" +
                    "Map GetMember(string columnName)\r\n            {\r\n                var prop = _pro" +
                    "pertySelector(_type, columnName);\r\n                return prop != null ? new Sim" +
                    "pleMemberMap(columnName, prop) : null;\r\n            }\r\n        }\r\n\r\n\r\n        pu" +
                    "blic static class SqlMapperExtensions\r\n        {\r\n            public interface I" +
                    "Proxy\r\n            {\r\n                bool IsDirty { get; set; }\r\n            }\r" +
                    "\n\r\n\r\n            public class SqlWhereOrderCache\r\n            {\r\n               " +
                    " public string Sql { get; set; }\r\n                public IEnumerable<string> Whe" +
                    "re { get; set; }\r\n                public IEnumerable<string> Order { get; set; }" +
                    "\r\n            }\r\n\r\n            private static readonly ConcurrentDictionary<Runt" +
                    "imeTypeHandle, IEnumerable<PropertyInfo>> KeyProperties = new ConcurrentDictiona" +
                    "ry<RuntimeTypeHandle, IEnumerable<PropertyInfo>>();\r\n            private static " +
                    "readonly ConcurrentDictionary<RuntimeTypeHandle, IEnumerable<PropertyInfo>> Type" +
                    "Properties = new ConcurrentDictionary<RuntimeTypeHandle, IEnumerable<PropertyInf" +
                    "o>>();\r\n            private static readonly ConcurrentDictionary<RuntimeTypeHand" +
                    "le, string> GetQueries = new ConcurrentDictionary<RuntimeTypeHandle, string>();\r" +
                    "\n            private static readonly ConcurrentDictionary<RuntimeTypeHandle, str" +
                    "ing> TypeTableName = new ConcurrentDictionary<RuntimeTypeHandle, string>();\r\n   " +
                    "         private static readonly ConcurrentDictionary<RuntimeTypeHandle, string>" +
                    " GetQueriesAll = new ConcurrentDictionary<RuntimeTypeHandle, string>();\r\n       " +
                    "     private static readonly ConcurrentDictionary<int, SqlWhereOrderCache> GetQu" +
                    "eriesWhereOrder = new ConcurrentDictionary<int, SqlWhereOrderCache>();\r\n\r\n\r\n    " +
                    "        private static readonly Dictionary<string, ISqlAdapter> AdapterDictionar" +
                    "y = new Dictionary<string, ISqlAdapter>() {\r\n                                   " +
                    "                                                         {\"sqlconnection\", new S" +
                    "qlServerAdapter()},\r\n                                                           " +
                    "                                 {\"npgsqlconnection\", new PostgresAdapter()}\r\n  " +
                    "                                                                                " +
                    "      };\r\n\r\n            private static IEnumerable<PropertyInfo> KeyPropertiesCa" +
                    "che(Type type)\r\n            {\r\n\r\n                IEnumerable<PropertyInfo> pi;\r\n" +
                    "                if (KeyProperties.TryGetValue(type.TypeHandle, out pi))\r\n       " +
                    "         {\r\n                    return pi;\r\n                }\r\n\r\n               " +
                    " var allProperties = TypePropertiesCache(type);\r\n                var keyProperti" +
                    "es = allProperties.Where(p => p.GetCustomAttributes(true).Any(a => a is KeyAttri" +
                    "bute)).ToList();\r\n\r\n                if (keyProperties.Count == 0)\r\n             " +
                    "   {\r\n                    var idProp = allProperties.Where(p => p.Name.ToLower()" +
                    " == \"id\").FirstOrDefault();\r\n                    if (idProp != null)\r\n          " +
                    "          {\r\n                        keyProperties.Add(idProp);\r\n               " +
                    "     }\r\n                }\r\n\r\n                KeyProperties[type.TypeHandle] = ke" +
                    "yProperties;\r\n                return keyProperties;\r\n            }\r\n            " +
                    "private static IEnumerable<PropertyInfo> TypePropertiesCache(Type type)\r\n       " +
                    "     {\r\n                IEnumerable<PropertyInfo> pis;\r\n                if (Type" +
                    "Properties.TryGetValue(type.TypeHandle, out pis))\r\n                {\r\n          " +
                    "          return pis;\r\n                }\r\n\r\n                var properties = typ" +
                    "e.GetProperties().Where(IsWriteable);\r\n                TypeProperties[type.TypeH" +
                    "andle] = properties;\r\n                return properties;\r\n            }\r\n\r\n     " +
                    "       public static bool IsWriteable(PropertyInfo pi)\r\n            {\r\n         " +
                    "       object[] attributes = pi.GetCustomAttributes(typeof(WriteAttribute), fals" +
                    "e);\r\n                if (attributes.Length == 1)\r\n                {\r\n           " +
                    "         WriteAttribute write = (WriteAttribute)attributes[0];\r\n                " +
                    "    return write.Write;\r\n                }\r\n                return true;\r\n      " +
                    "      }\r\n\r\n\r\n            /// <summary>\r\n            /// </summary>\r\n            " +
                    "/// <typeparam name=\"T\">Interface type to create and populate</typeparam>\r\n     " +
                    "       /// <param name=\"connection\">Open SqlConnection</param>\r\n            /// " +
                    "<param name=\"transaction\"></param>\r\n            /// <param name=\"commandTimeout\"" +
                    "></param>\r\n            /// <returns>Entity of T</returns>\r\n            public st" +
                    "atic IEnumerable<T> GetAll<T>(this IDbConnection connection, IDbTransaction tran" +
                    "saction = null, int? commandTimeout = null) where T : class\r\n            {\r\n    " +
                    "            var type = typeof(T);\r\n                string sql;\r\n                " +
                    "if (!GetQueriesAll.TryGetValue(type.TypeHandle, out sql))\r\n                {\r\n  " +
                    "                  var name = GetTableName(type);\r\n\r\n                    // TODO:" +
                    " pluralizer \r\n                    // TODO: query information schema and only sel" +
                    "ect fields that are both in information schema and underlying class / interface " +
                    "\r\n                    sql = string.Format(\"select * from {0}\", name);\r\n         " +
                    "           GetQueriesAll[type.TypeHandle] = sql;\r\n                }\r\n\r\n         " +
                    "       IEnumerable<T> obj = null;\r\n\r\n                if (type.IsInterface)\r\n    " +
                    "            {\r\n                    var res = connection.Query(sql);\r\n           " +
                    "         if (!res.Any())\r\n                        return (IEnumerable<T>)((objec" +
                    "t)null);\r\n                    var objList = new List<T>();\r\n                    " +
                    "foreach (var item in res)\r\n                    {\r\n                        T objI" +
                    "tem = ProxyGenerator.GetInterfaceProxy<T>();\r\n\r\n                        foreach " +
                    "(var property in TypePropertiesCache(type))\r\n                        {\r\n        " +
                    "                    var val = item[property.Name];\r\n                            " +
                    "property.SetValue(objItem, val, null);\r\n                        }\r\n\r\n           " +
                    "             ((IProxy)objItem).IsDirty = false;   //reset change tracking and re" +
                    "turn   \r\n                        objList.Add(objItem);\r\n                    }\r\n " +
                    "                   obj = objList.AsEnumerable();\r\n                }\r\n           " +
                    "     else\r\n                {\r\n                    obj = connection.Query<T>(sql," +
                    " transaction: transaction, commandTimeout: commandTimeout);\r\n                }\r\n" +
                    "                return obj;\r\n            }\r\n\r\n            /// <summary>\r\n       " +
                    "     /// </summary>\r\n            /// <typeparam name=\"T\">Interface type to creat" +
                    "e and populate</typeparam>\r\n            /// <param name=\"connection\">Open SqlCon" +
                    "nection</param>\r\n            /// <param name=\"where\"></param>\r\n            /// <" +
                    "param name=\"order\"></param>\r\n            /// <returns>Entity of T</returns>\r\n   " +
                    "         public static IEnumerable<T> GetBy<T>(this IDbConnection connection, ob" +
                    "ject where = null, object order = null, IDbTransaction transaction = null, int? " +
                    "commandTimeout = null) where T : class\r\n            {\r\n                var type " +
                    "= typeof(T);\r\n                var isUseWhere = where != null;\r\n                v" +
                    "ar isUseOrder = order != null;\r\n                if (!isUseWhere && !isUseOrder)\r" +
                    "\n                {\r\n                    return GetAll<T>(connection: connection," +
                    " transaction: transaction, commandTimeout: commandTimeout);\r\n                }\r\n" +
                    "                var whereType = isUseWhere ? where.GetType() : null;\r\n          " +
                    "      var orderType = isUseOrder ? order.GetType() : null;\r\n                SqlW" +
                    "hereOrderCache cache;\r\n                var key = GetKeyTypeWhereOrder(type, wher" +
                    "eType, orderType);\r\n                if (!GetQueriesWhereOrder.TryGetValue(key, o" +
                    "ut cache))\r\n                {\r\n                    cache = new SqlWhereOrderCach" +
                    "e();\r\n                    if (isUseWhere)\r\n                    {\r\n              " +
                    "          cache.Where = GetListOfNames(whereType.GetProperties());\r\n            " +
                    "        }\r\n                    if (isUseOrder)\r\n                    {\r\n         " +
                    "               cache.Order = GetListOfNames(orderType.GetProperties());\r\n       " +
                    "             }\r\n                    var name = GetTableName(type);\r\n            " +
                    "        StringBuilder sb = new StringBuilder();\r\n                    sb.AppendFo" +
                    "rmat(\"select * from {0}\", name);\r\n                    int cnt, last, i;\r\n       " +
                    "             if (isUseWhere)\r\n                    {\r\n                        sb." +
                    "Append(\" where \");\r\n                        cnt = cache.Where.Count();\r\n        " +
                    "                last = cnt - 1;\r\n                        for (i = 0; i < cnt; i+" +
                    "+)\r\n                        {\r\n                            var prop = cache.Wher" +
                    "e.ElementAt(i);\r\n                            sb.AppendFormat(\"[{0}]=@{1}\", prop," +
                    " prop);\r\n                            if (i != last)\r\n                           " +
                    " {\r\n                                sb.Append(\" and \");\r\n                       " +
                    "     }\r\n\r\n                        }\r\n                    }\r\n                    " +
                    "if (isUseOrder)\r\n                    {\r\n                        sb.Append(\" orde" +
                    "r by \");\r\n                        cnt = cache.Order.Count();\r\n                  " +
                    "      last = cnt - 1;\r\n                        for (i = 0; i < cnt; i++)\r\n      " +
                    "                  {\r\n                            var prop = cache.Order.ElementA" +
                    "t(i);\r\n                            sb.AppendFormat(\"[{0}] #{1}\", prop, prop);\r\n " +
                    "                           if (i != last)\r\n                            {\r\n      " +
                    "                          sb.Append(\", \");\r\n                            }\r\n     " +
                    "                   }\r\n                    }\r\n\r\n                    // TODO: plur" +
                    "alizer \r\n                    // TODO: query information schema and only select f" +
                    "ields that are both in information schema and underlying class / interface \r\n   " +
                    "                 cache.Sql = sb.ToString();\r\n                    GetQueriesWhere" +
                    "Order[key] = cache;\r\n                }\r\n\r\n                IEnumerable<T> obj = n" +
                    "ull;\r\n                var dynParms = new DynamicParameters();\r\n                i" +
                    "f (isUseWhere)\r\n                {\r\n                    foreach (string name in c" +
                    "ache.Where)\r\n                    {\r\n                        dynParms.Add(name, w" +
                    "hereType.GetProperty(name).GetValue(where, null));\r\n                    }\r\n     " +
                    "           }\r\n                if (isUseOrder)\r\n                {\r\n              " +
                    "      foreach (string name in cache.Order)\r\n                    {\r\n             " +
                    "           SortAs enumVal = (SortAs)orderType.GetProperty(name).GetValue(order, " +
                    "null);\r\n                        switch (enumVal)\r\n                        {\r\n   " +
                    "                         case SortAs.Asc:\r\n                                cache" +
                    ".Sql = cache.Sql.Replace(\"#\" + name, \"ASC\");\r\n                                br" +
                    "eak;\r\n                            case SortAs.Desc:\r\n                           " +
                    "     cache.Sql = cache.Sql.Replace(\"#\" + name, \"DESC\");\r\n                       " +
                    "         break;\r\n                            default:\r\n                         " +
                    "       throw new ArgumentOutOfRangeException();\r\n                        }\r\n    " +
                    "                }\r\n                }\r\n                if (type.IsInterface)\r\n   " +
                    "             {\r\n                    var res = connection.Query(cache.Sql);\r\n    " +
                    "                if (!res.Any())\r\n                        return (IEnumerable<T>)" +
                    "((object)null);\r\n                    var objList = new List<T>();\r\n             " +
                    "       foreach (var item in res)\r\n                    {\r\n                       " +
                    " T objItem = ProxyGenerator.GetInterfaceProxy<T>();\r\n\r\n                        f" +
                    "oreach (var property in TypePropertiesCache(type))\r\n                        {\r\n " +
                    "                           var val = item[property.Name];\r\n                     " +
                    "       property.SetValue(objItem, val, null);\r\n                        }\r\n\r\n    " +
                    "                    ((IProxy)objItem).IsDirty = false;   //reset change tracking" +
                    " and return   \r\n                        objList.Add(objItem);\r\n                 " +
                    "   }\r\n                    obj = objList.AsEnumerable();\r\n                }\r\n    " +
                    "            else\r\n                {\r\n                    obj = connection.Query<" +
                    "T>(cache.Sql, dynParms, transaction: transaction, commandTimeout: commandTimeout" +
                    ");\r\n                }\r\n                return obj;\r\n            }\r\n\r\n           " +
                    " /// <summary>\r\n            /// Returns a single entity by a single id from tabl" +
                    "e \"Ts\". T must be of interface type. \r\n            /// Id must be marked with [K" +
                    "ey] attribute.\r\n            /// Created entity is tracked/intercepted for change" +
                    "s and used by the Update() extension. \r\n            /// </summary>\r\n            " +
                    "/// <typeparam name=\"T\">Interface type to create and populate</typeparam>\r\n     " +
                    "       /// <param name=\"connection\">Open SqlConnection</param>\r\n            /// " +
                    "<param name=\"id\">Id of the entity to get, must be marked with [Key] attribute</p" +
                    "aram>\r\n            /// <returns>Entity of T</returns>\r\n            public static" +
                    " T Get<T>(this IDbConnection connection, dynamic id, IDbTransaction transaction " +
                    "= null, int? commandTimeout = null) where T : BaseModel\r\n            {\r\n        " +
                    "        var type = typeof(T);\r\n                string sql;\r\n                if (" +
                    "!GetQueries.TryGetValue(type.TypeHandle, out sql))\r\n                {\r\n         " +
                    "           var keys = KeyPropertiesCache(type);\r\n                    if (keys.Co" +
                    "unt() > 1)\r\n                        throw new DataException(\"Get<T> only support" +
                    "s an entity with a single [Key] property\");\r\n                    if (keys.Count(" +
                    ") == 0)\r\n                        throw new DataException(\"Get<T> only supports e" +
                    "n entity with a [Key] property\");\r\n\r\n                    var onlyKey = keys.Firs" +
                    "t();\r\n\r\n                    var name = GetTableName(type);\r\n\r\n                  " +
                    "  // TODO: pluralizer \r\n                    // TODO: query information schema an" +
                    "d only select fields that are both in information schema and underlying class / " +
                    "interface \r\n                    sql = \"select * from \" + name + \" where [\" + onl" +
                    "yKey.Name + \"] = @id\";\r\n                    GetQueries[type.TypeHandle] = sql;\r\n" +
                    "                }\r\n\r\n                var dynParms = new DynamicParameters();\r\n  " +
                    "              dynParms.Add(\"@id\", id);\r\n\r\n                T obj = null;\r\n\r\n     " +
                    "           if (type.IsInterface)\r\n                {\r\n                    var res" +
                    " = connection.Query(sql, dynParms).FirstOrDefault() as IDictionary<string, objec" +
                    "t>;\r\n\r\n                    if (res == null)\r\n                        return (T)(" +
                    "(object)null);\r\n\r\n                    obj = ProxyGenerator.GetInterfaceProxy<T>(" +
                    ");\r\n\r\n                    foreach (var property in TypePropertiesCache(type))\r\n " +
                    "                   {\r\n                        var val = res[property.Name];\r\n   " +
                    "                     property.SetValue(obj, val, null);\r\n                    }\r\n" +
                    "\r\n                    ((IProxy)obj).IsDirty = false;   //reset change tracking a" +
                    "nd return\r\n                }\r\n                else\r\n                {\r\n         " +
                    "           obj = connection.Query<T>(sql, dynParms, transaction: transaction, co" +
                    "mmandTimeout: commandTimeout).FirstOrDefault();\r\n                }\r\n            " +
                    "    return obj;\r\n            }\r\n\r\n            private static int GetKeyTypeWhere" +
                    "Order(Type type, Type where, Type order)\r\n            {\r\n                var han" +
                    "dler = type.TypeHandle;\r\n                string whereCondition = @where != null " +
                    "? @where.TypeHandle.Value.ToString() : string.Empty;\r\n                string ord" +
                    "erCondition = order != null ? order.TypeHandle.Value.ToString() : string.Empty; " +
                    ";\r\n                var str = string.Format(\"{0}{1}{2}\", handler.Value, whereCond" +
                    "ition, orderCondition);\r\n                return str.GetHashCode();\r\n            " +
                    "}\r\n\r\n            private static IEnumerable<string> GetListOfNames(PropertyInfo[" +
                    "] list)\r\n            {\r\n                List<string> lst = new List<string>();\r\n" +
                    "                foreach (PropertyInfo info in list)\r\n                {\r\n        " +
                    "            lst.Add(info.Name);\r\n                }\r\n                return lst.A" +
                    "sEnumerable();\r\n            }\r\n\r\n            private static string GetTableName(" +
                    "Type type)\r\n            {\r\n                string name;\r\n                if (!Ty" +
                    "peTableName.TryGetValue(type.TypeHandle, out name))\r\n                {\r\n        " +
                    "            name = type.Name + \"s\";\r\n                    if (type.IsInterface &&" +
                    " name.StartsWith(\"I\"))\r\n                        name = name.Substring(1);\r\n\r\n   " +
                    "                 //NOTE: This as dynamic trick should be able to handle both our" +
                    " own Table-attribute as well as the one in EntityFramework \r\n                   " +
                    " var tableattr = type.GetCustomAttributes(false).Where(attr => attr.GetType().Na" +
                    "me == \"TableAttribute\").SingleOrDefault() as\r\n                        dynamic;\r\n" +
                    "                    if (tableattr != null)\r\n                        name = table" +
                    "attr.Name;\r\n                    TypeTableName[type.TypeHandle] = name;\r\n        " +
                    "        }\r\n                return name;\r\n            }\r\n\r\n            /// <summa" +
                    "ry>\r\n            /// Inserts an entity into table \"Ts\" and returns identity id.\r" +
                    "\n            /// </summary>\r\n            /// <param name=\"connection\">Open SqlCo" +
                    "nnection</param>\r\n            /// <param name=\"entityToInsert\">Entity to insert<" +
                    "/param>\r\n            /// <returns>Identity of inserted entity</returns>\r\n       " +
                    "     public static long Insert<T>(this IDbConnection connection, T entityToInser" +
                    "t, IDbTransaction transaction = null, int? commandTimeout = null) where T : clas" +
                    "s\r\n            {\r\n\r\n                var type = typeof(T);\r\n\r\n                var" +
                    " name = GetTableName(type);\r\n\r\n                var sbColumnList = new StringBuil" +
                    "der(null);\r\n\r\n                var allProperties = TypePropertiesCache(type);\r\n  " +
                    "              var keyProperties = KeyPropertiesCache(type);\r\n                var" +
                    " allPropertiesExceptKey = allProperties.Except(keyProperties);\r\n\r\n              " +
                    "  for (var i = 0; i < allPropertiesExceptKey.Count(); i++)\r\n                {\r\n " +
                    "                   var property = allPropertiesExceptKey.ElementAt(i);\r\n        " +
                    "            sbColumnList.AppendFormat(\"[{0}]\", property.Name);\r\n                " +
                    "    if (i < allPropertiesExceptKey.Count() - 1)\r\n                        sbColum" +
                    "nList.Append(\", \");\r\n                }\r\n\r\n                var sbParameterList = " +
                    "new StringBuilder(null);\r\n                for (var i = 0; i < allPropertiesExcep" +
                    "tKey.Count(); i++)\r\n                {\r\n                    var property = allPro" +
                    "pertiesExceptKey.ElementAt(i);\r\n                    sbParameterList.AppendFormat" +
                    "(\"@{0}\", property.Name);\r\n                    if (i < allPropertiesExceptKey.Cou" +
                    "nt() - 1)\r\n                        sbParameterList.Append(\", \");\r\n              " +
                    "  }\r\n                ISqlAdapter adapter = GetFormatter(connection);\r\n          " +
                    "      int id = adapter.Insert(connection, transaction, commandTimeout, name, sbC" +
                    "olumnList.ToString(), sbParameterList.ToString(), keyProperties, entityToInsert)" +
                    ";\r\n                return id;\r\n            }\r\n\r\n            /// <summary>\r\n     " +
                    "       /// Updates entity in table \"Ts\", checks if the entity is modified if the" +
                    " entity is tracked by the Get() extension.\r\n            /// </summary>\r\n        " +
                    "    /// <typeparam name=\"T\">Type to be updated</typeparam>\r\n            /// <par" +
                    "am name=\"connection\">Open SqlConnection</param>\r\n            /// <param name=\"en" +
                    "tityToUpdate\">Entity to be updated</param>\r\n            /// <returns>true if upd" +
                    "ated, false if not found or not modified (tracked entities)</returns>\r\n         " +
                    "   public static bool Update<T>(this IDbConnection connection, T entityToUpdate," +
                    " IDbTransaction transaction = null, int? commandTimeout = null) where T : BaseMo" +
                    "del\r\n            {\r\n                if (entityToUpdate.DatabaseModelStatus != Mo" +
                    "delStatus.Retrieved)\r\n                    return false;\r\n\r\n                if (e" +
                    "ntityToUpdate.UpdatedProperties.Count < 1)\r\n                    return false;\r\n\r" +
                    "\n                var type = typeof(T);\r\n\r\n                var keyProperties = Ke" +
                    "yPropertiesCache(type).ToList();\r\n                if (!keyProperties.Any())\r\n   " +
                    "                 throw new ArgumentException(\"Entity must have at least one [Key" +
                    "] property\");\r\n\r\n                var name = GetTableName(type);\r\n\r\n             " +
                    "   var sb = new StringBuilder();\r\n                sb.AppendFormat(\"update [{0}] " +
                    "set \", name);\r\n\r\n                var allProperties = TypePropertiesCache(type);\r" +
                    "\n                var nonIdProps = allProperties.Where(a => !keyProperties.Contai" +
                    "ns(a) && entityToUpdate.UpdatedProperties.Contains(a.Name)).ToList(); // Only up" +
                    "dated properties\r\n\r\n\r\n                for (var i = 0; i < nonIdProps.Count(); i+" +
                    "+)\r\n                {\r\n                    var property = nonIdProps.ElementAt(i" +
                    ");\r\n                    sb.AppendFormat(\"[{0}] = @{1}\", property.Name, property." +
                    "Name);\r\n                    if (i < nonIdProps.Count() - 1)\r\n                   " +
                    "     sb.AppendFormat(\", \");\r\n                }\r\n\r\n                sb.Append(\" wh" +
                    "ere \");\r\n                for (var i = 0; i < keyProperties.Count(); i++)\r\n      " +
                    "          {\r\n                    var property = keyProperties.ElementAt(i);\r\n   " +
                    "                 sb.AppendFormat(\"[{0}] = @{1}\", property.Name, property.Name);\r" +
                    "\n                    if (i < keyProperties.Count() - 1)\r\n                       " +
                    " sb.AppendFormat(\" and \");\r\n                }\r\n                var updated = con" +
                    "nection.Execute(sb.ToString(), entityToUpdate, commandTimeout: commandTimeout, t" +
                    "ransaction: transaction);\r\n                return updated > 0;\r\n            }\r\n\r" +
                    "\n            /// <summary>\r\n            /// Delete entity in table \"Ts\".\r\n      " +
                    "      /// </summary>\r\n            /// <typeparam name=\"T\">Type of entity</typepa" +
                    "ram>\r\n            /// <param name=\"connection\">Open SqlConnection</param>\r\n     " +
                    "       /// <param name=\"entityToDelete\">Entity to delete</param>\r\n            //" +
                    "/ <returns>true if deleted, false if not found</returns>\r\n            public sta" +
                    "tic bool Delete<T>(this IDbConnection connection, T entityToDelete, IDbTransacti" +
                    "on transaction = null, int? commandTimeout = null) where T : BaseModel\r\n        " +
                    "    {\r\n              if (entityToDelete == null)\r\n                    throw new " +
                    "ArgumentException(\"Cannot Delete null Object\", \"entityToDelete\");\r\n\r\n           " +
                    "     var type = typeof(T);\r\n\r\n                var keyProperties = KeyPropertiesC" +
                    "ache(type).ToList();\r\n\r\n                if (!keyProperties.Any())\r\n             " +
                    "       throw new ArgumentException(\"Entity must have at least one [Key] property" +
                    "\");\r\n\r\n                var name = GetTableName(type);\r\n\r\n                var sb " +
                    "= new StringBuilder();\r\n                sb.AppendFormat(\"delete from {0} where \"" +
                    ", name);\r\n\r\n                for (var i = 0; i < keyProperties.Count(); i++)\r\n   " +
                    "             {\r\n                    var property = keyProperties.ElementAt(i);\r\n" +
                    "                    sb.AppendFormat(\"[{0}] = @{1}\", property.Name, property.Name" +
                    ");\r\n                    if (i < keyProperties.Count() - 1)\r\n                    " +
                    "    sb.AppendFormat(\" and \");\r\n                }\r\n                var deleted = " +
                    "connection.Execute(sb.ToString(), entityToDelete, transaction: transaction, comm" +
                    "andTimeout: commandTimeout) > 0;\r\n                if(deleted) { entityToDelete.D" +
                    "atabaseModelStatus = ModelStatus.Deleted; }\r\n                return deleted;\r\n  " +
                    "          }\r\n\r\n            public static ISqlAdapter GetFormatter(IDbConnection " +
                    "connection)\r\n            {\r\n                string name = connection.GetType().N" +
                    "ame.ToLower();\r\n                if (!AdapterDictionary.ContainsKey(name))\r\n     " +
                    "               return new SqlServerAdapter();\r\n                return AdapterDic" +
                    "tionary[name];\r\n            }\r\n\r\n            class ProxyGenerator\r\n            {" +
                    "\r\n                private static readonly Dictionary<Type, object> TypeCache = n" +
                    "ew Dictionary<Type, object>();\r\n\r\n                private static AssemblyBuilder" +
                    " GetAsmBuilder(string name)\r\n                {\r\n                    var assembly" +
                    "Builder = Thread.GetDomain().DefineDynamicAssembly(new AssemblyName { Name = nam" +
                    "e },\r\n                        AssemblyBuilderAccess.Run);       //NOTE: to save," +
                    " use RunAndSave\r\n\r\n                    return assemblyBuilder;\r\n                " +
                    "}\r\n\r\n                public static T GetClassProxy<T>()\r\n                {\r\n    " +
                    "                // A class proxy could be implemented if all properties are virt" +
                    "ual\r\n                    //  otherwise there is a pretty dangerous case where in" +
                    "ternal actions will not update dirty tracking\r\n                    throw new Not" +
                    "ImplementedException();\r\n                }\r\n\r\n\r\n                public static T " +
                    "GetInterfaceProxy<T>()\r\n                {\r\n                    Type typeOfT = ty" +
                    "peof(T);\r\n\r\n                    object k;\r\n                    if (TypeCache.Try" +
                    "GetValue(typeOfT, out k))\r\n                    {\r\n                        return" +
                    " (T)k;\r\n                    }\r\n                    var assemblyBuilder = GetAsmB" +
                    "uilder(typeOfT.Name);\r\n\r\n                    var moduleBuilder = assemblyBuilder" +
                    ".DefineDynamicModule(\"SqlMapperExtensions.\" + typeOfT.Name); //NOTE: to save, ad" +
                    "d \"asdasd.dll\" parameter\r\n\r\n                    var interfaceType = typeof(IProx" +
                    "y);\r\n                    var typeBuilder = moduleBuilder.DefineType(typeOfT.Name" +
                    " + \"_\" + Guid.NewGuid(),\r\n                        TypeAttributes.Public | TypeAt" +
                    "tributes.Class);\r\n                    typeBuilder.AddInterfaceImplementation(typ" +
                    "eOfT);\r\n                    typeBuilder.AddInterfaceImplementation(interfaceType" +
                    ");\r\n\r\n                    //create our _isDirty field, which implements IProxy\r\n" +
                    "                    var setIsDirtyMethod = CreateIsDirtyProperty(typeBuilder);\r\n" +
                    "\r\n                    // Generate a field for each property, which implements th" +
                    "e T\r\n                    foreach (var property in typeof(T).GetProperties())\r\n  " +
                    "                  {\r\n                        var isId = property.GetCustomAttrib" +
                    "utes(true).Any(a => a is KeyAttribute);\r\n                        CreateProperty<" +
                    "T>(typeBuilder, property.Name, property.PropertyType, setIsDirtyMethod, isId);\r\n" +
                    "                    }\r\n\r\n                    var generatedType = typeBuilder.Cre" +
                    "ateType();\r\n\r\n                    //assemblyBuilder.Save(name + \".dll\");  //NOTE" +
                    ": to save, uncomment\r\n\r\n                    var generatedObject = Activator.Crea" +
                    "teInstance(generatedType);\r\n\r\n                    TypeCache.Add(typeOfT, generat" +
                    "edObject);\r\n                    return (T)generatedObject;\r\n                }\r\n\r" +
                    "\n\r\n                private static MethodInfo CreateIsDirtyProperty(TypeBuilder t" +
                    "ypeBuilder)\r\n                {\r\n                    var propType = typeof(bool);" +
                    "\r\n                    var field = typeBuilder.DefineField(\"_\" + \"IsDirty\", propT" +
                    "ype, FieldAttributes.Private);\r\n                    var property = typeBuilder.D" +
                    "efineProperty(\"IsDirty\",\r\n                                                   Sys" +
                    "tem.Reflection.PropertyAttributes.None,\r\n                                       " +
                    "            propType,\r\n                                                   new Ty" +
                    "pe[] { propType });\r\n\r\n                    const MethodAttributes getSetAttr = M" +
                    "ethodAttributes.Public | MethodAttributes.NewSlot | MethodAttributes.SpecialName" +
                    " |\r\n                                                        MethodAttributes.Fin" +
                    "al | MethodAttributes.Virtual | MethodAttributes.HideBySig;\r\n\r\n                 " +
                    "   // Define the \"get\" and \"set\" accessor methods\r\n                    var currG" +
                    "etPropMthdBldr = typeBuilder.DefineMethod(\"get_\" + \"IsDirty\",\r\n                 " +
                    "                                getSetAttr,\r\n                                   " +
                    "              propType,\r\n                                                 Type.E" +
                    "mptyTypes);\r\n                    var currGetIL = currGetPropMthdBldr.GetILGenera" +
                    "tor();\r\n                    currGetIL.Emit(OpCodes.Ldarg_0);\r\n                  " +
                    "  currGetIL.Emit(OpCodes.Ldfld, field);\r\n                    currGetIL.Emit(OpCo" +
                    "des.Ret);\r\n                    var currSetPropMthdBldr = typeBuilder.DefineMetho" +
                    "d(\"set_\" + \"IsDirty\",\r\n                                                 getSetAt" +
                    "tr,\r\n                                                 null,\r\n                   " +
                    "                              new Type[] { propType });\r\n                    var" +
                    " currSetIL = currSetPropMthdBldr.GetILGenerator();\r\n                    currSetI" +
                    "L.Emit(OpCodes.Ldarg_0);\r\n                    currSetIL.Emit(OpCodes.Ldarg_1);\r\n" +
                    "                    currSetIL.Emit(OpCodes.Stfld, field);\r\n                    c" +
                    "urrSetIL.Emit(OpCodes.Ret);\r\n\r\n                    property.SetGetMethod(currGet" +
                    "PropMthdBldr);\r\n                    property.SetSetMethod(currSetPropMthdBldr);\r" +
                    "\n                    var getMethod = typeof(IProxy).GetMethod(\"get_\" + \"IsDirty\"" +
                    ");\r\n                    var setMethod = typeof(IProxy).GetMethod(\"set_\" + \"IsDir" +
                    "ty\");\r\n                    typeBuilder.DefineMethodOverride(currGetPropMthdBldr," +
                    " getMethod);\r\n                    typeBuilder.DefineMethodOverride(currSetPropMt" +
                    "hdBldr, setMethod);\r\n\r\n                    return currSetPropMthdBldr;\r\n        " +
                    "        }\r\n\r\n                private static void CreateProperty<T>(TypeBuilder t" +
                    "ypeBuilder, string propertyName, Type propType, MethodInfo setIsDirtyMethod, boo" +
                    "l isIdentity)\r\n                {\r\n                    //Define the field and the" +
                    " property \r\n                    var field = typeBuilder.DefineField(\"_\" + proper" +
                    "tyName, propType, FieldAttributes.Private);\r\n                    var property = " +
                    "typeBuilder.DefineProperty(propertyName,\r\n                                      " +
                    "             System.Reflection.PropertyAttributes.None,\r\n                       " +
                    "                            propType,\r\n                                         " +
                    "          new Type[] { propType });\r\n\r\n                    const MethodAttribute" +
                    "s getSetAttr = MethodAttributes.Public | MethodAttributes.Virtual |\r\n           " +
                    "                                             MethodAttributes.HideBySig;\r\n\r\n    " +
                    "                // Define the \"get\" and \"set\" accessor methods\r\n                " +
                    "    var currGetPropMthdBldr = typeBuilder.DefineMethod(\"get_\" + propertyName,\r\n " +
                    "                                                getSetAttr,\r\n                   " +
                    "                              propType,\r\n                                       " +
                    "          Type.EmptyTypes);\r\n\r\n                    var currGetIL = currGetPropMt" +
                    "hdBldr.GetILGenerator();\r\n                    currGetIL.Emit(OpCodes.Ldarg_0);\r\n" +
                    "                    currGetIL.Emit(OpCodes.Ldfld, field);\r\n                    c" +
                    "urrGetIL.Emit(OpCodes.Ret);\r\n\r\n                    var currSetPropMthdBldr = typ" +
                    "eBuilder.DefineMethod(\"set_\" + propertyName,\r\n                                  " +
                    "               getSetAttr,\r\n                                                 nul" +
                    "l,\r\n                                                 new Type[] { propType });\r\n" +
                    "\r\n                    //store value in private field and set the isdirty flag\r\n " +
                    "                   var currSetIL = currSetPropMthdBldr.GetILGenerator();\r\n      " +
                    "              currSetIL.Emit(OpCodes.Ldarg_0);\r\n                    currSetIL.Em" +
                    "it(OpCodes.Ldarg_1);\r\n                    currSetIL.Emit(OpCodes.Stfld, field);\r" +
                    "\n                    currSetIL.Emit(OpCodes.Ldarg_0);\r\n                    currS" +
                    "etIL.Emit(OpCodes.Ldc_I4_1);\r\n                    currSetIL.Emit(OpCodes.Call, s" +
                    "etIsDirtyMethod);\r\n                    currSetIL.Emit(OpCodes.Ret);\r\n\r\n         " +
                    "           //TODO: Should copy all attributes defined by the interface?\r\n       " +
                    "             if (isIdentity)\r\n                    {\r\n                        var" +
                    " keyAttribute = typeof(KeyAttribute);\r\n                        var myConstructor" +
                    "Info = keyAttribute.GetConstructor(new Type[] { });\r\n                        var" +
                    " attributeBuilder = new CustomAttributeBuilder(myConstructorInfo, new object[] {" +
                    " });\r\n                        property.SetCustomAttribute(attributeBuilder);\r\n  " +
                    "                  }\r\n\r\n                    property.SetGetMethod(currGetPropMthd" +
                    "Bldr);\r\n                    property.SetSetMethod(currSetPropMthdBldr);\r\n       " +
                    "             var getMethod = typeof(T).GetMethod(\"get_\" + propertyName);\r\n      " +
                    "              var setMethod = typeof(T).GetMethod(\"set_\" + propertyName);\r\n     " +
                    "               typeBuilder.DefineMethodOverride(currGetPropMthdBldr, getMethod);" +
                    "\r\n                    typeBuilder.DefineMethodOverride(currSetPropMthdBldr, setM" +
                    "ethod);\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        [AttributeUsag" +
                    "e(AttributeTargets.Class)]\r\n        public class TableAttribute : Attribute\r\n   " +
                    "     {\r\n            public TableAttribute(string tableName)\r\n            {\r\n    " +
                    "            Name = tableName;\r\n            }\r\n            public string Name { g" +
                    "et; private set; }\r\n        }\r\n\r\n        // do not want to depend on data annota" +
                    "tions that is not in client profile\r\n        [AttributeUsage(AttributeTargets.Pr" +
                    "operty)]\r\n        public class KeyAttribute : Attribute\r\n        {\r\n        }\r\n\r" +
                    "\n        [AttributeUsage(AttributeTargets.Property)]\r\n        public class Write" +
                    "Attribute : Attribute\r\n        {\r\n            public WriteAttribute(bool write)\r" +
                    "\n            {\r\n                Write = write;\r\n            }\r\n            publi" +
                    "c bool Write { get; private set; }\r\n        }\r\n\r\n        public interface ISqlAd" +
                    "apter\r\n        {\r\n            int Insert(IDbConnection connection, IDbTransactio" +
                    "n transaction, int? commandTimeout, String tableName, string columnList, string " +
                    "parameterList, IEnumerable<PropertyInfo> keyProperties, object entityToInsert);\r" +
                    "\n        }\r\n\r\n        public class SqlServerAdapter : ISqlAdapter\r\n        {\r\n  " +
                    "          public int Insert(IDbConnection connection, IDbTransaction transaction" +
                    ", int? commandTimeout, String tableName, string columnList, string parameterList" +
                    ", IEnumerable<PropertyInfo> keyProperties, object entityToInsert)\r\n            {" +
                    "\r\n                string cmd = String.Format(\"insert into {0} ({1}) values ({2})" +
                    "\", tableName, columnList, parameterList);\r\n\r\n                connection.Execute(" +
                    "cmd, entityToInsert, transaction: transaction, commandTimeout: commandTimeout);\r" +
                    "\n\r\n                //NOTE: would prefer to use IDENT_CURRENT(\'tablename\') or IDE" +
                    "NT_SCOPE but these are not available on SQLCE\r\n                var r = connectio" +
                    "n.Query(\"select @@IDENTITY id\", transaction: transaction, commandTimeout: comman" +
                    "dTimeout);\r\n                int id = (int)r.First().id;\r\n                if (key" +
                    "Properties.Any())\r\n                    keyProperties.First().SetValue(entityToIn" +
                    "sert, id, null);\r\n                return id;\r\n            }\r\n        }\r\n\r\n      " +
                    "  public class PostgresAdapter : ISqlAdapter\r\n        {\r\n            public int " +
                    "Insert(IDbConnection connection, IDbTransaction transaction, int? commandTimeout" +
                    ", String tableName, string columnList, string parameterList, IEnumerable<Propert" +
                    "yInfo> keyProperties, object entityToInsert)\r\n            {\r\n                Str" +
                    "ingBuilder sb = new StringBuilder();\r\n                sb.AppendFormat(\"insert in" +
                    "to {0} ({1}) values ({2})\", tableName, columnList, parameterList);\r\n\r\n          " +
                    "      // If no primary key then safe to assume a join table with not too much da" +
                    "ta to return\r\n                if (!keyProperties.Any())\r\n                    sb." +
                    "Append(\" RETURNING *\");\r\n                else\r\n                {\r\n              " +
                    "      sb.Append(\" RETURNING \");\r\n                    bool first = true;\r\n       " +
                    "             foreach (var property in keyProperties)\r\n                    {\r\n   " +
                    "                     if (!first)\r\n                            sb.Append(\", \");\r\n" +
                    "                        first = false;\r\n                        sb.Append(proper" +
                    "ty.Name);\r\n                    }\r\n                }\r\n\r\n                var resul" +
                    "ts = connection.Query(sb.ToString(), entityToInsert, transaction: transaction, c" +
                    "ommandTimeout: commandTimeout);\r\n\r\n                // Return the key by assingin" +
                    "g the corresponding property in the object - by product is that it supports comp" +
                    "ound primary keys\r\n                int id = 0;\r\n                foreach (var p i" +
                    "n keyProperties)\r\n                {\r\n                    var value = ((IDictiona" +
                    "ry<string, object>)results.First())[p.Name.ToLower()];\r\n                    p.Se" +
                    "tValue(entityToInsert, value, null);\r\n                    if (id == 0)\r\n        " +
                    "                id = Convert.ToInt32(value);\r\n                }\r\n               " +
                    " return id;\r\n            }\r\n        }\r\n    }\r\n");
            return this.GenerationEnvironment.ToString();
        }
    }
    
    #line default
    #line hidden
    #region Base class
    /// <summary>
    /// Base class for this transformation
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "14.0.0.0")]
    public class DapperBase
    {
        #region Fields
        private global::System.Text.StringBuilder generationEnvironmentField;
        private global::System.CodeDom.Compiler.CompilerErrorCollection errorsField;
        private global::System.Collections.Generic.List<int> indentLengthsField;
        private string currentIndentField = "";
        private bool endsWithNewline;
        private global::System.Collections.Generic.IDictionary<string, object> sessionField;
        #endregion
        #region Properties
        /// <summary>
        /// The string builder that generation-time code is using to assemble generated output
        /// </summary>
        protected System.Text.StringBuilder GenerationEnvironment
        {
            get
            {
                if ((this.generationEnvironmentField == null))
                {
                    this.generationEnvironmentField = new global::System.Text.StringBuilder();
                }
                return this.generationEnvironmentField;
            }
            set
            {
                this.generationEnvironmentField = value;
            }
        }
        /// <summary>
        /// The error collection for the generation process
        /// </summary>
        public System.CodeDom.Compiler.CompilerErrorCollection Errors
        {
            get
            {
                if ((this.errorsField == null))
                {
                    this.errorsField = new global::System.CodeDom.Compiler.CompilerErrorCollection();
                }
                return this.errorsField;
            }
        }
        /// <summary>
        /// A list of the lengths of each indent that was added with PushIndent
        /// </summary>
        private System.Collections.Generic.List<int> indentLengths
        {
            get
            {
                if ((this.indentLengthsField == null))
                {
                    this.indentLengthsField = new global::System.Collections.Generic.List<int>();
                }
                return this.indentLengthsField;
            }
        }
        /// <summary>
        /// Gets the current indent we use when adding lines to the output
        /// </summary>
        public string CurrentIndent
        {
            get
            {
                return this.currentIndentField;
            }
        }
        /// <summary>
        /// Current transformation session
        /// </summary>
        public virtual global::System.Collections.Generic.IDictionary<string, object> Session
        {
            get
            {
                return this.sessionField;
            }
            set
            {
                this.sessionField = value;
            }
        }
        #endregion
        #region Transform-time helpers
        /// <summary>
        /// Write text directly into the generated output
        /// </summary>
        public void Write(string textToAppend)
        {
            if (string.IsNullOrEmpty(textToAppend))
            {
                return;
            }
            // If we're starting off, or if the previous text ended with a newline,
            // we have to append the current indent first.
            if (((this.GenerationEnvironment.Length == 0) 
                        || this.endsWithNewline))
            {
                this.GenerationEnvironment.Append(this.currentIndentField);
                this.endsWithNewline = false;
            }
            // Check if the current text ends with a newline
            if (textToAppend.EndsWith(global::System.Environment.NewLine, global::System.StringComparison.CurrentCulture))
            {
                this.endsWithNewline = true;
            }
            // This is an optimization. If the current indent is "", then we don't have to do any
            // of the more complex stuff further down.
            if ((this.currentIndentField.Length == 0))
            {
                this.GenerationEnvironment.Append(textToAppend);
                return;
            }
            // Everywhere there is a newline in the text, add an indent after it
            textToAppend = textToAppend.Replace(global::System.Environment.NewLine, (global::System.Environment.NewLine + this.currentIndentField));
            // If the text ends with a newline, then we should strip off the indent added at the very end
            // because the appropriate indent will be added when the next time Write() is called
            if (this.endsWithNewline)
            {
                this.GenerationEnvironment.Append(textToAppend, 0, (textToAppend.Length - this.currentIndentField.Length));
            }
            else
            {
                this.GenerationEnvironment.Append(textToAppend);
            }
        }
        /// <summary>
        /// Write text directly into the generated output
        /// </summary>
        public void WriteLine(string textToAppend)
        {
            this.Write(textToAppend);
            this.GenerationEnvironment.AppendLine();
            this.endsWithNewline = true;
        }
        /// <summary>
        /// Write formatted text directly into the generated output
        /// </summary>
        public void Write(string format, params object[] args)
        {
            this.Write(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
        }
        /// <summary>
        /// Write formatted text directly into the generated output
        /// </summary>
        public void WriteLine(string format, params object[] args)
        {
            this.WriteLine(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
        }
        /// <summary>
        /// Raise an error
        /// </summary>
        public void Error(string message)
        {
            System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
            error.ErrorText = message;
            this.Errors.Add(error);
        }
        /// <summary>
        /// Raise a warning
        /// </summary>
        public void Warning(string message)
        {
            System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
            error.ErrorText = message;
            error.IsWarning = true;
            this.Errors.Add(error);
        }
        /// <summary>
        /// Increase the indent
        /// </summary>
        public void PushIndent(string indent)
        {
            if ((indent == null))
            {
                throw new global::System.ArgumentNullException("indent");
            }
            this.currentIndentField = (this.currentIndentField + indent);
            this.indentLengths.Add(indent.Length);
        }
        /// <summary>
        /// Remove the last indent that was added with PushIndent
        /// </summary>
        public string PopIndent()
        {
            string returnValue = "";
            if ((this.indentLengths.Count > 0))
            {
                int indentLength = this.indentLengths[(this.indentLengths.Count - 1)];
                this.indentLengths.RemoveAt((this.indentLengths.Count - 1));
                if ((indentLength > 0))
                {
                    returnValue = this.currentIndentField.Substring((this.currentIndentField.Length - indentLength));
                    this.currentIndentField = this.currentIndentField.Remove((this.currentIndentField.Length - indentLength));
                }
            }
            return returnValue;
        }
        /// <summary>
        /// Remove any indentation
        /// </summary>
        public void ClearIndent()
        {
            this.indentLengths.Clear();
            this.currentIndentField = "";
        }
        #endregion
        #region ToString Helpers
        /// <summary>
        /// Utility class to produce culture-oriented representation of an object as a string.
        /// </summary>
        public class ToStringInstanceHelper
        {
            private System.IFormatProvider formatProviderField  = global::System.Globalization.CultureInfo.InvariantCulture;
            /// <summary>
            /// Gets or sets format provider to be used by ToStringWithCulture method.
            /// </summary>
            public System.IFormatProvider FormatProvider
            {
                get
                {
                    return this.formatProviderField ;
                }
                set
                {
                    if ((value != null))
                    {
                        this.formatProviderField  = value;
                    }
                }
            }
            /// <summary>
            /// This is called from the compile/run appdomain to convert objects within an expression block to a string
            /// </summary>
            public string ToStringWithCulture(object objectToConvert)
            {
                if ((objectToConvert == null))
                {
                    throw new global::System.ArgumentNullException("objectToConvert");
                }
                System.Type t = objectToConvert.GetType();
                System.Reflection.MethodInfo method = t.GetMethod("ToString", new System.Type[] {
                            typeof(System.IFormatProvider)});
                if ((method == null))
                {
                    return objectToConvert.ToString();
                }
                else
                {
                    return ((string)(method.Invoke(objectToConvert, new object[] {
                                this.formatProviderField })));
                }
            }
        }
        private ToStringInstanceHelper toStringHelperField = new ToStringInstanceHelper();
        /// <summary>
        /// Helper to produce culture-oriented representation of an object as a string
        /// </summary>
        public ToStringInstanceHelper ToStringHelper
        {
            get
            {
                return this.toStringHelperField;
            }
        }
        #endregion
    }
    #endregion
}
