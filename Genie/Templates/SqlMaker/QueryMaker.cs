// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 14.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace Genie.Templates.SqlMaker
{
    using Genie.Base;
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    
    #line 1 "F:\Projects\Genie\Genie\Templates\SqlMaker\QueryMaker.tt"
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "14.0.0.0")]
    public partial class QueryMaker : QueryMakerBase
    {
#line hidden
        /// <summary>
        /// Create the template output
        /// </summary>
        public virtual string TransformText()
        {
            this.Write("namespace ");
            
            #line 3 "F:\Projects\Genie\Genie\Templates\SqlMaker\QueryMaker.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(GenerationContext.BaseNamespace));
            
            #line default
            #line hidden
            this.Write(".SqlMaker\r\n{\r\n    public class QueryMaker : ISqlMaker\r\n    {\r\n        private enu" +
                    "m ClauseType\r\n        {\r\n            ActionInsert,\r\n            ActionInsertValu" +
                    "es,\r\n            ActionUpdate,\r\n            ActionUpdateSet,\r\n            Action" +
                    "UpdateValues,\r\n            ActionUpdateWhere,\r\n            ActionSelect,\r\n      " +
                    "      ActionSelectWhereOnHaving,\r\n            ActionSelectJoin,\r\n            Act" +
                    "ionSelectOrder,\r\n            ActionSelectGroup,\r\n            ActionDelete,\r\n    " +
                    "        ActionDeleteWhere,\r\n            Table,\r\n            Column,\r\n           " +
                    " Parameter,\r\n        }\r\n\r\n        private static string br = \"\\n\";\r\n        priv" +
                    "ate static string brIndent = \"\\n\\t\";\r\n        private static string brIndentX2 =" +
                    " \"\\n\\t\\t\";\r\n\r\n        private static string _dbScheme;\r\n\r\n        public static " +
                    "string DbScheme { get { return _dbScheme; } set { _dbScheme = value; } }\r\n\r\n    " +
                    "    private static List<Clause> _clauses;\r\n        private static List<Clause> C" +
                    "lauses\r\n        {\r\n            get { return _clauses ?? (_clauses = new List<Cla" +
                    "use>()); }\r\n        }\r\n\r\n        private class Clause\r\n        {\r\n            pu" +
                    "blic static Clause New(ClauseType type, string sqlPart = null, string name = nul" +
                    "l, string aliace = null,\r\n                                        string conditi" +
                    "on = null, string direction = null, string extra = null)\r\n            {\r\n       " +
                    "         return new Clause\r\n                {\r\n                    ClauseType = " +
                    "type,\r\n                    SqlPart = sqlPart,\r\n                    Name = name,\r" +
                    "\n                    Aliace = aliace,\r\n                    Condition = condition" +
                    ",\r\n                    Direction = direction,\r\n                    Extra = extra" +
                    "\r\n                };\r\n            }\r\n\r\n            public ClauseType ClauseType " +
                    "{ get; private set; }\r\n            public string SqlPart { get; private set; }\r\n" +
                    "            public string Name { get; private set; }\r\n            public string " +
                    "Aliace { get; private set; }\r\n            public string Condition { get; private" +
                    " set; }\r\n            public string Direction { get; private set; }\r\n            " +
                    "public string Extra { get; private set; }\r\n        }\r\n\r\n        private static I" +
                    "SqlMaker _sqlMaker;\r\n\r\n        public static ISqlMaker Current\r\n        {\r\n     " +
                    "       get { return _sqlMaker ?? (_sqlMaker = new QueryMaker()); }\r\n        }\r\n " +
                    "       public static ISqlFirst New(string dbScheme = null)\r\n        {\r\n         " +
                    "   if (!string.IsNullOrEmpty(dbScheme))\r\n            {\r\n                _dbSchem" +
                    "e = dbScheme;\r\n            }\r\n            Clauses.Clear();\r\n            _sqlMake" +
                    "r = new QueryMaker();\r\n            return _sqlMaker;\r\n        }\r\n\r\n        #regi" +
                    "on Common Method\r\n        private static string FormatScheme(string globalScheme" +
                    ", string currentScheme = null)\r\n        {\r\n            if (!string.IsNullOrEmpty" +
                    "(currentScheme))\r\n            {\r\n                return string.Format(\"[{0}].\", " +
                    "currentScheme.Trim());\r\n            }\r\n            if (!string.IsNullOrEmpty(glo" +
                    "balScheme))\r\n            {\r\n                return string.Format(\"[{0}].\", globa" +
                    "lScheme.Trim());\r\n            }\r\n            return string.Empty;\r\n        }\r\n  " +
                    "      private static string FormatAliace(string aliace)\r\n        {\r\n            " +
                    "if (!string.IsNullOrEmpty(aliace))\r\n            {\r\n                return string" +
                    ".Format(\" AS {0}\", aliace.Trim());\r\n            }\r\n            return string.Emp" +
                    "ty;\r\n        }\r\n        private static string FormatTableNameWithShema(string sc" +
                    "heme, string tableName)\r\n        {\r\n            return string.Format(\"{0}[{1}]\"," +
                    " scheme, tableName.Trim());\r\n        }\r\n        private static string ResolveStr" +
                    "ingToRows(string extra, string indent)\r\n        {\r\n            var sb = new Stri" +
                    "ngBuilder();\r\n            var delimiters = new char[] { \',\', \';\' };\r\n           " +
                    " var array = extra.Split(delimiters);\r\n            var firstParam = true;\r\n     " +
                    "       foreach (var s in array)\r\n            {\r\n                if (firstParam)\r" +
                    "\n                {\r\n                    sb.Append(indent + s.Trim());\r\n         " +
                    "           firstParam = false;\r\n                }\r\n                else\r\n       " +
                    "         {\r\n                    sb.Append(indent + \", \" + s.Trim());\r\n          " +
                    "      }\r\n            }\r\n            return sb.ToString();\r\n        }\r\n        pr" +
                    "ivate static string FormatParameter(string paramName)\r\n        {\r\n            re" +
                    "turn paramName.Contains(\"@\") ? paramName.Trim() : \"@\" + paramName.Trim();\r\n     " +
                    "   }\r\n        #endregion\r\n\r\n        #region Resolve Sql Query\r\n        private s" +
                    "tatic string ResolveInsert(IEnumerable<Clause> list, string dbScheme)\r\n        {" +
                    "\r\n            var sb = new StringBuilder();\r\n            var sqlScheme = FormatS" +
                    "cheme(dbScheme);\r\n            var isFirstCol = true;\r\n            var lastBkt = " +
                    "false;\r\n            var insertedParams = false;\r\n            var colCount = list" +
                    ".Count(i => i.ClauseType == ClauseType.Column);\r\n            var count = 0;\r\n   " +
                    "         foreach (var clause in list)\r\n            {\r\n                switch (cl" +
                    "ause.ClauseType)\r\n                {\r\n                    case ClauseType.ActionI" +
                    "nsert:\r\n                        sb.Append(clause.SqlPart);\r\n                    " +
                    "    sb.Append(\" \");\r\n                        sb.Append(FormatTableNameWithShema(" +
                    "sqlScheme, clause.Name));\r\n                        break;\r\n                    c" +
                    "ase ClauseType.Column:\r\n                        count += 1;\r\n                   " +
                    "     if (isFirstCol)\r\n                        {\r\n                            sb." +
                    "Append(\" (\");\r\n                        }\r\n                        if (isFirstCol" +
                    ")\r\n                        {\r\n                            sb.Append(brIndentX2 +" +
                    " \"[\" + clause.Name + \"]\");\r\n                            isFirstCol = false;\r\n   " +
                    "                     }\r\n                        else\r\n                        {\r" +
                    "\n                            sb.Append(brIndentX2 + \", [\" + clause.Name + \"]\");\r" +
                    "\n                        }\r\n                        if (count == colCount)\r\n    " +
                    "                    {\r\n                            sb.Append(brIndent + \")\");\r\n " +
                    "                       }\r\n                        break;\r\n                    ca" +
                    "se ClauseType.ActionInsertValues:\r\n                        lastBkt = true;\r\n    " +
                    "                    sb.Append(brIndent);\r\n                        sb.Append(clau" +
                    "se.SqlPart);\r\n                        sb.Append(\" (\");\r\n                        " +
                    "if (!string.IsNullOrEmpty(clause.Extra))\r\n                        {\r\n           " +
                    "                 insertedParams = true;\r\n                            sb.Append(R" +
                    "esolveStringToRows(clause.Extra, brIndentX2));\r\n                        }\r\n     " +
                    "                   break;\r\n                    case ClauseType.Parameter:\r\n     " +
                    "                   var paramName = FormatParameter(clause.Name);\r\n              " +
                    "          if (!insertedParams)\r\n                        {\r\n                     " +
                    "       insertedParams = true;\r\n                            sb.Append(brIndentX2 " +
                    "+ paramName);\r\n                        }\r\n                        else\r\n        " +
                    "                {\r\n                            sb.Append(brIndentX2 + \", \" + par" +
                    "amName);\r\n                        }\r\n                        break;\r\n           " +
                    "         default:\r\n                        throw new ArgumentOutOfRangeException" +
                    "(\"Wrong clause type in Insert resolving method\");\r\n                }\r\n          " +
                    "  }\r\n            if (lastBkt)\r\n            {\r\n                sb.Append(brIndent" +
                    " + \");\");\r\n            }\r\n            return sb.ToString();\r\n        }\r\n\r\n      " +
                    "  private static string ResolveUpdate(List<Clause> list, string dbScheme)\r\n     " +
                    "   {\r\n            var sb = new StringBuilder();\r\n            var sqlScheme = For" +
                    "matScheme(dbScheme);\r\n            var isSetParam = false;\r\n            foreach (" +
                    "var clause in list)\r\n            {\r\n                switch (clause.ClauseType)\r\n" +
                    "                {\r\n                    case ClauseType.ActionUpdate:\r\n          " +
                    "              sb.Append(clause.SqlPart);\r\n                        sb.Append(\" \")" +
                    ";\r\n                        sb.Append(FormatTableNameWithShema(sqlScheme, clause." +
                    "Name));\r\n                        break;\r\n                    case ClauseType.Act" +
                    "ionUpdateSet:\r\n                        sb.Append(br);\r\n                        s" +
                    "b.Append(clause.SqlPart);\r\n                        if (!string.IsNullOrEmpty(cla" +
                    "use.Extra))\r\n                        {\r\n                            isSetParam =" +
                    " true;\r\n                            sb.Append(ResolveStringToRows(clause.Extra, " +
                    "brIndent));\r\n                        }\r\n                        break;\r\n        " +
                    "            case ClauseType.ActionUpdateValues:\r\n                        if (!is" +
                    "SetParam)\r\n                        {\r\n                            isSetParam = t" +
                    "rue;\r\n                            sb.Append(brIndent + clause.Name.Trim());\r\n   " +
                    "                         sb.Append(\" = \");\r\n                            sb.Appen" +
                    "d(FormatParameter(clause.Aliace));\r\n                        }\r\n                 " +
                    "       else\r\n                        {\r\n                            sb.Append(br" +
                    "Indent + \", \" + clause.Name.Trim());\r\n                            sb.Append(\" = " +
                    "\");\r\n                            sb.Append(FormatParameter(clause.Aliace));\r\n   " +
                    "                     }\r\n                        break;\r\n                    case" +
                    " ClauseType.ActionUpdateWhere:\r\n                        sb.Append(clause.SqlPart" +
                    ");\r\n                        sb.Append(clause.Condition.Trim());\r\n               " +
                    "         break;\r\n                    default:\r\n                        throw new" +
                    " ArgumentOutOfRangeException();\r\n                }\r\n            }\r\n            s" +
                    "b.Append(\";\");\r\n            return sb.ToString();\r\n        }\r\n\r\n        private " +
                    "static string ResolveSelect(List<Clause> list, string dbScheme)\r\n        {\r\n    " +
                    "        var sb = new StringBuilder();\r\n            bool isFirst = true;\r\n       " +
                    "     foreach (var clause in list)\r\n            {\r\n                switch (clause" +
                    ".ClauseType)\r\n                {\r\n                    case ClauseType.ActionSelec" +
                    "t:\r\n                        isFirst = true; // SELECT or UNION\r\n                " +
                    "        sb.Append(clause.SqlPart);\r\n                        if (!string.IsNullOr" +
                    "Empty(clause.Extra))\r\n                        {\r\n                            isF" +
                    "irst = false;\r\n                            sb.Append(ResolveStringToRows(clause." +
                    "Extra, brIndent));\r\n                        }\r\n                        break;\r\n " +
                    "                   case ClauseType.ActionSelectWhereOnHaving:\r\n                 " +
                    "       sb.Append(clause.SqlPart);\r\n                        sb.Append(clause.Cond" +
                    "ition.Trim());\r\n                        break;\r\n                    case ClauseT" +
                    "ype.ActionSelectJoin:\r\n                        var schemeJoin = FormatScheme(dbS" +
                    "cheme, clause.Extra);\r\n                        var tabNameJoin = FormatTableName" +
                    "WithShema(schemeJoin, clause.Name);\r\n                        var tabAliaceJoin =" +
                    " FormatAliace(clause.Aliace);\r\n                        sb.Append(clause.SqlPart)" +
                    ";\r\n                        sb.Append(tabNameJoin + tabAliaceJoin);\r\n            " +
                    "            break;\r\n                    case ClauseType.ActionSelectOrder:\r\n    " +
                    "                    sb.Append(clause.SqlPart);\r\n                        sb.Appen" +
                    "d(clause.Name.Trim());\r\n                        sb.Append(\" \");\r\n               " +
                    "         sb.Append(clause.Direction);\r\n                        break;\r\n         " +
                    "           case ClauseType.ActionSelectGroup:\r\n                        sb.Append" +
                    "(clause.SqlPart);\r\n                        sb.Append(clause.Name.Trim());\r\n     " +
                    "                   break;\r\n                    case ClauseType.Table:\r\n         " +
                    "               var scheme = FormatScheme(dbScheme, clause.Extra);\r\n             " +
                    "           var tabName = FormatTableNameWithShema(scheme, clause.Name);\r\n       " +
                    "                 var tabAliace = FormatAliace(clause.Aliace);\r\n                 " +
                    "       if (isFirst)\r\n                        {\r\n                            isFi" +
                    "rst = false;\r\n                            sb.Append(brIndent + tabName + tabAlia" +
                    "ce);\r\n                        }\r\n                        else\r\n                 " +
                    "       {\r\n                            sb.Append(brIndent + \", \" + tabName + tabA" +
                    "liace);\r\n                        }\r\n                        break;\r\n            " +
                    "        case ClauseType.Column:\r\n                        var aliace = string.IsN" +
                    "ullOrEmpty(clause.Aliace) ? string.Empty : \" AS \" + clause.Aliace.Trim();\r\n     " +
                    "                   if (isFirst)\r\n                        {\r\n                    " +
                    "        isFirst = false;\r\n                            sb.Append(brIndent + claus" +
                    "e.Name.Trim() + aliace);\r\n                        }\r\n                        els" +
                    "e\r\n                        {\r\n                            sb.Append(brIndent + \"" +
                    ", \" + clause.Name.Trim() + aliace);\r\n                        }\r\n                " +
                    "        break;\r\n                    default:\r\n                        throw new " +
                    "ArgumentOutOfRangeException();\r\n                }\r\n            }\r\n            sb" +
                    ".Append(\";\");\r\n            return sb.ToString();\r\n        }\r\n\r\n        private s" +
                    "tatic string ResolveDelete(List<Clause> list, string dbScheme)\r\n        {\r\n     " +
                    "       var sb = new StringBuilder();\r\n            var sqlScheme = FormatScheme(d" +
                    "bScheme);\r\n            foreach (var clause in list)\r\n            {\r\n            " +
                    "    switch (clause.ClauseType)\r\n                {\r\n                    case Clau" +
                    "seType.ActionDelete:\r\n                        sb.Append(clause.SqlPart);\r\n      " +
                    "                  sb.Append(\" \");\r\n                        sb.Append(FormatTable" +
                    "NameWithShema(sqlScheme, clause.Name));\r\n                        break;\r\n       " +
                    "             case ClauseType.ActionDeleteWhere:\r\n                        sb.Appe" +
                    "nd(clause.SqlPart);\r\n                        sb.Append(clause.Condition.Trim());" +
                    "\r\n                        break;\r\n                    default:\r\n                " +
                    "        throw new ArgumentOutOfRangeException();\r\n                }\r\n           " +
                    " }\r\n            sb.Append(\";\");\r\n            return sb.ToString();\r\n        }\r\n " +
                    "       #endregion Resolve Sql Query\r\n\r\n        public virtual string RawSql()\r\n " +
                    "       {\r\n            string sqlResult = null;\r\n            if (Clauses.Count ==" +
                    " 0)\r\n            {\r\n                throw new Exception(\"Empty query\");\r\n       " +
                    "     }\r\n            var first = Clauses.First();\r\n            switch (first.Clau" +
                    "seType)\r\n            {\r\n                case ClauseType.ActionInsert:\r\n         " +
                    "           sqlResult = ResolveInsert(Clauses, _dbScheme);\r\n                    b" +
                    "reak;\r\n                case ClauseType.ActionUpdate:\r\n                    sqlRes" +
                    "ult = ResolveUpdate(Clauses, _dbScheme);\r\n                    break;\r\n          " +
                    "      case ClauseType.ActionSelect:\r\n                    sqlResult = ResolveSele" +
                    "ct(Clauses, _dbScheme);\r\n                    break;\r\n                case Clause" +
                    "Type.ActionDelete:\r\n                    sqlResult = ResolveDelete(Clauses, _dbSc" +
                    "heme);\r\n                    break;\r\n                default:\r\n                  " +
                    "  throw new Exception(\"Wrong start of query\");\r\n            }\r\n            retur" +
                    "n sqlResult;\r\n        }\r\n\r\n        #region SELECT\r\n        public virtual ISqlMa" +
                    "kerSelect SELECT(string columns = null)\r\n        {\r\n            Clauses.Add(Clau" +
                    "se.New(ClauseType.ActionSelect, \"SELECT\", extra: columns));\r\n            return " +
                    "this;\r\n        }\r\n\r\n        public virtual ISqlMakerSelect SelectDistinct(string" +
                    " columns = null)\r\n        {\r\n            Clauses.Add(Clause.New(ClauseType.Actio" +
                    "nSelect, \"SELECT DISTINCT\", extra: columns));\r\n            return this;\r\n       " +
                    " }\r\n\r\n        public virtual ISqlMakerSelect Union(bool isAll = false)\r\n        " +
                    "{\r\n            var sqlPart = br + \"UNION\" + (isAll ? \" ALL\" : string.Empty) + br" +
                    " + \"SELECT\";\r\n            Clauses.Add(Clause.New(ClauseType.ActionSelect, sqlPar" +
                    "t));\r\n            return this;\r\n        }\r\n\r\n        public virtual ISqlMakerSel" +
                    "ect Col(string columnName, string columnAliace = null)\r\n        {\r\n            C" +
                    "lauses.Add(Clause.New(ClauseType.Column, name: columnName, aliace: columnAliace)" +
                    ");\r\n            return this;\r\n        }\r\n\r\n        public virtual ISqlMakerSelec" +
                    "t From(string tables = null)\r\n        {\r\n            Clauses.Add(Clause.New(Clau" +
                    "seType.ActionSelect, br + \"FROM\", extra: tables));\r\n            return this;\r\n  " +
                    "      }\r\n\r\n        public virtual ISqlMakerSelect Tab(string tableName, string t" +
                    "ableAliace = null, string tableScheme = null)\r\n        {\r\n            Clauses.Ad" +
                    "d(Clause.New(ClauseType.Table, name: tableName, aliace: tableAliace, extra: tabl" +
                    "eScheme));\r\n            return this;\r\n        }\r\n\r\n        ISqlMakerSelect ISqlM" +
                    "akerSelect.Where(string whereConditions)\r\n        {\r\n            Clauses.Add(Cla" +
                    "use.New(ClauseType.ActionSelectWhereOnHaving, br + \"WHERE\" + brIndent, condition" +
                    ": whereConditions));\r\n            return this;\r\n        }\r\n\r\n        ISqlMakerSe" +
                    "lect ISqlMakerSelect.WhereAnd(string whereConditions)\r\n        {\r\n            Cl" +
                    "auses.Add(Clause.New(ClauseType.ActionSelectWhereOnHaving, brIndent + \"AND \", co" +
                    "ndition: whereConditions));\r\n            return this;\r\n        }\r\n\r\n        ISql" +
                    "MakerSelect ISqlMakerSelect.WhereOr(string whereConditions)\r\n        {\r\n        " +
                    "    Clauses.Add(Clause.New(ClauseType.ActionSelectWhereOnHaving, brIndent + \"OR " +
                    "\", condition: whereConditions));\r\n            return this;\r\n        }\r\n\r\n       " +
                    " public virtual ISqlMakerSelect Join(string tableName, string tableAliace = null" +
                    ")\r\n        {\r\n            Clauses.Add(Clause.New(ClauseType.ActionSelectJoin, br" +
                    " + \"INNER JOIN \", name: tableName, aliace: tableAliace));\r\n            return th" +
                    "is;\r\n        }\r\n\r\n        public virtual ISqlMakerSelect LeftJoin(string tableNa" +
                    "me, string tableAliace = null)\r\n        {\r\n            Clauses.Add(Clause.New(Cl" +
                    "auseType.ActionSelectJoin, br + \"LEFT JOIN \", name: tableName, aliace: tableAlia" +
                    "ce));\r\n            return this;\r\n        }\r\n\r\n        public virtual ISqlMakerSe" +
                    "lect RightJoin(string tableName, string tableAliace = null)\r\n        {\r\n        " +
                    "    Clauses.Add(Clause.New(ClauseType.ActionSelectJoin, br + \"RIGHT JOIN \", name" +
                    ": tableName, aliace: tableAliace));\r\n            return this;\r\n        }\r\n\r\n    " +
                    "    public virtual ISqlMakerSelect FullJoin(string tableName, string tableAliace" +
                    " = null)\r\n        {\r\n            Clauses.Add(Clause.New(ClauseType.ActionSelectJ" +
                    "oin, br + \"FULL JOIN \", name: tableName, aliace: tableAliace));\r\n            ret" +
                    "urn this;\r\n        }\r\n\r\n        public virtual ISqlMakerSelect On(string conditi" +
                    "on)\r\n        {\r\n            Clauses.Add(Clause.New(ClauseType.ActionSelectWhereO" +
                    "nHaving, brIndent + \"ON \", condition: condition));\r\n            return this;\r\n  " +
                    "      }\r\n\r\n        public virtual ISqlMakerSelect OnAnd(string condition)\r\n     " +
                    "   {\r\n            Clauses.Add(Clause.New(ClauseType.ActionSelectWhereOnHaving, b" +
                    "rIndent + \"AND \", condition: condition));\r\n            return this;\r\n        }\r\n" +
                    "\r\n        public virtual ISqlMakerSelect OnOr(string condition)\r\n        {\r\n    " +
                    "        Clauses.Add(Clause.New(ClauseType.ActionSelectWhereOnHaving, brIndent + " +
                    "\"OR \", condition: condition));\r\n            return this;\r\n        }\r\n\r\n        p" +
                    "ublic virtual ISqlMakerSelect OrderBy(string columnName, SortAs direction)\r\n    " +
                    "    {\r\n            Clauses.Add(Clause.New(ClauseType.ActionSelectOrder, br + \"OR" +
                    "DER BY \", name: columnName, direction: direction.ToString().ToUpperInvariant()))" +
                    ";\r\n            return this;\r\n        }\r\n\r\n        public virtual ISqlMakerSelect" +
                    " OrderThen(string columnName, SortAs direction)\r\n        {\r\n            Clauses." +
                    "Add(Clause.New(ClauseType.ActionSelectOrder, \", \", name: columnName, direction: " +
                    "direction.ToString().ToUpperInvariant()));\r\n            return this;\r\n        }\r" +
                    "\n\r\n        public virtual ISqlMakerSelect GroupBy(string columnName)\r\n        {\r" +
                    "\n            Clauses.Add(Clause.New(ClauseType.ActionSelectGroup, br + \"GROUP BY" +
                    " \", name: columnName));\r\n            return this;\r\n        }\r\n\r\n        public v" +
                    "irtual ISqlMakerSelect GroupThen(string columnName)\r\n        {\r\n            Clau" +
                    "ses.Add(Clause.New(ClauseType.ActionSelectGroup, \", \", name: columnName));\r\n    " +
                    "        return this;\r\n        }\r\n\r\n        public virtual ISqlMakerSelect Having" +
                    "(string havingConditions)\r\n        {\r\n            Clauses.Add(Clause.New(ClauseT" +
                    "ype.ActionSelectWhereOnHaving, br + \"HAVING \", condition: havingConditions));\r\n " +
                    "           return this;\r\n        }\r\n\r\n        public virtual ISqlMakerSelect Hav" +
                    "ingAnd(string havingConditions)\r\n        {\r\n            Clauses.Add(Clause.New(C" +
                    "lauseType.ActionSelectWhereOnHaving, brIndent + \"AND \", condition: havingConditi" +
                    "ons));\r\n            return this;\r\n        }\r\n\r\n        public virtual ISqlMakerS" +
                    "elect HavingOr(string havingConditions)\r\n        {\r\n            Clauses.Add(Clau" +
                    "se.New(ClauseType.ActionSelectWhereOnHaving, brIndent + \"OR \", condition: having" +
                    "Conditions));\r\n            return this;\r\n        }\r\n        #endregion SELECT\r\n\r" +
                    "\n        #region INSERT\r\n        public virtual ISqlMakerInsert INSERT(string ta" +
                    "bleName)\r\n        {\r\n            Clauses.Add(Clause.New(ClauseType.ActionInsert," +
                    " \"INSERT INTO\", name: tableName));\r\n            return this;\r\n        }\r\n       " +
                    " public virtual ISqlMakerInsert Col(string columnName)\r\n        {\r\n            C" +
                    "lauses.Add(Clause.New(ClauseType.Column, name: columnName));\r\n            return" +
                    " this;\r\n        }\r\n\r\n        public virtual ISqlMakerInsert VALUES(string parame" +
                    "ters = null)\r\n        {\r\n            Clauses.Add(Clause.New(ClauseType.ActionIns" +
                    "ertValues, \"VALUES\", extra: parameters));\r\n            return this;\r\n        }\r\n" +
                    "\r\n        public virtual ISqlMakerInsert Param(string paramName)\r\n        {\r\n   " +
                    "         Clauses.Add(Clause.New(ClauseType.Parameter, name: paramName));\r\n      " +
                    "      return this;\r\n        }\r\n        #endregion INSERT\r\n\r\n        #region UPDA" +
                    "TE\r\n        public virtual ISqlMakerUpdate UPDATE(string tableName)\r\n        {\r\n" +
                    "            Clauses.Add(Clause.New(ClauseType.ActionUpdate, \"UPDATE\", name: tabl" +
                    "eName));\r\n            return this;\r\n        }\r\n\r\n        public virtual ISqlMake" +
                    "rUpdate SET(string columnsValues = null)\r\n        {\r\n            Clauses.Add(Cla" +
                    "use.New(ClauseType.ActionUpdateSet, \"SET\", extra: columnsValues));\r\n            " +
                    "return this;\r\n        }\r\n\r\n        public virtual ISqlMakerUpdate Val(string col" +
                    "umnName, string parameterAliace)\r\n        {\r\n            Clauses.Add(Clause.New(" +
                    "ClauseType.ActionUpdateValues, name: columnName, aliace: parameterAliace));\r\n   " +
                    "         return this;\r\n        }\r\n\r\n        ISqlMakerUpdate ISqlMakerUpdate.WHER" +
                    "E(string whereConditions)\r\n        {\r\n            Clauses.Add(Clause.New(ClauseT" +
                    "ype.ActionUpdateWhere, br + \"WHERE \", condition: whereConditions));\r\n           " +
                    " return this;\r\n        }\r\n\r\n        ISqlMakerUpdate ISqlMakerUpdate.WhereAnd(str" +
                    "ing whereConditions)\r\n        {\r\n            Clauses.Add(Clause.New(ClauseType.A" +
                    "ctionUpdateWhere, brIndent + \"AND \", condition: whereConditions));\r\n            " +
                    "return this;\r\n        }\r\n\r\n        ISqlMakerUpdate ISqlMakerUpdate.WhereOr(strin" +
                    "g whereConditions)\r\n        {\r\n            Clauses.Add(Clause.New(ClauseType.Act" +
                    "ionUpdateWhere, brIndent + \"OR \", condition: whereConditions));\r\n            ret" +
                    "urn this;\r\n        }\r\n        #endregion UPDATE\r\n\r\n        #region DELETE\r\n     " +
                    "   public virtual ISqlMakerDelete DELETE(string tableName)\r\n        {\r\n         " +
                    "   Clauses.Add(Clause.New(ClauseType.ActionDelete, \"DELETE FROM\", name: tableNam" +
                    "e));\r\n            return this;\r\n        }\r\n\r\n        public virtual ISqlMakerDel" +
                    "ete WHERE(string whereConditions)\r\n        {\r\n            Clauses.Add(Clause.New" +
                    "(ClauseType.ActionDeleteWhere, br + \"WHERE \", condition: whereConditions));\r\n   " +
                    "         return this;\r\n        }\r\n\r\n        public virtual ISqlMakerDelete Where" +
                    "And(string whereConditions)\r\n        {\r\n            Clauses.Add(Clause.New(Claus" +
                    "eType.ActionDeleteWhere, brIndent + \"AND \", condition: whereConditions));\r\n     " +
                    "       return this;\r\n        }\r\n\r\n        public virtual ISqlMakerDelete WhereOr" +
                    "(string whereConditions)\r\n        {\r\n            Clauses.Add(Clause.New(ClauseTy" +
                    "pe.ActionDeleteWhere, brIndent + \"OR \", condition: whereConditions));\r\n         " +
                    "   return this;\r\n        }\r\n        #endregion DELETE\r\n    }\r\n}\r\n");
            return this.GenerationEnvironment.ToString();
        }
    }
    
    #line default
    #line hidden
    #region Base class
    /// <summary>
    /// Base class for this transformation
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "14.0.0.0")]
    public class QueryMakerBase
    {
        #region Fields
        private global::System.Text.StringBuilder generationEnvironmentField;
        private global::System.CodeDom.Compiler.CompilerErrorCollection errorsField;
        private global::System.Collections.Generic.List<int> indentLengthsField;
        private string currentIndentField = "";
        private bool endsWithNewline;
        private global::System.Collections.Generic.IDictionary<string, object> sessionField;
        #endregion
        #region Properties
        /// <summary>
        /// The string builder that generation-time code is using to assemble generated output
        /// </summary>
        protected System.Text.StringBuilder GenerationEnvironment
        {
            get
            {
                if ((this.generationEnvironmentField == null))
                {
                    this.generationEnvironmentField = new global::System.Text.StringBuilder();
                }
                return this.generationEnvironmentField;
            }
            set
            {
                this.generationEnvironmentField = value;
            }
        }
        /// <summary>
        /// The error collection for the generation process
        /// </summary>
        public System.CodeDom.Compiler.CompilerErrorCollection Errors
        {
            get
            {
                if ((this.errorsField == null))
                {
                    this.errorsField = new global::System.CodeDom.Compiler.CompilerErrorCollection();
                }
                return this.errorsField;
            }
        }
        /// <summary>
        /// A list of the lengths of each indent that was added with PushIndent
        /// </summary>
        private System.Collections.Generic.List<int> indentLengths
        {
            get
            {
                if ((this.indentLengthsField == null))
                {
                    this.indentLengthsField = new global::System.Collections.Generic.List<int>();
                }
                return this.indentLengthsField;
            }
        }
        /// <summary>
        /// Gets the current indent we use when adding lines to the output
        /// </summary>
        public string CurrentIndent
        {
            get
            {
                return this.currentIndentField;
            }
        }
        /// <summary>
        /// Current transformation session
        /// </summary>
        public virtual global::System.Collections.Generic.IDictionary<string, object> Session
        {
            get
            {
                return this.sessionField;
            }
            set
            {
                this.sessionField = value;
            }
        }
        #endregion
        #region Transform-time helpers
        /// <summary>
        /// Write text directly into the generated output
        /// </summary>
        public void Write(string textToAppend)
        {
            if (string.IsNullOrEmpty(textToAppend))
            {
                return;
            }
            // If we're starting off, or if the previous text ended with a newline,
            // we have to append the current indent first.
            if (((this.GenerationEnvironment.Length == 0) 
                        || this.endsWithNewline))
            {
                this.GenerationEnvironment.Append(this.currentIndentField);
                this.endsWithNewline = false;
            }
            // Check if the current text ends with a newline
            if (textToAppend.EndsWith(global::System.Environment.NewLine, global::System.StringComparison.CurrentCulture))
            {
                this.endsWithNewline = true;
            }
            // This is an optimization. If the current indent is "", then we don't have to do any
            // of the more complex stuff further down.
            if ((this.currentIndentField.Length == 0))
            {
                this.GenerationEnvironment.Append(textToAppend);
                return;
            }
            // Everywhere there is a newline in the text, add an indent after it
            textToAppend = textToAppend.Replace(global::System.Environment.NewLine, (global::System.Environment.NewLine + this.currentIndentField));
            // If the text ends with a newline, then we should strip off the indent added at the very end
            // because the appropriate indent will be added when the next time Write() is called
            if (this.endsWithNewline)
            {
                this.GenerationEnvironment.Append(textToAppend, 0, (textToAppend.Length - this.currentIndentField.Length));
            }
            else
            {
                this.GenerationEnvironment.Append(textToAppend);
            }
        }
        /// <summary>
        /// Write text directly into the generated output
        /// </summary>
        public void WriteLine(string textToAppend)
        {
            this.Write(textToAppend);
            this.GenerationEnvironment.AppendLine();
            this.endsWithNewline = true;
        }
        /// <summary>
        /// Write formatted text directly into the generated output
        /// </summary>
        public void Write(string format, params object[] args)
        {
            this.Write(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
        }
        /// <summary>
        /// Write formatted text directly into the generated output
        /// </summary>
        public void WriteLine(string format, params object[] args)
        {
            this.WriteLine(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
        }
        /// <summary>
        /// Raise an error
        /// </summary>
        public void Error(string message)
        {
            System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
            error.ErrorText = message;
            this.Errors.Add(error);
        }
        /// <summary>
        /// Raise a warning
        /// </summary>
        public void Warning(string message)
        {
            System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
            error.ErrorText = message;
            error.IsWarning = true;
            this.Errors.Add(error);
        }
        /// <summary>
        /// Increase the indent
        /// </summary>
        public void PushIndent(string indent)
        {
            if ((indent == null))
            {
                throw new global::System.ArgumentNullException("indent");
            }
            this.currentIndentField = (this.currentIndentField + indent);
            this.indentLengths.Add(indent.Length);
        }
        /// <summary>
        /// Remove the last indent that was added with PushIndent
        /// </summary>
        public string PopIndent()
        {
            string returnValue = "";
            if ((this.indentLengths.Count > 0))
            {
                int indentLength = this.indentLengths[(this.indentLengths.Count - 1)];
                this.indentLengths.RemoveAt((this.indentLengths.Count - 1));
                if ((indentLength > 0))
                {
                    returnValue = this.currentIndentField.Substring((this.currentIndentField.Length - indentLength));
                    this.currentIndentField = this.currentIndentField.Remove((this.currentIndentField.Length - indentLength));
                }
            }
            return returnValue;
        }
        /// <summary>
        /// Remove any indentation
        /// </summary>
        public void ClearIndent()
        {
            this.indentLengths.Clear();
            this.currentIndentField = "";
        }
        #endregion
        #region ToString Helpers
        /// <summary>
        /// Utility class to produce culture-oriented representation of an object as a string.
        /// </summary>
        public class ToStringInstanceHelper
        {
            private System.IFormatProvider formatProviderField  = global::System.Globalization.CultureInfo.InvariantCulture;
            /// <summary>
            /// Gets or sets format provider to be used by ToStringWithCulture method.
            /// </summary>
            public System.IFormatProvider FormatProvider
            {
                get
                {
                    return this.formatProviderField ;
                }
                set
                {
                    if ((value != null))
                    {
                        this.formatProviderField  = value;
                    }
                }
            }
            /// <summary>
            /// This is called from the compile/run appdomain to convert objects within an expression block to a string
            /// </summary>
            public string ToStringWithCulture(object objectToConvert)
            {
                if ((objectToConvert == null))
                {
                    throw new global::System.ArgumentNullException("objectToConvert");
                }
                System.Type t = objectToConvert.GetType();
                System.Reflection.MethodInfo method = t.GetMethod("ToString", new System.Type[] {
                            typeof(System.IFormatProvider)});
                if ((method == null))
                {
                    return objectToConvert.ToString();
                }
                else
                {
                    return ((string)(method.Invoke(objectToConvert, new object[] {
                                this.formatProviderField })));
                }
            }
        }
        private ToStringInstanceHelper toStringHelperField = new ToStringInstanceHelper();
        /// <summary>
        /// Helper to produce culture-oriented representation of an object as a string
        /// </summary>
        public ToStringInstanceHelper ToStringHelper
        {
            get
            {
                return this.toStringHelperField;
            }
        }
        #endregion
    }
    #endregion
}
