// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 14.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace Genie.Templates.Dapper
{
    using Genie.Base;
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    
    #line 1 "F:\Projects\Genie\Genie\Templates\Dapper\SqlMapper.tt"
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "14.0.0.0")]
    public partial class SqlMapper : SqlMapperBase
    {
#line hidden
        /// <summary>
        /// Create the template output
        /// </summary>
        public virtual string TransformText()
        {
            this.Write(@"using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;

namespace ");
            
            #line 16 "F:\Projects\Genie\Genie\Templates\Dapper\SqlMapper.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(GenerationContext.BaseNamespace));
            
            #line default
            #line hidden
            this.Write(".Dapper\r\n{\r\n    /// <summary>\r\n    /// Dapper, a light weight object mapper for A" +
                    "DO.NET\r\n    /// </summary>\r\n    static class SqlMapper\r\n    {\r\n        /// <summ" +
                    "ary>\r\n        /// Implement this interface to pass an arbitrary db specific set " +
                    "of parameters to Dapper\r\n        /// </summary>\r\n        public interface IDynam" +
                    "icParameters\r\n        {\r\n            /// <summary>\r\n            /// Add all the " +
                    "parameters needed to the command just before it executes\r\n            /// </summ" +
                    "ary>\r\n            /// <param name=\"command\">The raw command prior to execution</" +
                    "param>\r\n            /// <param name=\"identity\">Information about the query</para" +
                    "m>\r\n            void AddParameters(IDbCommand command, Identity identity);\r\n    " +
                    "    }\r\n\r\n        /// <summary>\r\n        /// Implement this interface to change d" +
                    "efault mapping of reader columns to type memebers\r\n        /// </summary>\r\n     " +
                    "   public interface ITypeMap\r\n        {\r\n            /// <summary>\r\n            " +
                    "/// Finds best constructor\r\n            /// </summary>\r\n            /// <param n" +
                    "ame=\"names\">DataReader column names</param>\r\n            /// <param name=\"types\"" +
                    ">DataReader column types</param>\r\n            /// <returns>Matching constructor " +
                    "or default one</returns>\r\n            ConstructorInfo FindConstructor(string[] n" +
                    "ames, Type[] types);\r\n\r\n            /// <summary>\r\n            /// Gets mapping " +
                    "for constructor parameter\r\n            /// </summary>\r\n            /// <param na" +
                    "me=\"constructor\">Constructor to resolve</param>\r\n            /// <param name=\"co" +
                    "lumnName\">DataReader column name</param>\r\n            /// <returns>Mapping imple" +
                    "mentation</returns>\r\n            IMemberMap GetConstructorParameter(ConstructorI" +
                    "nfo constructor, string columnName);\r\n\r\n            /// <summary>\r\n            /" +
                    "// Gets member mapping for column\r\n            /// </summary>\r\n            /// <" +
                    "param name=\"columnName\">DataReader column name</param>\r\n            /// <returns" +
                    ">Mapping implementation</returns>\r\n            IMemberMap GetMember(string colum" +
                    "nName);\r\n        }\r\n\r\n        /// <summary>\r\n        /// Implements this interfa" +
                    "ce to provide custom member mapping\r\n        /// </summary>\r\n        public inte" +
                    "rface IMemberMap\r\n        {\r\n            /// <summary>\r\n            /// Source D" +
                    "ataReader column name\r\n            /// </summary>\r\n            string ColumnName" +
                    " { get; }\r\n\r\n            /// <summary>\r\n            ///  Target member type\r\n   " +
                    "         /// </summary>\r\n            Type MemberType { get; }\r\n\r\n            ///" +
                    " <summary>\r\n            /// Target property\r\n            /// </summary>\r\n       " +
                    "     PropertyInfo Property { get; }\r\n\r\n            /// <summary>\r\n            //" +
                    "/ Target field\r\n            /// </summary>\r\n            FieldInfo Field { get; }" +
                    "\r\n\r\n            /// <summary>\r\n            /// Target constructor parameter\r\n   " +
                    "         /// </summary>\r\n            ParameterInfo Parameter { get; }\r\n        }" +
                    "\r\n\r\n        static Link<Type, Action<IDbCommand, bool>> _bindByNameCache;\r\n     " +
                    "   static Action<IDbCommand, bool> GetBindByName(Type commandType)\r\n        {\r\n " +
                    "           if (commandType == null) return null; // GIGO\r\n            Action<IDb" +
                    "Command, bool> action;\r\n            if (Link<Type, Action<IDbCommand, bool>>.Try" +
                    "Get(_bindByNameCache, commandType, out action))\r\n            {\r\n                " +
                    "return action;\r\n            }\r\n            var prop = commandType.GetProperty(\"B" +
                    "indByName\", BindingFlags.Public | BindingFlags.Instance);\r\n            action = " +
                    "null;\r\n            ParameterInfo[] indexers;\r\n            MethodInfo setter;\r\n  " +
                    "          if (prop != null && prop.CanWrite && prop.PropertyType == typeof(bool)" +
                    "\r\n                && ((indexers = prop.GetIndexParameters()) == null || indexers" +
                    ".Length == 0)\r\n                && (setter = prop.GetSetMethod()) != null\r\n      " +
                    "          )\r\n            {\r\n                var method = new DynamicMethod(comma" +
                    "ndType.Name + \"_BindByName\", null, new[] { typeof(IDbCommand), typeof(bool) });\r" +
                    "\n                var il = method.GetILGenerator();\r\n                il.Emit(OpCo" +
                    "des.Ldarg_0);\r\n                il.Emit(OpCodes.Castclass, commandType);\r\n       " +
                    "         il.Emit(OpCodes.Ldarg_1);\r\n                il.EmitCall(OpCodes.Callvirt" +
                    ", setter, null);\r\n                il.Emit(OpCodes.Ret);\r\n                action " +
                    "= (Action<IDbCommand, bool>)method.CreateDelegate(typeof(Action<IDbCommand, bool" +
                    ">));\r\n            }\r\n            // cache it            \r\n            Link<Type," +
                    " Action<IDbCommand, bool>>.TryAdd(ref _bindByNameCache, commandType, ref action)" +
                    ";\r\n            return action;\r\n        }\r\n        /// <summary>\r\n        /// Thi" +
                    "s is a micro-cache; suitable when the number of terms is controllable (a few hun" +
                    "dred, for example),\r\n        /// and strictly append-only; you cannot change exi" +
                    "sting values. All key matches are on **REFERENCE**\r\n        /// equality. The ty" +
                    "pe is fully thread-safe.\r\n        /// </summary>\r\n        class Link<TKey, TValu" +
                    "e> where TKey : class\r\n        {\r\n            public static bool TryGet(Link<TKe" +
                    "y, TValue> link, TKey key, out TValue value)\r\n            {\r\n                whi" +
                    "le (link != null)\r\n                {\r\n                    if (key == link.Key)\r\n" +
                    "                    {\r\n                        value = link.Value;\r\n            " +
                    "            return true;\r\n                    }\r\n                    link = link" +
                    ".Tail;\r\n                }\r\n                value = default(TValue);\r\n           " +
                    "     return false;\r\n            }\r\n            public static bool TryAdd(ref Lin" +
                    "k<TKey, TValue> head, TKey key, ref TValue value)\r\n            {\r\n              " +
                    "  bool tryAgain;\r\n                do\r\n                {\r\n                    var" +
                    " snapshot = Interlocked.CompareExchange(ref head, null, null);\r\n                " +
                    "    TValue found;\r\n                    if (TryGet(snapshot, key, out found))\r\n  " +
                    "                  { // existing match; report the existing value instead\r\n      " +
                    "                  value = found;\r\n                        return false;\r\n       " +
                    "             }\r\n                    var newNode = new Link<TKey, TValue>(key, va" +
                    "lue, snapshot);\r\n                    // did somebody move our cheese?\r\n         " +
                    "           tryAgain = Interlocked.CompareExchange(ref head, newNode, snapshot) !" +
                    "= snapshot;\r\n                } while (tryAgain);\r\n                return true;\r\n" +
                    "            }\r\n            private Link(TKey key, TValue value, Link<TKey, TValu" +
                    "e> tail)\r\n            {\r\n                Key = key;\r\n                Value = val" +
                    "ue;\r\n                Tail = tail;\r\n            }\r\n\r\n            private TKey Key" +
                    " { get; }\r\n            private TValue Value { get; }\r\n            private Link<T" +
                    "Key, TValue> Tail { get; }\r\n        }\r\n        class CacheInfo\r\n        {\r\n     " +
                    "       public DeserializerState Deserializer { get; set; }\r\n            public F" +
                    "unc<IDataReader, object>[] OtherDeserializers { get; set; }\r\n            public " +
                    "Action<IDbCommand, object> ParamReader { get; set; }\r\n            private int _h" +
                    "itCount;\r\n            public int GetHitCount() { return Interlocked.CompareExcha" +
                    "nge(ref _hitCount, 0, 0); }\r\n            public void RecordHit() { Interlocked.I" +
                    "ncrement(ref _hitCount); }\r\n        }\r\n        static int GetColumnHash(IDataRea" +
                    "der reader)\r\n        {\r\n            unchecked\r\n            {\r\n                in" +
                    "t colCount = reader.FieldCount, hash = colCount;\r\n                for (int i = 0" +
                    "; i < colCount; i++)\r\n                {   // binding code is only interested in " +
                    "names - not types\r\n                    object tmp = reader.GetName(i);\r\n        " +
                    "            hash = (hash * 31) + (tmp == null ? 0 : tmp.GetHashCode());\r\n       " +
                    "         }\r\n                return hash;\r\n            }\r\n        }\r\n        stru" +
                    "ct DeserializerState\r\n        {\r\n            public readonly int Hash;\r\n        " +
                    "    public readonly Func<IDataReader, object> Func;\r\n\r\n            public Deseri" +
                    "alizerState(int hash, Func<IDataReader, object> func)\r\n            {\r\n          " +
                    "      Hash = hash;\r\n                Func = func;\r\n            }\r\n        }\r\n\r\n  " +
                    "      /// <summary>\r\n        /// Called if the query cache is purged via PurgeQu" +
                    "eryCache\r\n        /// </summary>\r\n        public static event EventHandler Query" +
                    "CachePurged;\r\n        private static void OnQueryCachePurged()\r\n        {\r\n     " +
                    "       var handler = QueryCachePurged;\r\n            if (handler != null) handler" +
                    "(null, EventArgs.Empty);\r\n        }\r\n#if CSHARP30\r\n    private static readonly D" +
                    "ictionary<Identity, CacheInfo> _queryCache = new Dictionary<Identity, CacheInfo>" +
                    "();\r\n    // note: conflicts between readers and writers are so short-lived that " +
                    "it isn\'t worth the overhead of\r\n    // ReaderWriterLockSlim etc; a simple lock i" +
                    "s faster\r\n    private static void SetQueryCache(Identity key, CacheInfo value)\r\n" +
                    "    {\r\n        lock (_queryCache) { _queryCache[key] = value; }\r\n    }\r\n    priv" +
                    "ate static bool TryGetQueryCache(Identity key, out CacheInfo value)\r\n    {\r\n    " +
                    "    lock (_queryCache) { return _queryCache.TryGetValue(key, out value); }\r\n    " +
                    "}\r\n    private static void PurgeQueryCacheByType(Type type)\r\n    {\r\n        lock" +
                    " (_queryCache)\r\n        {\r\n            var toRemove = _queryCache.Keys.Where(id " +
                    "=> id.type == type).ToArray();\r\n            foreach (var key in toRemove)\r\n     " +
                    "           _queryCache.Remove(key);\r\n        }\r\n    }\r\n    /// <summary>\r\n    //" +
                    "/ Purge the query cache \r\n    /// </summary>\r\n    public static void PurgeQueryC" +
                    "ache()\r\n    {\r\n        lock (_queryCache)\r\n        {\r\n                _queryCach" +
                    "e.Clear();\r\n        }\r\n        OnQueryCachePurged();\r\n    }\r\n#else\r\n        stat" +
                    "ic readonly ConcurrentDictionary<Identity, CacheInfo> QueryCache = new Concurren" +
                    "tDictionary<Identity, CacheInfo>();\r\n        private static void SetQueryCache(I" +
                    "dentity key, CacheInfo value)\r\n        {\r\n            if (Interlocked.Increment(" +
                    "ref _collect) == CollectPerItems)\r\n            {\r\n                CollectCacheGa" +
                    "rbage();\r\n            }\r\n            QueryCache[key] = value;\r\n        }\r\n\r\n    " +
                    "    private static void CollectCacheGarbage()\r\n        {\r\n            try\r\n     " +
                    "       {\r\n                foreach (var pair in QueryCache)\r\n                {\r\n " +
                    "                   if (pair.Value.GetHitCount() <= CollectHitCountMin)\r\n        " +
                    "            {\r\n                        CacheInfo cache;\r\n                       " +
                    " QueryCache.TryRemove(pair.Key, out cache);\r\n                    }\r\n            " +
                    "    }\r\n            }\r\n\r\n            finally\r\n            {\r\n                Inte" +
                    "rlocked.Exchange(ref _collect, 0);\r\n            }\r\n        }\r\n\r\n        private " +
                    "const int CollectPerItems = 1000, CollectHitCountMin = 0;\r\n        private stati" +
                    "c int _collect;\r\n        private static bool TryGetQueryCache(Identity key, out " +
                    "CacheInfo value)\r\n        {\r\n            if (QueryCache.TryGetValue(key, out val" +
                    "ue))\r\n            {\r\n                value.RecordHit();\r\n                return " +
                    "true;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        /// <summa" +
                    "ry>\r\n        /// Purge the query cache \r\n        /// </summary>\r\n        public " +
                    "static void PurgeQueryCache()\r\n        {\r\n            QueryCache.Clear();\r\n     " +
                    "       OnQueryCachePurged();\r\n        }\r\n\r\n        private static void PurgeQuer" +
                    "yCacheByType(Type type)\r\n        {\r\n            foreach (var entry in QueryCache" +
                    ")\r\n            {\r\n                CacheInfo cache;\r\n                if (entry.Ke" +
                    "y.type == type)\r\n                    QueryCache.TryRemove(entry.Key, out cache);" +
                    "\r\n            }\r\n        }\r\n\r\n        /// <summary>\r\n        /// Return a count " +
                    "of all the cached queries by dapper\r\n        /// </summary>\r\n        /// <return" +
                    "s></returns>\r\n        public static int GetCachedSQLCount()\r\n        {\r\n        " +
                    "    return QueryCache.Count;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Re" +
                    "turn a list of all the queries cached by dapper\r\n        /// </summary>\r\n       " +
                    " /// <param name=\"ignoreHitCountAbove\"></param>\r\n        /// <returns></returns>" +
                    "\r\n        public static IEnumerable<Tuple<string, string, int>> GetCachedSQL(int" +
                    " ignoreHitCountAbove = int.MaxValue)\r\n        {\r\n            var data = QueryCac" +
                    "he.Select(pair => Tuple.Create(pair.Key.connectionString, pair.Key.sql, pair.Val" +
                    "ue.GetHitCount()));\r\n            if (ignoreHitCountAbove < int.MaxValue) data = " +
                    "data.Where(tuple => tuple.Item3 <= ignoreHitCountAbove);\r\n            return dat" +
                    "a;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Deep diagnostics only: find " +
                    "any hash collisions in the cache\r\n        /// </summary>\r\n        /// <returns><" +
                    "/returns>\r\n        public static IEnumerable<Tuple<int, int>> GetHashCollissions" +
                    "()\r\n        {\r\n            var counts = new Dictionary<int, int>();\r\n           " +
                    " foreach (var key in QueryCache.Keys)\r\n            {\r\n                int count;" +
                    "\r\n                if (!counts.TryGetValue(key.hashCode, out count))\r\n           " +
                    "     {\r\n                    counts.Add(key.hashCode, 1);\r\n                }\r\n   " +
                    "             else\r\n                {\r\n                    counts[key.hashCode] =" +
                    " count + 1;\r\n                }\r\n            }\r\n            return from pair in c" +
                    "ounts\r\n                    where pair.Value > 1\r\n                    select Tupl" +
                    "e.Create(pair.Key, pair.Value);\r\n\r\n        }\r\n#endif\r\n\r\n\r\n        static readonl" +
                    "y Dictionary<Type, DbType> typeMap;\r\n\r\n        static SqlMapper()\r\n        {\r\n  " +
                    "          typeMap = new Dictionary<Type, DbType>();\r\n            typeMap[typeof(" +
                    "byte)] = DbType.Byte;\r\n            typeMap[typeof(sbyte)] = DbType.SByte;\r\n     " +
                    "       typeMap[typeof(short)] = DbType.Int16;\r\n            typeMap[typeof(ushort" +
                    ")] = DbType.UInt16;\r\n            typeMap[typeof(int)] = DbType.Int32;\r\n         " +
                    "   typeMap[typeof(uint)] = DbType.UInt32;\r\n            typeMap[typeof(long)] = D" +
                    "bType.Int64;\r\n            typeMap[typeof(ulong)] = DbType.UInt64;\r\n            t" +
                    "ypeMap[typeof(float)] = DbType.Single;\r\n            typeMap[typeof(double)] = Db" +
                    "Type.Double;\r\n            typeMap[typeof(decimal)] = DbType.Decimal;\r\n          " +
                    "  typeMap[typeof(bool)] = DbType.Boolean;\r\n            typeMap[typeof(string)] =" +
                    " DbType.String;\r\n            typeMap[typeof(char)] = DbType.StringFixedLength;\r\n" +
                    "            typeMap[typeof(Guid)] = DbType.Guid;\r\n            typeMap[typeof(Dat" +
                    "eTime)] = DbType.DateTime;\r\n            typeMap[typeof(DateTimeOffset)] = DbType" +
                    ".DateTimeOffset;\r\n            typeMap[typeof(TimeSpan)] = DbType.Time;\r\n        " +
                    "    typeMap[typeof(byte[])] = DbType.Binary;\r\n            typeMap[typeof(byte?)]" +
                    " = DbType.Byte;\r\n            typeMap[typeof(sbyte?)] = DbType.SByte;\r\n          " +
                    "  typeMap[typeof(short?)] = DbType.Int16;\r\n            typeMap[typeof(ushort?)] " +
                    "= DbType.UInt16;\r\n            typeMap[typeof(int?)] = DbType.Int32;\r\n           " +
                    " typeMap[typeof(uint?)] = DbType.UInt32;\r\n            typeMap[typeof(long?)] = D" +
                    "bType.Int64;\r\n            typeMap[typeof(ulong?)] = DbType.UInt64;\r\n            " +
                    "typeMap[typeof(float?)] = DbType.Single;\r\n            typeMap[typeof(double?)] =" +
                    " DbType.Double;\r\n            typeMap[typeof(decimal?)] = DbType.Decimal;\r\n      " +
                    "      typeMap[typeof(bool?)] = DbType.Boolean;\r\n            typeMap[typeof(char?" +
                    ")] = DbType.StringFixedLength;\r\n            typeMap[typeof(Guid?)] = DbType.Guid" +
                    ";\r\n            typeMap[typeof(DateTime?)] = DbType.DateTime;\r\n            typeMa" +
                    "p[typeof(DateTimeOffset?)] = DbType.DateTimeOffset;\r\n            typeMap[typeof(" +
                    "TimeSpan?)] = DbType.Time;\r\n            typeMap[typeof(Object)] = DbType.Object;" +
                    "\r\n        }\r\n        /// <summary>\r\n        /// Configire the specified type to " +
                    "be mapped to a given db-type\r\n        /// </summary>\r\n        public static void" +
                    " AddTypeMap(Type type, DbType dbType)\r\n        {\r\n            typeMap[type] = db" +
                    "Type;\r\n        }\r\n\r\n        internal const string LinqBinary = \"System.Data.Linq" +
                    ".Binary\";\r\n        internal static DbType LookupDbType(Type type, string name)\r\n" +
                    "        {\r\n            DbType dbType;\r\n            var nullUnderlyingType = Null" +
                    "able.GetUnderlyingType(type);\r\n            if (nullUnderlyingType != null) type " +
                    "= nullUnderlyingType;\r\n            if (type.IsEnum && !typeMap.ContainsKey(type)" +
                    ")\r\n            {\r\n                type = Enum.GetUnderlyingType(type);\r\n        " +
                    "    }\r\n            if (typeMap.TryGetValue(type, out dbType))\r\n            {\r\n  " +
                    "              return dbType;\r\n            }\r\n            if (type.FullName == Li" +
                    "nqBinary)\r\n            {\r\n                return DbType.Binary;\r\n            }\r\n" +
                    "            if (typeof(IEnumerable).IsAssignableFrom(type))\r\n            {\r\n    " +
                    "            return DynamicParameters.EnumerableMultiParameter;\r\n            }\r\n\r" +
                    "\n\r\n            throw new NotSupportedException(string.Format(\"The member {0} of " +
                    "type {1} cannot be used as a parameter value\", name, type));\r\n        }\r\n\r\n\r\n   " +
                    "     /// <summary>\r\n        /// Identity of a cached query in Dapper, used for e" +
                    "xtensability\r\n        /// </summary>\r\n        public partial class Identity : IE" +
                    "quatable<Identity>\r\n        {\r\n            internal Identity ForGrid(Type primar" +
                    "yType, int gridIndex)\r\n            {\r\n                return new Identity(sql, c" +
                    "ommandType, connectionString, primaryType, parametersType, null, gridIndex);\r\n  " +
                    "          }\r\n\r\n            internal Identity ForGrid(Type primaryType, Type[] ot" +
                    "herTypes, int gridIndex)\r\n            {\r\n                return new Identity(sql" +
                    ", commandType, connectionString, primaryType, parametersType, otherTypes, gridIn" +
                    "dex);\r\n            }\r\n            /// <summary>\r\n            /// Create an ident" +
                    "ity for use with DynamicParameters, internal use only\r\n            /// </summary" +
                    ">\r\n            /// <param name=\"type\"></param>\r\n            /// <returns></retur" +
                    "ns>\r\n            public Identity ForDynamicParameters(Type type)\r\n            {\r" +
                    "\n                return new Identity(sql, commandType, connectionString, this.ty" +
                    "pe, type, null, -1);\r\n            }\r\n\r\n            internal Identity(string sql," +
                    " CommandType? commandType, IDbConnection connection, Type type, Type parametersT" +
                    "ype, Type[] otherTypes)\r\n                : this(sql, commandType, connection.Con" +
                    "nectionString, type, parametersType, otherTypes, 0)\r\n            { }\r\n          " +
                    "  private Identity(string sql, CommandType? commandType, string connectionString" +
                    ", Type type, Type parametersType, Type[] otherTypes, int gridIndex)\r\n           " +
                    " {\r\n                this.sql = sql;\r\n                this.commandType = commandT" +
                    "ype;\r\n                this.connectionString = connectionString;\r\n               " +
                    " this.type = type;\r\n                this.parametersType = parametersType;\r\n     " +
                    "           this.gridIndex = gridIndex;\r\n                unchecked\r\n             " +
                    "   {\r\n                    hashCode = 17; // we *know* we are using this in a dic" +
                    "tionary, so pre-compute this\r\n                    hashCode = hashCode * 23 + com" +
                    "mandType.GetHashCode();\r\n                    hashCode = hashCode * 23 + gridInde" +
                    "x.GetHashCode();\r\n                    hashCode = hashCode * 23 + (sql == null ? " +
                    "0 : sql.GetHashCode());\r\n                    hashCode = hashCode * 23 + (type ==" +
                    " null ? 0 : type.GetHashCode());\r\n                    if (otherTypes != null)\r\n " +
                    "                   {\r\n                        foreach (var t in otherTypes)\r\n   " +
                    "                     {\r\n                            hashCode = hashCode * 23 + (" +
                    "t == null ? 0 : t.GetHashCode());\r\n                        }\r\n                  " +
                    "  }\r\n                    hashCode = hashCode * 23 + (connectionString == null ? " +
                    "0 : connectionString.GetHashCode());\r\n                    hashCode = hashCode * " +
                    "23 + (parametersType == null ? 0 : parametersType.GetHashCode());\r\n             " +
                    "   }\r\n            }\r\n\r\n            /// <summary>\r\n            /// \r\n            " +
                    "/// </summary>\r\n            /// <param name=\"obj\"></param>\r\n            /// <ret" +
                    "urns></returns>\r\n            public override bool Equals(object obj)\r\n          " +
                    "  {\r\n                return Equals(obj as Identity);\r\n            }\r\n           " +
                    " /// <summary>\r\n            /// The sql\r\n            /// </summary>\r\n           " +
                    " public readonly string sql;\r\n            /// <summary>\r\n            /// The com" +
                    "mand type \r\n            /// </summary>\r\n            public readonly CommandType?" +
                    " commandType;\r\n\r\n            /// <summary>\r\n            /// \r\n            /// </" +
                    "summary>\r\n            public readonly int hashCode, gridIndex;\r\n            /// " +
                    "<summary>\r\n            /// \r\n            /// </summary>\r\n            public read" +
                    "only Type type;\r\n            /// <summary>\r\n            /// \r\n            /// </" +
                    "summary>\r\n            public readonly string connectionString;\r\n            /// " +
                    "<summary>\r\n            /// \r\n            /// </summary>\r\n            public read" +
                    "only Type parametersType;\r\n            /// <summary>\r\n            /// \r\n        " +
                    "    /// </summary>\r\n            /// <returns></returns>\r\n            public over" +
                    "ride int GetHashCode()\r\n            {\r\n                return hashCode;\r\n       " +
                    "     }\r\n            /// <summary>\r\n            /// Compare 2 Identity objects\r\n " +
                    "           /// </summary>\r\n            /// <param name=\"other\"></param>\r\n       " +
                    "     /// <returns></returns>\r\n            public bool Equals(Identity other)\r\n  " +
                    "          {\r\n                return\r\n                    other != null &&\r\n     " +
                    "               gridIndex == other.gridIndex &&\r\n                    type == othe" +
                    "r.type &&\r\n                    sql == other.sql &&\r\n                    commandT" +
                    "ype == other.commandType &&\r\n                    connectionString == other.conne" +
                    "ctionString &&\r\n                    parametersType == other.parametersType;\r\n   " +
                    "         }\r\n        }\r\n\r\n#if CSHARP30\r\n    /// <summary>\r\n    /// Execute parame" +
                    "terized SQL  \r\n    /// </summary>\r\n    /// <returns>Number of rows affected</ret" +
                    "urns>\r\n    public static int Execute(this IDbConnection cnn, string sql, object " +
                    "param)\r\n    {\r\n        return Execute(cnn, sql, param, null, null, null);\r\n    }" +
                    "\r\n\r\n    /// <summary>\r\n    /// Execute parameterized SQL\r\n    /// </summary>\r\n  " +
                    "  /// <returns>Number of rows affected</returns>\r\n    public static int Execute(" +
                    "this IDbConnection cnn, string sql, object param, IDbTransaction transaction)\r\n " +
                    "   {\r\n        return Execute(cnn, sql, param, transaction, null, null);\r\n    }\r\n" +
                    "\r\n    /// <summary>\r\n    /// Execute parameterized SQL\r\n    /// </summary>\r\n    " +
                    "/// <returns>Number of rows affected</returns>\r\n    public static int Execute(th" +
                    "is IDbConnection cnn, string sql, object param, CommandType commandType)\r\n    {\r" +
                    "\n        return Execute(cnn, sql, param, null, null, commandType);\r\n    }\r\n\r\n   " +
                    " /// <summary>\r\n    /// Execute parameterized SQL\r\n    /// </summary>\r\n    /// <" +
                    "returns>Number of rows affected</returns>\r\n    public static int Execute(this ID" +
                    "bConnection cnn, string sql, object param, IDbTransaction transaction, CommandTy" +
                    "pe commandType)\r\n    {\r\n        return Execute(cnn, sql, param, transaction, nul" +
                    "l, commandType);\r\n    }\r\n\r\n    /// <summary>\r\n    /// Executes a query, returnin" +
                    "g the data typed as per T\r\n    /// </summary>\r\n    /// <returns>A sequence of da" +
                    "ta of the supplied type; if a basic type (int, string, etc) is queried then the " +
                    "data from the first column in assumed, otherwise an instance is\r\n    /// created" +
                    " per row, and a direct column-name===member-name mapping is assumed (case insens" +
                    "itive).\r\n    /// </returns>\r\n    public static IEnumerable<T> Query<T>(this IDbC" +
                    "onnection cnn, string sql, object param)\r\n    {\r\n        return Query<T>(cnn, sq" +
                    "l, param, null, true, null, null);\r\n    }\r\n\r\n    /// <summary>\r\n    /// Executes" +
                    " a query, returning the data typed as per T\r\n    /// </summary>\r\n    /// <return" +
                    "s>A sequence of data of the supplied type; if a basic type (int, string, etc) is" +
                    " queried then the data from the first column in assumed, otherwise an instance i" +
                    "s\r\n    /// created per row, and a direct column-name===member-name mapping is as" +
                    "sumed (case insensitive).\r\n    /// </returns>\r\n    public static IEnumerable<T> " +
                    "Query<T>(this IDbConnection cnn, string sql, object param, IDbTransaction transa" +
                    "ction)\r\n    {\r\n        return Query<T>(cnn, sql, param, transaction, true, null," +
                    " null);\r\n    }\r\n\r\n    /// <summary>\r\n    /// Executes a query, returning the dat" +
                    "a typed as per T\r\n    /// </summary>\r\n    /// <returns>A sequence of data of the" +
                    " supplied type; if a basic type (int, string, etc) is queried then the data from" +
                    " the first column in assumed, otherwise an instance is\r\n    /// created per row," +
                    " and a direct column-name===member-name mapping is assumed (case insensitive).\r\n" +
                    "    /// </returns>\r\n    public static IEnumerable<T> Query<T>(this IDbConnection" +
                    " cnn, string sql, object param, CommandType commandType)\r\n    {\r\n        return " +
                    "Query<T>(cnn, sql, param, null, true, null, commandType);\r\n    }\r\n\r\n    /// <sum" +
                    "mary>\r\n    /// Executes a query, returning the data typed as per T\r\n    /// </su" +
                    "mmary>\r\n    /// <returns>A sequence of data of the supplied type; if a basic typ" +
                    "e (int, string, etc) is queried then the data from the first column in assumed, " +
                    "otherwise an instance is\r\n    /// created per row, and a direct column-name===me" +
                    "mber-name mapping is assumed (case insensitive).\r\n    /// </returns>\r\n    public" +
                    " static IEnumerable<T> Query<T>(this IDbConnection cnn, string sql, object param" +
                    ", IDbTransaction transaction, CommandType commandType)\r\n    {\r\n        return Qu" +
                    "ery<T>(cnn, sql, param, transaction, true, null, commandType);\r\n    }\r\n\r\n    ///" +
                    " <summary>\r\n    /// Execute a command that returns multiple result sets, and acc" +
                    "ess each in turn\r\n    /// </summary>\r\n    public static GridReader QueryMultiple" +
                    "(this IDbConnection cnn, string sql, object param, IDbTransaction transaction) \r" +
                    "\n    {\r\n        return QueryMultiple(cnn, sql, param, transaction, null, null);\r" +
                    "\n    }\r\n\r\n    /// <summary>\r\n    /// Execute a command that returns multiple res" +
                    "ult sets, and access each in turn\r\n    /// </summary>\r\n    public static GridRea" +
                    "der QueryMultiple(this IDbConnection cnn, string sql, object param, CommandType " +
                    "commandType) \r\n    {\r\n        return QueryMultiple(cnn, sql, param, null, null, " +
                    "commandType);\r\n    }\r\n\r\n    /// <summary>\r\n    /// Execute a command that return" +
                    "s multiple result sets, and access each in turn\r\n    /// </summary>\r\n    public " +
                    "static GridReader QueryMultiple(this IDbConnection cnn, string sql, object param" +
                    ", IDbTransaction transaction, CommandType commandType)\r\n    {\r\n        return Qu" +
                    "eryMultiple(cnn, sql, param, transaction, null, commandType);\r\n    }\r\n#endif\r\n  " +
                    "      /// <summary>\r\n        /// Execute parameterized SQL  \r\n        /// </summ" +
                    "ary>\r\n        /// <returns>Number of rows affected</returns>\r\n        public sta" +
                    "tic int Execute(\r\n#if CSHARP30\r\n        this IDbConnection cnn, string sql, obje" +
                    "ct param, IDbTransaction transaction, int? commandTimeout, CommandType? commandT" +
                    "ype\r\n#else\r\nthis IDbConnection cnn, string sql, dynamic param = null, IDbTransac" +
                    "tion transaction = null, int? commandTimeout = null, CommandType? commandType = " +
                    "null\r\n#endif\r\n)\r\n        {\r\n            IEnumerable multiExec = (object)param as" +
                    " IEnumerable;\r\n            Identity identity;\r\n            CacheInfo info = null" +
                    ";\r\n            if (multiExec != null && !(multiExec is string))\r\n            {\r\n" +
                    "                bool isFirst = true;\r\n                int total = 0;\r\n          " +
                    "      using (var cmd = SetupCommand(cnn, transaction, sql, null, null, commandTi" +
                    "meout, commandType))\r\n                {\r\n\r\n                    string masterSql " +
                    "= null;\r\n                    foreach (var obj in multiExec)\r\n                   " +
                    " {\r\n                        if (isFirst)\r\n                        {\r\n           " +
                    "                 masterSql = cmd.CommandText;\r\n                            isFir" +
                    "st = false;\r\n                            identity = new Identity(sql, cmd.Comman" +
                    "dType, cnn, null, obj.GetType(), null);\r\n                            info = GetC" +
                    "acheInfo(identity);\r\n                        }\r\n                        else\r\n  " +
                    "                      {\r\n                            cmd.CommandText = masterSql" +
                    "; // because we do magic replaces on \"in\" etc\r\n                            cmd.P" +
                    "arameters.Clear(); // current code is Add-tastic\r\n                        }\r\n   " +
                    "                     info.ParamReader(cmd, obj);\r\n                        total " +
                    "+= cmd.ExecuteNonQuery();\r\n                    }\r\n                }\r\n           " +
                    "     return total;\r\n            }\r\n\r\n            // nice and simple\r\n           " +
                    " if ((object)param != null)\r\n            {\r\n                identity = new Ident" +
                    "ity(sql, commandType, cnn, null, (object)param == null ? null : ((object)param)." +
                    "GetType(), null);\r\n                info = GetCacheInfo(identity);\r\n            }" +
                    "\r\n            return ExecuteCommand(cnn, transaction, sql, (object)param == null" +
                    " ? null : info.ParamReader, (object)param, commandTimeout, commandType);\r\n      " +
                    "  }\r\n#if !CSHARP30\r\n        /// <summary>\r\n        /// Return a list of dynamic " +
                    "objects, reader is closed after the call\r\n        /// </summary>\r\n        public" +
                    " static IEnumerable<dynamic> Query(this IDbConnection cnn, string sql, dynamic p" +
                    "aram = null, IDbTransaction transaction = null, bool buffered = true, int? comma" +
                    "ndTimeout = null, CommandType? commandType = null)\r\n        {\r\n            retur" +
                    "n Query<DapperRow>(cnn, sql, param as object, transaction, buffered, commandTime" +
                    "out, commandType);\r\n        }\r\n#else\r\n    /// <summary>\r\n    /// Return a list o" +
                    "f dynamic objects, reader is closed after the call\r\n    /// </summary>\r\n    publ" +
                    "ic static IEnumerable<IDictionary<string, object>> Query(this IDbConnection cnn," +
                    " string sql, object param) {\r\n        return Query(cnn, sql, param, null, true, " +
                    "null, null);\r\n    }\r\n\r\n    /// <summary>\r\n    /// Return a list of dynamic objec" +
                    "ts, reader is closed after the call\r\n    /// </summary>\r\n    public static IEnum" +
                    "erable<IDictionary<string, object>> Query(this IDbConnection cnn, string sql, ob" +
                    "ject param, IDbTransaction transaction) {\r\n        return Query(cnn, sql, param," +
                    " transaction, true, null, null);\r\n    }\r\n\r\n    /// <summary>\r\n    /// Return a l" +
                    "ist of dynamic objects, reader is closed after the call\r\n    /// </summary>\r\n   " +
                    " public static IEnumerable<IDictionary<string, object>> Query(this IDbConnection" +
                    " cnn, string sql, object param, CommandType? commandType) {\r\n        return Quer" +
                    "y(cnn, sql, param, null, true, null, commandType);\r\n    }\r\n\r\n    /// <summary>\r\n" +
                    "    /// Return a list of dynamic objects, reader is closed after the call\r\n    /" +
                    "// </summary>\r\n    public static IEnumerable<IDictionary<string, object>> Query(" +
                    "this IDbConnection cnn, string sql, object param, IDbTransaction transaction, Co" +
                    "mmandType? commandType) {\r\n        return Query(cnn, sql, param, transaction, tr" +
                    "ue, null, commandType);\r\n    }\r\n\r\n    /// <summary>\r\n    /// Return a list of dy" +
                    "namic objects, reader is closed after the call\r\n    /// </summary>\r\n    public s" +
                    "tatic IEnumerable<IDictionary<string,object>> Query(this IDbConnection cnn, stri" +
                    "ng sql, object param, IDbTransaction transaction, bool buffered, int? commandTim" +
                    "eout, CommandType? commandType) {\r\n        return Query<IDictionary<string, obje" +
                    "ct>>(cnn, sql, param, transaction, buffered, commandTimeout, commandType);\r\n    " +
                    "}\r\n#endif\r\n\r\n        /// <summary>\r\n        /// Executes a query, returning the " +
                    "data typed as per T\r\n        /// </summary>\r\n        /// <remarks>the dynamic pa" +
                    "ram may seem a bit odd, but this works around a major usability issue in vs, if " +
                    "it is Object vs completion gets annoying. Eg type new [space] get new object</re" +
                    "marks>\r\n        /// <returns>A sequence of data of the supplied type; if a basic" +
                    " type (int, string, etc) is queried then the data from the first column in assum" +
                    "ed, otherwise an instance is\r\n        /// created per row, and a direct column-n" +
                    "ame===member-name mapping is assumed (case insensitive).\r\n        /// </returns>" +
                    "\r\n        public static IEnumerable<T> Query<T>(\r\n#if CSHARP30\r\n        this IDb" +
                    "Connection cnn, string sql, object param, IDbTransaction transaction, bool buffe" +
                    "red, int? commandTimeout, CommandType? commandType\r\n#else\r\nthis IDbConnection cn" +
                    "n, string sql, dynamic param = null, IDbTransaction transaction = null, bool buf" +
                    "fered = true, int? commandTimeout = null, CommandType? commandType = null\r\n#endi" +
                    "f\r\n)\r\n        {\r\n            var data = QueryInternal<T>(cnn, sql, param as obje" +
                    "ct, transaction, commandTimeout, commandType);\r\n            return buffered ? da" +
                    "ta.ToList() : data;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Execute a c" +
                    "ommand that returns multiple result sets, and access each in turn\r\n        /// <" +
                    "/summary>\r\n        public static GridReader QueryMultiple(\r\n#if CSHARP30\r\n      " +
                    "  this IDbConnection cnn, string sql, object param, IDbTransaction transaction, " +
                    "int? commandTimeout, CommandType? commandType\r\n#else\r\n        this IDbConnection" +
                    " cnn, string sql, dynamic param = null, IDbTransaction transaction = null, int? " +
                    "commandTimeout = null, CommandType? commandType = null\r\n#endif\r\n)\r\n        {\r\n  " +
                    "          Identity identity = new Identity(sql, commandType, cnn, typeof(GridRea" +
                    "der), (object)param == null ? null : ((object)param).GetType(), null);\r\n        " +
                    "    CacheInfo info = GetCacheInfo(identity);\r\n\r\n            IDbCommand cmd = nul" +
                    "l;\r\n            IDataReader reader = null;\r\n            bool wasClosed = cnn.Sta" +
                    "te == ConnectionState.Closed;\r\n            try\r\n            {\r\n                i" +
                    "f (wasClosed) cnn.Open();\r\n                cmd = SetupCommand(cnn, transaction, " +
                    "sql, info.ParamReader, (object)param, commandTimeout, commandType);\r\n           " +
                    "     reader = cmd.ExecuteReader(wasClosed ? CommandBehavior.CloseConnection : Co" +
                    "mmandBehavior.Default);\r\n\r\n                var result = new GridReader(cmd, read" +
                    "er, identity);\r\n                wasClosed = false; // *if* the connection was cl" +
                    "osed and we got this far, then we now have a reader\r\n                           " +
                    "         // with the CloseConnection flag, so the reader will deal with the conn" +
                    "ection; we\r\n                                    // still need something in the \"" +
                    "finally\" to ensure that broken SQL still results\r\n                              " +
                    "      // in the connection closing itself\r\n                return result;\r\n     " +
                    "       }\r\n            catch\r\n            {\r\n                if (reader != null)\r" +
                    "\n                {\r\n                    if (!reader.IsClosed) try { cmd.Cancel()" +
                    "; }\r\n                        catch { /* don\'t spoil the existing exception */ }\r" +
                    "\n                    reader.Dispose();\r\n                }\r\n                if (c" +
                    "md != null) cmd.Dispose();\r\n                if (wasClosed) cnn.Close();\r\n       " +
                    "         throw;\r\n            }\r\n        }\r\n\r\n        /// <summary>\r\n        /// " +
                    "Return a typed list of objects, reader is closed after the call\r\n        /// </s" +
                    "ummary>\r\n        private static IEnumerable<T> QueryInternal<T>(this IDbConnecti" +
                    "on cnn, string sql, object param, IDbTransaction transaction, int? commandTimeou" +
                    "t, CommandType? commandType)\r\n        {\r\n            var identity = new Identity" +
                    "(sql, commandType, cnn, typeof(T), param == null ? null : param.GetType(), null)" +
                    ";\r\n            var info = GetCacheInfo(identity);\r\n\r\n            IDbCommand cmd " +
                    "= null;\r\n            IDataReader reader = null;\r\n\r\n            bool wasClosed = " +
                    "cnn.State == ConnectionState.Closed;\r\n            try\r\n            {\r\n          " +
                    "      cmd = SetupCommand(cnn, transaction, sql, info.ParamReader, param, command" +
                    "Timeout, commandType);\r\n\r\n                if (wasClosed) cnn.Open();\r\n          " +
                    "      reader = cmd.ExecuteReader(wasClosed ? CommandBehavior.CloseConnection : C" +
                    "ommandBehavior.Default);\r\n                wasClosed = false; // *if* the connect" +
                    "ion was closed and we got this far, then we now have a reader\r\n                 " +
                    "                   // with the CloseConnection flag, so the reader will deal wit" +
                    "h the connection; we\r\n                                    // still need somethin" +
                    "g in the \"finally\" to ensure that broken SQL still results\r\n                    " +
                    "                // in the connection closing itself\r\n                var tuple =" +
                    " info.Deserializer;\r\n                int hash = GetColumnHash(reader);\r\n        " +
                    "        if (tuple.Func == null || tuple.Hash != hash)\r\n                {\r\n      " +
                    "              tuple = info.Deserializer = new DeserializerState(hash, GetDeseria" +
                    "lizer(typeof(T), reader, 0, -1, false));\r\n                    SetQueryCache(iden" +
                    "tity, info);\r\n                }\r\n\r\n                var func = tuple.Func;\r\n\r\n   " +
                    "             while (reader.Read())\r\n                {\r\n                    yield" +
                    " return (T)func(reader);\r\n                }\r\n                // happy path; clos" +
                    "e the reader cleanly - no\r\n                // need for \"Cancel\" etc\r\n           " +
                    "     reader.Dispose();\r\n                reader = null;\r\n            }\r\n         " +
                    "   finally\r\n            {\r\n                if (reader != null)\r\n                " +
                    "{\r\n                    if (!reader.IsClosed) try { cmd.Cancel(); }\r\n            " +
                    "            catch { /* don\'t spoil the existing exception */ }\r\n                " +
                    "    reader.Dispose();\r\n                }\r\n                if (wasClosed) cnn.Clo" +
                    "se();\r\n                if (cmd != null) cmd.Dispose();\r\n            }\r\n        }" +
                    "\r\n\r\n        /// <summary>\r\n        /// Maps a query to objects\r\n        /// </su" +
                    "mmary>\r\n        /// <typeparam name=\"TFirst\">The first type in the recordset</ty" +
                    "peparam>\r\n        /// <typeparam name=\"TSecond\">The second type in the recordset" +
                    "</typeparam>\r\n        /// <typeparam name=\"TReturn\">The return type</typeparam>\r" +
                    "\n        /// <param name=\"cnn\"></param>\r\n        /// <param name=\"sql\"></param>\r" +
                    "\n        /// <param name=\"map\"></param>\r\n        /// <param name=\"param\"></param" +
                    ">\r\n        /// <param name=\"transaction\"></param>\r\n        /// <param name=\"buff" +
                    "ered\"></param>\r\n        /// <param name=\"splitOn\">The Field we should split and " +
                    "read the second object from (default: id)</param>\r\n        /// <param name=\"comm" +
                    "andTimeout\">Number of seconds before command execution timeout</param>\r\n        " +
                    "/// <param name=\"commandType\">Is it a stored proc or a batch?</param>\r\n        /" +
                    "// <returns></returns>\r\n        public static IEnumerable<TReturn> Query<TFirst," +
                    " TSecond, TReturn>(\r\n#if CSHARP30\r\n        this IDbConnection cnn, string sql, F" +
                    "unc<TFirst, TSecond, TReturn> map, object param, IDbTransaction transaction, boo" +
                    "l buffered, string splitOn, int? commandTimeout, CommandType? commandType\r\n#else" +
                    "\r\nthis IDbConnection cnn, string sql, Func<TFirst, TSecond, TReturn> map, dynami" +
                    "c param = null, IDbTransaction transaction = null, bool buffered = true, string " +
                    "splitOn = \"Id\", int? commandTimeout = null, CommandType? commandType = null\r\n#en" +
                    "dif\r\n)\r\n        {\r\n            return MultiMap<TFirst, TSecond, DontMap, DontMap" +
                    ", DontMap, TReturn>(cnn, sql, map, param as object, transaction, buffered, split" +
                    "On, commandTimeout, commandType);\r\n        }\r\n\r\n        /// <summary>\r\n        /" +
                    "// Maps a query to objects\r\n        /// </summary>\r\n        /// <typeparam name=" +
                    "\"TFirst\"></typeparam>\r\n        /// <typeparam name=\"TSecond\"></typeparam>\r\n     " +
                    "   /// <typeparam name=\"TThird\"></typeparam>\r\n        /// <typeparam name=\"TRetu" +
                    "rn\"></typeparam>\r\n        /// <param name=\"cnn\"></param>\r\n        /// <param nam" +
                    "e=\"sql\"></param>\r\n        /// <param name=\"map\"></param>\r\n        /// <param nam" +
                    "e=\"param\"></param>\r\n        /// <param name=\"transaction\"></param>\r\n        /// " +
                    "<param name=\"buffered\"></param>\r\n        /// <param name=\"splitOn\">The Field we " +
                    "should split and read the second object from (default: id)</param>\r\n        /// " +
                    "<param name=\"commandTimeout\">Number of seconds before command execution timeout<" +
                    "/param>\r\n        /// <param name=\"commandType\"></param>\r\n        /// <returns></" +
                    "returns>\r\n        public static IEnumerable<TReturn> Query<TFirst, TSecond, TThi" +
                    "rd, TReturn>(\r\n#if CSHARP30\r\n        this IDbConnection cnn, string sql, Func<TF" +
                    "irst, TSecond, TThird, TReturn> map, object param, IDbTransaction transaction, b" +
                    "ool buffered, string splitOn, int? commandTimeout, CommandType? commandType\r\n#el" +
                    "se\r\nthis IDbConnection cnn, string sql, Func<TFirst, TSecond, TThird, TReturn> m" +
                    "ap, dynamic param = null, IDbTransaction transaction = null, bool buffered = tru" +
                    "e, string splitOn = \"Id\", int? commandTimeout = null, CommandType? commandType =" +
                    " null\r\n#endif\r\n)\r\n        {\r\n            return MultiMap<TFirst, TSecond, TThird" +
                    ", DontMap, DontMap, TReturn>(cnn, sql, map, param as object, transaction, buffer" +
                    "ed, splitOn, commandTimeout, commandType);\r\n        }\r\n\r\n        /// <summary>\r\n" +
                    "        /// Perform a multi mapping query with 4 input parameters\r\n        /// <" +
                    "/summary>\r\n        /// <typeparam name=\"TFirst\"></typeparam>\r\n        /// <typep" +
                    "aram name=\"TSecond\"></typeparam>\r\n        /// <typeparam name=\"TThird\"></typepar" +
                    "am>\r\n        /// <typeparam name=\"TFourth\"></typeparam>\r\n        /// <typeparam " +
                    "name=\"TReturn\"></typeparam>\r\n        /// <param name=\"cnn\"></param>\r\n        ///" +
                    " <param name=\"sql\"></param>\r\n        /// <param name=\"map\"></param>\r\n        ///" +
                    " <param name=\"param\"></param>\r\n        /// <param name=\"transaction\"></param>\r\n " +
                    "       /// <param name=\"buffered\"></param>\r\n        /// <param name=\"splitOn\"></" +
                    "param>\r\n        /// <param name=\"commandTimeout\"></param>\r\n        /// <param na" +
                    "me=\"commandType\"></param>\r\n        /// <returns></returns>\r\n        public stati" +
                    "c IEnumerable<TReturn> Query<TFirst, TSecond, TThird, TFourth, TReturn>(\r\n#if CS" +
                    "HARP30\r\n        this IDbConnection cnn, string sql, Func<TFirst, TSecond, TThird" +
                    ", TFourth, TReturn> map, object param, IDbTransaction transaction, bool buffered" +
                    ", string splitOn, int? commandTimeout, CommandType? commandType\r\n#else\r\nthis IDb" +
                    "Connection cnn, string sql, Func<TFirst, TSecond, TThird, TFourth, TReturn> map," +
                    " dynamic param = null, IDbTransaction transaction = null, bool buffered = true, " +
                    "string splitOn = \"Id\", int? commandTimeout = null, CommandType? commandType = nu" +
                    "ll\r\n#endif\r\n)\r\n        {\r\n            return MultiMap<TFirst, TSecond, TThird, T" +
                    "Fourth, DontMap, TReturn>(cnn, sql, map, param as object, transaction, buffered," +
                    " splitOn, commandTimeout, commandType);\r\n        }\r\n#if !CSHARP30\r\n        /// <" +
                    "summary>\r\n        /// Perform a multi mapping query with 5 input parameters\r\n   " +
                    "     /// </summary>\r\n        /// <typeparam name=\"TFirst\"></typeparam>\r\n        " +
                    "/// <typeparam name=\"TSecond\"></typeparam>\r\n        /// <typeparam name=\"TThird\"" +
                    "></typeparam>\r\n        /// <typeparam name=\"TFourth\"></typeparam>\r\n        /// <" +
                    "typeparam name=\"TFifth\"></typeparam>\r\n        /// <typeparam name=\"TReturn\"></ty" +
                    "peparam>\r\n        /// <param name=\"cnn\"></param>\r\n        /// <param name=\"sql\">" +
                    "</param>\r\n        /// <param name=\"map\"></param>\r\n        /// <param name=\"param" +
                    "\"></param>\r\n        /// <param name=\"transaction\"></param>\r\n        /// <param n" +
                    "ame=\"buffered\"></param>\r\n        /// <param name=\"splitOn\"></param>\r\n        ///" +
                    " <param name=\"commandTimeout\"></param>\r\n        /// <param name=\"commandType\"></" +
                    "param>\r\n        /// <returns></returns>\r\n        public static IEnumerable<TRetu" +
                    "rn> Query<TFirst, TSecond, TThird, TFourth, TFifth, TReturn>(this IDbConnection " +
                    "cnn, string sql, Func<TFirst, TSecond, TThird, TFourth, TFifth, TReturn> map, dy" +
                    "namic param = null, IDbTransaction transaction = null, bool buffered = true, str" +
                    "ing splitOn = \"Id\", int? commandTimeout = null, CommandType? commandType = null)" +
                    "\r\n        {\r\n            return MultiMap<TFirst, TSecond, TThird, TFourth, TFift" +
                    "h, TReturn>(cnn, sql, map, param as object, transaction, buffered, splitOn, comm" +
                    "andTimeout, commandType);\r\n        }\r\n#endif\r\n        partial class DontMap { }\r" +
                    "\n        static IEnumerable<TReturn> MultiMap<TFirst, TSecond, TThird, TFourth, " +
                    "TFifth, TReturn>(\r\n            this IDbConnection cnn, string sql, object map, o" +
                    "bject param, IDbTransaction transaction, bool buffered, string splitOn, int? com" +
                    "mandTimeout, CommandType? commandType)\r\n        {\r\n            var results = Mul" +
                    "tiMapImpl<TFirst, TSecond, TThird, TFourth, TFifth, TReturn>(cnn, sql, map, para" +
                    "m, transaction, splitOn, commandTimeout, commandType, null, null);\r\n            " +
                    "return buffered ? results.ToList() : results;\r\n        }\r\n\r\n\r\n        static IEn" +
                    "umerable<TReturn> MultiMapImpl<TFirst, TSecond, TThird, TFourth, TFifth, TReturn" +
                    ">(this IDbConnection cnn, string sql, object map, object param, IDbTransaction t" +
                    "ransaction, string splitOn, int? commandTimeout, CommandType? commandType, IData" +
                    "Reader reader, Identity identity)\r\n        {\r\n            identity = identity ??" +
                    " new Identity(sql, commandType, cnn, typeof(TFirst), (object)param == null ? nul" +
                    "l : ((object)param).GetType(), new[] { typeof(TFirst), typeof(TSecond), typeof(T" +
                    "Third), typeof(TFourth), typeof(TFifth) });\r\n            CacheInfo cinfo = GetCa" +
                    "cheInfo(identity);\r\n\r\n            IDbCommand ownedCommand = null;\r\n            I" +
                    "DataReader ownedReader = null;\r\n\r\n            try\r\n            {\r\n              " +
                    "  if (reader == null)\r\n                {\r\n                    ownedCommand = Set" +
                    "upCommand(cnn, transaction, sql, cinfo.ParamReader, (object)param, commandTimeou" +
                    "t, commandType);\r\n                    ownedReader = ownedCommand.ExecuteReader()" +
                    ";\r\n                    reader = ownedReader;\r\n                }\r\n               " +
                    " DeserializerState deserializer = default(DeserializerState);\r\n                F" +
                    "unc<IDataReader, object>[] otherDeserializers = null;\r\n\r\n                int has" +
                    "h = GetColumnHash(reader);\r\n                if ((deserializer = cinfo.Deserializ" +
                    "er).Func == null || (otherDeserializers = cinfo.OtherDeserializers) == null || h" +
                    "ash != deserializer.Hash)\r\n                {\r\n                    var deserializ" +
                    "ers = GenerateDeserializers(new Type[] { typeof(TFirst), typeof(TSecond), typeof" +
                    "(TThird), typeof(TFourth), typeof(TFifth) }, splitOn, reader);\r\n                " +
                    "    deserializer = cinfo.Deserializer = new DeserializerState(hash, deserializer" +
                    "s[0]);\r\n                    otherDeserializers = cinfo.OtherDeserializers = dese" +
                    "rializers.Skip(1).ToArray();\r\n                    SetQueryCache(identity, cinfo)" +
                    ";\r\n                }\r\n\r\n                Func<IDataReader, TReturn> mapIt = Gener" +
                    "ateMapper<TFirst, TSecond, TThird, TFourth, TFifth, TReturn>(deserializer.Func, " +
                    "otherDeserializers, map);\r\n\r\n                if (mapIt != null)\r\n               " +
                    " {\r\n                    while (reader.Read())\r\n                    {\r\n          " +
                    "              yield return mapIt(reader);\r\n                    }\r\n              " +
                    "  }\r\n            }\r\n            finally\r\n            {\r\n                try\r\n   " +
                    "             {\r\n                    if (ownedReader != null)\r\n                  " +
                    "  {\r\n                        ownedReader.Dispose();\r\n                    }\r\n    " +
                    "            }\r\n                finally\r\n                {\r\n                    i" +
                    "f (ownedCommand != null)\r\n                    {\r\n                        ownedCo" +
                    "mmand.Dispose();\r\n                    }\r\n                }\r\n            }\r\n     " +
                    "   }\r\n\r\n        private static Func<IDataReader, TReturn> GenerateMapper<TFirst," +
                    " TSecond, TThird, TFourth, TFifth, TReturn>(Func<IDataReader, object> deserializ" +
                    "er, Func<IDataReader, object>[] otherDeserializers, object map)\r\n        {\r\n    " +
                    "        switch (otherDeserializers.Length)\r\n            {\r\n                case " +
                    "1:\r\n                    return r => ((Func<TFirst, TSecond, TReturn>)map)((TFirs" +
                    "t)deserializer(r), (TSecond)otherDeserializers[0](r));\r\n                case 2:\r" +
                    "\n                    return r => ((Func<TFirst, TSecond, TThird, TReturn>)map)((" +
                    "TFirst)deserializer(r), (TSecond)otherDeserializers[0](r), (TThird)otherDeserial" +
                    "izers[1](r));\r\n                case 3:\r\n                    return r => ((Func<T" +
                    "First, TSecond, TThird, TFourth, TReturn>)map)((TFirst)deserializer(r), (TSecond" +
                    ")otherDeserializers[0](r), (TThird)otherDeserializers[1](r), (TFourth)otherDeser" +
                    "ializers[2](r));\r\n#if !CSHARP30\r\n                case 4:\r\n                    re" +
                    "turn r => ((Func<TFirst, TSecond, TThird, TFourth, TFifth, TReturn>)map)((TFirst" +
                    ")deserializer(r), (TSecond)otherDeserializers[0](r), (TThird)otherDeserializers[" +
                    "1](r), (TFourth)otherDeserializers[2](r), (TFifth)otherDeserializers[3](r));\r\n#e" +
                    "ndif\r\n                default:\r\n                    throw new NotSupportedExcept" +
                    "ion();\r\n            }\r\n        }\r\n\r\n        private static Func<IDataReader, obj" +
                    "ect>[] GenerateDeserializers(Type[] types, string splitOn, IDataReader reader)\r\n" +
                    "        {\r\n            int current = 0;\r\n            var splits = splitOn.Split(" +
                    "\',\').ToArray();\r\n            var splitIndex = 0;\r\n\r\n            Func<Type, int> " +
                    "nextSplit = type =>\r\n            {\r\n                var currentSplit = splits[sp" +
                    "litIndex].Trim();\r\n                if (splits.Length > splitIndex + 1)\r\n        " +
                    "        {\r\n                    splitIndex++;\r\n                }\r\n\r\n             " +
                    "   bool skipFirst = false;\r\n                int startingPos = current + 1;\r\n    " +
                    "            // if our current type has the split, skip the first time you see it" +
                    ". \r\n                if (type != typeof(Object))\r\n                {\r\n            " +
                    "        var props = DefaultTypeMap.GetSettableProps(type);\r\n                    " +
                    "var fields = DefaultTypeMap.GetSettableFields(type);\r\n\r\n                    fore" +
                    "ach (var name in props.Select(p => p.Name).Concat(fields.Select(f => f.Name)))\r\n" +
                    "                    {\r\n                        if (string.Equals(name, currentSp" +
                    "lit, StringComparison.OrdinalIgnoreCase))\r\n                        {\r\n          " +
                    "                  skipFirst = true;\r\n                            startingPos = c" +
                    "urrent;\r\n                            break;\r\n                        }\r\n        " +
                    "            }\r\n\r\n                }\r\n\r\n                int pos;\r\n                " +
                    "for (pos = startingPos; pos < reader.FieldCount; pos++)\r\n                {\r\n    " +
                    "                // some people like ID some id ... assuming case insensitive spl" +
                    "its for now\r\n                    if (splitOn == \"*\")\r\n                    {\r\n   " +
                    "                     break;\r\n                    }\r\n                    if (stri" +
                    "ng.Equals(reader.GetName(pos), currentSplit, StringComparison.OrdinalIgnoreCase)" +
                    ")\r\n                    {\r\n                        if (skipFirst)\r\n              " +
                    "          {\r\n                            skipFirst = false;\r\n                   " +
                    "     }\r\n                        else\r\n                        {\r\n               " +
                    "             break;\r\n                        }\r\n                    }\r\n         " +
                    "       }\r\n                current = pos;\r\n                return pos;\r\n         " +
                    "   };\r\n\r\n            var deserializers = new List<Func<IDataReader, object>>();\r" +
                    "\n            int split = 0;\r\n            bool first = true;\r\n            foreach" +
                    " (var type in types)\r\n            {\r\n                if (type != typeof(DontMap)" +
                    ")\r\n                {\r\n                    int next = nextSplit(type);\r\n         " +
                    "           deserializers.Add(GetDeserializer(type, reader, split, next - split, " +
                    "/* returnNullIfFirstMissing: */ !first));\r\n                    first = false;\r\n " +
                    "                   split = next;\r\n                }\r\n            }\r\n\r\n          " +
                    "  return deserializers.ToArray();\r\n        }\r\n\r\n        private static CacheInfo" +
                    " GetCacheInfo(Identity identity)\r\n        {\r\n            CacheInfo info;\r\n      " +
                    "      if (!TryGetQueryCache(identity, out info))\r\n            {\r\n               " +
                    " info = new CacheInfo();\r\n                if (identity.parametersType != null)\r\n" +
                    "                {\r\n                    if (typeof(IDynamicParameters).IsAssignab" +
                    "leFrom(identity.parametersType))\r\n                    {\r\n                       " +
                    " info.ParamReader = (cmd, obj) => { (obj as IDynamicParameters).AddParameters(cm" +
                    "d, identity); };\r\n                    }\r\n#if !CSHARP30\r\n                    else" +
                    " if (typeof(IEnumerable<KeyValuePair<string, object>>).IsAssignableFrom(identity" +
                    ".parametersType) && typeof(System.Dynamic.IDynamicMetaObjectProvider).IsAssignab" +
                    "leFrom(identity.parametersType))\r\n                    {\r\n                       " +
                    " info.ParamReader = (cmd, obj) =>\r\n                        {\r\n                  " +
                    "          IDynamicParameters mapped = new DynamicParameters(obj);\r\n             " +
                    "               mapped.AddParameters(cmd, identity);\r\n                        };\r" +
                    "\n                    }\r\n#endif\r\n                    else\r\n                    {\r" +
                    "\n                        info.ParamReader = CreateParamInfoGenerator(identity, f" +
                    "alse);\r\n                    }\r\n                }\r\n                SetQueryCache(" +
                    "identity, info);\r\n            }\r\n            return info;\r\n        }\r\n\r\n        " +
                    "private static Func<IDataReader, object> GetDeserializer(Type type, IDataReader " +
                    "reader, int startBound, int length, bool returnNullIfFirstMissing)\r\n        {\r\n#" +
                    "if !CSHARP30\r\n            // dynamic is passed in as Object ... by c# design\r\n  " +
                    "          if (type == typeof(object)\r\n                || type == typeof(DapperRo" +
                    "w))\r\n            {\r\n                return GetDapperRowDeserializer(reader, star" +
                    "tBound, length, returnNullIfFirstMissing);\r\n            }\r\n#else\r\n        if(typ" +
                    "e.IsAssignableFrom(typeof(Dictionary<string,object>)))\r\n        {\r\n            r" +
                    "eturn GetDictionaryDeserializer(reader, startBound, length, returnNullIfFirstMis" +
                    "sing);\r\n        }\r\n#endif\r\n            Type underlyingType = null;\r\n            " +
                    "if (!(typeMap.ContainsKey(type) || type.IsEnum || type.FullName == LinqBinary ||" +
                    "\r\n                (type.IsValueType && (underlyingType = Nullable.GetUnderlyingT" +
                    "ype(type)) != null && underlyingType.IsEnum)))\r\n            {\r\n                r" +
                    "eturn GetTypeDeserializer(type, reader, startBound, length, returnNullIfFirstMis" +
                    "sing);\r\n            }\r\n            return GetStructDeserializer(type, underlying" +
                    "Type ?? type, startBound);\r\n\r\n        }\r\n\r\n#if !CSHARP30\r\n        sealed partial" +
                    " class DapperTable\r\n        {\r\n            string[] fieldNames;\r\n            rea" +
                    "donly Dictionary<string, int> fieldNameLookup;\r\n\r\n            internal string[] " +
                    "FieldNames { get { return fieldNames; } }\r\n\r\n            public DapperTable(stri" +
                    "ng[] fieldNames)\r\n            {\r\n                if (fieldNames == null) throw n" +
                    "ew ArgumentNullException(\"fieldNames\");\r\n                this.fieldNames = field" +
                    "Names;\r\n\r\n                fieldNameLookup = new Dictionary<string, int>(fieldNam" +
                    "es.Length, StringComparer.Ordinal);\r\n                // if there are dups, we wa" +
                    "nt the **first** key to be the \"winner\" - so iterate backwards\r\n                " +
                    "for (int i = fieldNames.Length - 1; i >= 0; i--)\r\n                {\r\n           " +
                    "         string key = fieldNames[i];\r\n                    if (key != null) field" +
                    "NameLookup[key] = i;\r\n                }\r\n            }\r\n\r\n            internal i" +
                    "nt IndexOfName(string name)\r\n            {\r\n                int result;\r\n       " +
                    "         return (name != null && fieldNameLookup.TryGetValue(name, out result)) " +
                    "? result : -1;\r\n            }\r\n            internal int AddField(string name)\r\n " +
                    "           {\r\n                if (name == null) throw new ArgumentNullException(" +
                    "\"name\");\r\n                if (fieldNameLookup.ContainsKey(name)) throw new Inval" +
                    "idOperationException(\"Field already exists: \" + name);\r\n                int oldL" +
                    "en = fieldNames.Length;\r\n                Array.Resize(ref fieldNames, oldLen + 1" +
                    "); // yes, this is sub-optimal, but this is not the expected common case\r\n      " +
                    "          fieldNameLookup[name] = oldLen;\r\n                return oldLen;\r\n     " +
                    "       }\r\n\r\n\r\n            internal bool FieldExists(string key)\r\n            {\r\n" +
                    "                return key != null && fieldNameLookup.ContainsKey(key);\r\n       " +
                    "     }\r\n\r\n            public int FieldCount { get { return fieldNames.Length; } " +
                    "}\r\n        }\r\n\r\n        sealed partial class DapperRowMetaObject : System.Dynami" +
                    "c.DynamicMetaObject\r\n        {\r\n            static readonly MethodInfo getValueM" +
                    "ethod = typeof(IDictionary<string, object>).GetProperty(\"Item\").GetGetMethod();\r" +
                    "\n            static readonly MethodInfo setValueMethod = typeof(DapperRow).GetMe" +
                    "thod(\"SetValue\");\r\n\r\n            public DapperRowMetaObject(\r\n                Sy" +
                    "stem.Linq.Expressions.Expression expression,\r\n                System.Dynamic.Bin" +
                    "dingRestrictions restrictions\r\n                )\r\n                : base(express" +
                    "ion, restrictions)\r\n            {\r\n            }\r\n\r\n            public DapperRow" +
                    "MetaObject(\r\n                System.Linq.Expressions.Expression expression,\r\n   " +
                    "             System.Dynamic.BindingRestrictions restrictions,\r\n                o" +
                    "bject value\r\n                )\r\n                : base(expression, restrictions," +
                    " value)\r\n            {\r\n            }\r\n\r\n            System.Dynamic.DynamicMetaO" +
                    "bject CallMethod(\r\n                MethodInfo method,\r\n                System.Li" +
                    "nq.Expressions.Expression[] parameters\r\n                )\r\n            {\r\n      " +
                    "          var callMethod = new System.Dynamic.DynamicMetaObject(\r\n              " +
                    "      System.Linq.Expressions.Expression.Call(\r\n                        System.L" +
                    "inq.Expressions.Expression.Convert(Expression, LimitType),\r\n                    " +
                    "    method,\r\n                        parameters),\r\n                    System.Dy" +
                    "namic.BindingRestrictions.GetTypeRestriction(Expression, LimitType)\r\n           " +
                    "         );\r\n                return callMethod;\r\n            }\r\n\r\n            pu" +
                    "blic override System.Dynamic.DynamicMetaObject BindGetMember(System.Dynamic.GetM" +
                    "emberBinder binder)\r\n            {\r\n                var parameters = new System." +
                    "Linq.Expressions.Expression[]\r\n                                        {\r\n      " +
                    "                                  System.Linq.Expressions.Expression.Constant(bi" +
                    "nder.Name)\r\n                                        };\r\n\r\n                var ca" +
                    "llMethod = CallMethod(getValueMethod, parameters);\r\n\r\n                return cal" +
                    "lMethod;\r\n            }\r\n\r\n            public override System.Dynamic.DynamicMet" +
                    "aObject BindSetMember(System.Dynamic.SetMemberBinder binder, System.Dynamic.Dyna" +
                    "micMetaObject value)\r\n            {\r\n                var parameters = new System" +
                    ".Linq.Expressions.Expression[]\r\n                                        {\r\n     " +
                    "                                   System.Linq.Expressions.Expression.Constant(b" +
                    "inder.Name),\r\n                                        value.Expression,\r\n       " +
                    "                                 };\r\n\r\n                var callMethod = CallMeth" +
                    "od(setValueMethod, parameters);\r\n\r\n                return callMethod;\r\n         " +
                    "   }\r\n        }\r\n\r\n        sealed partial class DapperRow\r\n            : System." +
                    "Dynamic.IDynamicMetaObjectProvider\r\n            , IDictionary<string, object>\r\n " +
                    "       {\r\n            readonly DapperTable table;\r\n            object[] values;\r" +
                    "\n\r\n            public DapperRow(DapperTable table, object[] values)\r\n           " +
                    " {\r\n                if (table == null) throw new ArgumentNullException(\"table\");" +
                    "\r\n                if (values == null) throw new ArgumentNullException(\"values\");" +
                    "\r\n                this.table = table;\r\n                this.values = values;\r\n  " +
                    "          }\r\n            private sealed class DeadValue\r\n            {\r\n        " +
                    "        public static readonly DeadValue Default = new DeadValue();\r\n           " +
                    "     private DeadValue() { }\r\n            }\r\n            int ICollection<KeyValu" +
                    "ePair<string, object>>.Count\r\n            {\r\n                get\r\n              " +
                    "  {\r\n                    int count = 0;\r\n                    for (int i = 0; i <" +
                    " values.Length; i++)\r\n                    {\r\n                        if (!(value" +
                    "s[i] is DeadValue)) count++;\r\n                    }\r\n                    return " +
                    "count;\r\n                }\r\n            }\r\n\r\n            public bool TryGetValue(" +
                    "string name, out object value)\r\n            {\r\n                var index = table" +
                    ".IndexOfName(name);\r\n                if (index < 0)\r\n                { // doesn\'" +
                    "t exist\r\n                    value = null;\r\n                    return false;\r\n " +
                    "               }\r\n                // exists, **even if** we don\'t have a value; " +
                    "consider table rows heterogeneous\r\n                value = index < values.Length" +
                    " ? values[index] : null;\r\n                if (value is DeadValue)\r\n             " +
                    "   { // pretend it isn\'t here\r\n                    value = null;\r\n              " +
                    "      return false;\r\n                }\r\n                return true;\r\n          " +
                    "  }\r\n\r\n            public override string ToString()\r\n            {\r\n           " +
                    "     var sb = new StringBuilder(\"{DapperRow\");\r\n                foreach (var kv " +
                    "in this)\r\n                {\r\n                    var value = kv.Value;\r\n        " +
                    "            sb.Append(\", \").Append(kv.Key);\r\n                    if (value != nu" +
                    "ll)\r\n                    {\r\n                        sb.Append(\" = \'\").Append(kv." +
                    "Value).Append(\'\\\'\');\r\n                    }\r\n                    else\r\n         " +
                    "           {\r\n                        sb.Append(\" = NULL\");\r\n                   " +
                    " }\r\n                }\r\n\r\n                return sb.Append(\'}\').ToString();\r\n    " +
                    "        }\r\n\r\n            System.Dynamic.DynamicMetaObject System.Dynamic.IDynami" +
                    "cMetaObjectProvider.GetMetaObject(\r\n                System.Linq.Expressions.Expr" +
                    "ession parameter)\r\n            {\r\n                return new DapperRowMetaObject" +
                    "(parameter, System.Dynamic.BindingRestrictions.Empty, this);\r\n            }\r\n\r\n " +
                    "           public IEnumerator<KeyValuePair<string, object>> GetEnumerator()\r\n   " +
                    "         {\r\n                var names = table.FieldNames;\r\n                for (" +
                    "var i = 0; i < names.Length; i++)\r\n                {\r\n                    object" +
                    " value = i < values.Length ? values[i] : null;\r\n                    if (!(value " +
                    "is DeadValue))\r\n                    {\r\n                        yield return new " +
                    "KeyValuePair<string, object>(names[i], value);\r\n                    }\r\n         " +
                    "       }\r\n            }\r\n\r\n            IEnumerator IEnumerable.GetEnumerator()\r\n" +
                    "            {\r\n                return GetEnumerator();\r\n            }\r\n\r\n       " +
                    "     #region Implementation of ICollection<KeyValuePair<string,object>>\r\n\r\n     " +
                    "       void ICollection<KeyValuePair<string, object>>.Add(KeyValuePair<string, o" +
                    "bject> item)\r\n            {\r\n                IDictionary<string, object> dic = t" +
                    "his;\r\n                dic.Add(item.Key, item.Value);\r\n            }\r\n\r\n         " +
                    "   void ICollection<KeyValuePair<string, object>>.Clear()\r\n            { // remo" +
                    "ves values for **this row**, but doesn\'t change the fundamental table\r\n         " +
                    "       for (int i = 0; i < values.Length; i++)\r\n                    values[i] = " +
                    "DeadValue.Default;\r\n            }\r\n\r\n            bool ICollection<KeyValuePair<s" +
                    "tring, object>>.Contains(KeyValuePair<string, object> item)\r\n            {\r\n    " +
                    "            object value;\r\n                return TryGetValue(item.Key, out valu" +
                    "e) && Equals(value, item.Value);\r\n            }\r\n\r\n            void ICollection<" +
                    "KeyValuePair<string, object>>.CopyTo(KeyValuePair<string, object>[] array, int a" +
                    "rrayIndex)\r\n            {\r\n                foreach (var kv in this)\r\n           " +
                    "     {\r\n                    array[arrayIndex++] = kv; // if they didn\'t leave en" +
                    "ough space; not our fault\r\n                }\r\n            }\r\n\r\n            bool " +
                    "ICollection<KeyValuePair<string, object>>.Remove(KeyValuePair<string, object> it" +
                    "em)\r\n            {\r\n                IDictionary<string, object> dic = this;\r\n   " +
                    "             return dic.Remove(item.Key);\r\n            }\r\n\r\n            bool ICo" +
                    "llection<KeyValuePair<string, object>>.IsReadOnly\r\n            {\r\n              " +
                    "  get { return false; }\r\n            }\r\n\r\n            #endregion\r\n\r\n            " +
                    "#region Implementation of IDictionary<string,object>\r\n\r\n            bool IDictio" +
                    "nary<string, object>.ContainsKey(string key)\r\n            {\r\n                int" +
                    " index = table.IndexOfName(key);\r\n                if (index < 0 || index >= valu" +
                    "es.Length || values[index] is DeadValue) return false;\r\n                return t" +
                    "rue;\r\n            }\r\n\r\n            void IDictionary<string, object>.Add(string k" +
                    "ey, object value)\r\n            {\r\n                IDictionary<string, object> di" +
                    "c = this;\r\n                dic[key] = value;\r\n            }\r\n\r\n            bool " +
                    "IDictionary<string, object>.Remove(string key)\r\n            {\r\n                i" +
                    "nt index = table.IndexOfName(key);\r\n                if (index < 0 || index >= va" +
                    "lues.Length || values[index] is DeadValue) return false;\r\n                values" +
                    "[index] = DeadValue.Default;\r\n                return true;\r\n            }\r\n\r\n   " +
                    "         object IDictionary<string, object>.this[string key]\r\n            {\r\n   " +
                    "             get { object val; TryGetValue(key, out val); return val; }\r\n       " +
                    "         set { SetValue(key, value); }\r\n            }\r\n            public object" +
                    " SetValue(string key, object value)\r\n            {\r\n                if (key == n" +
                    "ull) throw new ArgumentNullException(\"key\");\r\n                int index = table." +
                    "IndexOfName(key);\r\n                if (index < 0)\r\n                {\r\n          " +
                    "          index = table.AddField(key);\r\n                }\r\n                if (v" +
                    "alues.Length <= index)\r\n                {   // we\'ll assume they\'re doing lots o" +
                    "f things, and\r\n                    // grow it to the full width of the table\r\n  " +
                    "                  Array.Resize(ref values, table.FieldCount);\r\n                }" +
                    "\r\n                return values[index] = value;\r\n            }\r\n\r\n            IC" +
                    "ollection<string> IDictionary<string, object>.Keys\r\n            {\r\n             " +
                    "   get { return this.Select(kv => kv.Key).ToArray(); }\r\n            }\r\n\r\n       " +
                    "     ICollection<object> IDictionary<string, object>.Values\r\n            {\r\n    " +
                    "            get { return this.Select(kv => kv.Value).ToArray(); }\r\n            }" +
                    "\r\n\r\n            #endregion\r\n        }\r\n#endif\r\n\r\n#if !CSHARP30\r\n        internal" +
                    " static Func<IDataReader, object> GetDapperRowDeserializer(IDataRecord reader, i" +
                    "nt startBound, int length, bool returnNullIfFirstMissing)\r\n        {\r\n          " +
                    "  var fieldCount = reader.FieldCount;\r\n            if (length == -1)\r\n          " +
                    "  {\r\n                length = fieldCount - startBound;\r\n            }\r\n\r\n       " +
                    "     if (fieldCount <= startBound)\r\n            {\r\n                throw new Arg" +
                    "umentException(\"When using the multi-mapping APIs ensure you set the splitOn par" +
                    "am if you have keys other than Id\", \"splitOn\");\r\n            }\r\n\r\n            va" +
                    "r effectiveFieldCount = fieldCount - startBound;\r\n\r\n            DapperTable tabl" +
                    "e = null;\r\n\r\n            return\r\n                r =>\r\n                {\r\n      " +
                    "              if (table == null)\r\n                    {\r\n                       " +
                    " string[] names = new string[effectiveFieldCount];\r\n                        for " +
                    "(int i = 0; i < effectiveFieldCount; i++)\r\n                        {\r\n          " +
                    "                  names[i] = r.GetName(i + startBound);\r\n                       " +
                    " }\r\n                        table = new DapperTable(names);\r\n                   " +
                    " }\r\n\r\n                    var values = new object[effectiveFieldCount];\r\n\r\n     " +
                    "               if (returnNullIfFirstMissing)\r\n                    {\r\n           " +
                    "             values[0] = r.GetValue(startBound);\r\n                        if (va" +
                    "lues[0] is DBNull)\r\n                        {\r\n                            retur" +
                    "n null;\r\n                        }\r\n                    }\r\n\r\n                   " +
                    " if (startBound == 0)\r\n                    {\r\n                        r.GetValue" +
                    "s(values);\r\n                    }\r\n                    else\r\n                   " +
                    " {\r\n                        var begin = returnNullIfFirstMissing ? 1 : 0;\r\n     " +
                    "                   for (var iter = begin; iter < effectiveFieldCount; ++iter)\r\n " +
                    "                       {\r\n                            values[iter] = r.GetValue(" +
                    "iter + startBound);\r\n                        }\r\n                    }\r\n         " +
                    "           return new DapperRow(table, values);\r\n                };\r\n        }\r\n" +
                    "#else\r\n    internal static Func<IDataReader, object> GetDictionaryDeserializer(I" +
                    "DataRecord reader, int startBound, int length, bool returnNullIfFirstMissing)\r\n " +
                    "   {\r\n        var fieldCount = reader.FieldCount;\r\n        if (length == -1)\r\n  " +
                    "      {\r\n            length = fieldCount - startBound;\r\n        }\r\n\r\n        if " +
                    "(fieldCount <= startBound)\r\n        {\r\n            throw new ArgumentException(\"" +
                    "When using the multi-mapping APIs ensure you set the splitOn param if you have k" +
                    "eys other than Id\", \"splitOn\");\r\n        }\r\n\r\n        return\r\n                r " +
                    "=>\r\n                {\r\n                    IDictionary<string, object> row = new" +
                    " Dictionary<string, object>(length);\r\n                    for (var i = startBoun" +
                    "d; i < startBound + length; i++)\r\n                    {\r\n                       " +
                    " var tmp = r.GetValue(i);\r\n                        tmp = tmp == DBNull.Value ? n" +
                    "ull : tmp;\r\n                        row[r.GetName(i)] = tmp;\r\n                  " +
                    "      if (returnNullIfFirstMissing && i == startBound && tmp == null)\r\n         " +
                    "               {\r\n                            return null;\r\n                    " +
                    "    }\r\n                    }\r\n                    return row;\r\n                }" +
                    ";\r\n    }\r\n#endif\r\n        /// <summary>\r\n        /// Internal use only\r\n        " +
                    "/// </summary>\r\n        /// <param name=\"value\"></param>\r\n        /// <returns><" +
                    "/returns>\r\n        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never" +
                    ")]\r\n        [Obsolete(\"This method is for internal usage only\", false)]\r\n       " +
                    " public static char ReadChar(object value)\r\n        {\r\n            if (value == " +
                    "null || value is DBNull) throw new ArgumentNullException(\"value\");\r\n            " +
                    "string s = value as string;\r\n            if (s == null || s.Length != 1) throw n" +
                    "ew ArgumentException(\"A single-character was expected\", \"value\");\r\n            r" +
                    "eturn s[0];\r\n        }\r\n\r\n        /// <summary>\r\n        /// Internal use only\r\n" +
                    "        /// </summary>\r\n        [Browsable(false), EditorBrowsable(EditorBrowsab" +
                    "leState.Never)]\r\n        [Obsolete(\"This method is for internal usage only\", fal" +
                    "se)]\r\n        public static char? ReadNullableChar(object value)\r\n        {\r\n   " +
                    "         if (value == null || value is DBNull) return null;\r\n            string " +
                    "s = value as string;\r\n            if (s == null || s.Length != 1) throw new Argu" +
                    "mentException(\"A single-character was expected\", \"value\");\r\n            return s" +
                    "[0];\r\n        }\r\n\r\n\r\n        /// <summary>\r\n        /// Internal use only\r\n     " +
                    "   /// </summary>\r\n        [Browsable(false), EditorBrowsable(EditorBrowsableSta" +
                    "te.Never)]\r\n        [Obsolete(\"This method is for internal usage only\", true)]\r\n" +
                    "        public static IDbDataParameter FindOrAddParameter(IDataParameterCollecti" +
                    "on parameters, IDbCommand command, string name)\r\n        {\r\n            IDbDataP" +
                    "arameter result;\r\n            if (parameters.Contains(name))\r\n            {\r\n   " +
                    "             result = (IDbDataParameter)parameters[name];\r\n            }\r\n      " +
                    "      else\r\n            {\r\n                result = command.CreateParameter();\r\n" +
                    "                result.ParameterName = name;\r\n                parameters.Add(res" +
                    "ult);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        /// <summ" +
                    "ary>\r\n        /// Internal use only\r\n        /// </summary>\r\n        [Browsable(" +
                    "false), EditorBrowsable(EditorBrowsableState.Never)]\r\n        [Obsolete(\"This me" +
                    "thod is for internal usage only\", false)]\r\n        public static void PackListPa" +
                    "rameters(IDbCommand command, string namePrefix, object value)\r\n        {\r\n      " +
                    "      // initially we tried TVP, however it performs quite poorly.\r\n            " +
                    "// keep in mind SQL support up to 2000 params easily in sp_executesql, needing m" +
                    "ore is rare\r\n\r\n            var list = value as IEnumerable;\r\n            var cou" +
                    "nt = 0;\r\n\r\n            if (list != null)\r\n            {\r\n                if (Fea" +
                    "tureSupport.Get(command.Connection).Arrays)\r\n                {\r\n                " +
                    "    var arrayParm = command.CreateParameter();\r\n                    arrayParm.Va" +
                    "lue = list;\r\n                    arrayParm.ParameterName = namePrefix;\r\n        " +
                    "            command.Parameters.Add(arrayParm);\r\n                }\r\n             " +
                    "   else\r\n                {\r\n                    bool isString = value is IEnumer" +
                    "able<string>;\r\n                    bool isDbString = value is IEnumerable<DbStri" +
                    "ng>;\r\n                    foreach (var item in list)\r\n                    {\r\n   " +
                    "                     count++;\r\n                        var listParam = command.C" +
                    "reateParameter();\r\n                        listParam.ParameterName = namePrefix " +
                    "+ count;\r\n                        listParam.Value = item ?? DBNull.Value;\r\n     " +
                    "                   if (isString)\r\n                        {\r\n                   " +
                    "         listParam.Size = 4000;\r\n                            if (item != null &&" +
                    " ((string)item).Length > 4000)\r\n                            {\r\n                 " +
                    "               listParam.Size = -1;\r\n                            }\r\n            " +
                    "            }\r\n                        if (isDbString && item as DbString != nul" +
                    "l)\r\n                        {\r\n                            var str = item as DbS" +
                    "tring;\r\n                            str.AddParameter(command, listParam.Paramete" +
                    "rName);\r\n                        }\r\n                        else\r\n              " +
                    "          {\r\n                            command.Parameters.Add(listParam);\r\n   " +
                    "                     }\r\n                    }\r\n\r\n                    if (count =" +
                    "= 0)\r\n                    {\r\n                        command.CommandText = Regex" +
                    ".Replace(command.CommandText, @\"[?@:]\" + Regex.Escape(namePrefix), \"(SELECT NULL" +
                    " WHERE 1 = 0)\");\r\n                    }\r\n                    else\r\n             " +
                    "       {\r\n                        command.CommandText = Regex.Replace(command.Co" +
                    "mmandText, @\"[?@:]\" + Regex.Escape(namePrefix), match =>\r\n                      " +
                    "  {\r\n                            var grp = match.Value;\r\n                       " +
                    "     var sb = new StringBuilder(\"(\").Append(grp).Append(1);\r\n                   " +
                    "         for (int i = 2; i <= count; i++)\r\n                            {\r\n      " +
                    "                          sb.Append(\',\').Append(grp).Append(i);\r\n               " +
                    "             }\r\n                            return sb.Append(\')\').ToString();\r\n " +
                    "                       });\r\n                    }\r\n                }\r\n          " +
                    "  }\r\n\r\n        }\r\n\r\n        private static IEnumerable<PropertyInfo> FilterParam" +
                    "eters(IEnumerable<PropertyInfo> parameters, string sql)\r\n        {\r\n            " +
                    "return parameters.Where(p => Regex.IsMatch(sql, \"[@:]\" + p.Name + \"([^a-zA-Z0-9_" +
                    "]+|$)\", RegexOptions.IgnoreCase | RegexOptions.Multiline));\r\n        }\r\n\r\n      " +
                    "  /// <summary>\r\n        /// Internal use only\r\n        /// </summary>\r\n        " +
                    "public static Action<IDbCommand, object> CreateParamInfoGenerator(Identity ident" +
                    "ity, bool checkForDuplicates)\r\n        {\r\n            Type type = identity.param" +
                    "etersType;\r\n            bool filterParams = identity.commandType.GetValueOrDefau" +
                    "lt(CommandType.Text) == CommandType.Text;\r\n            var dm = new DynamicMetho" +
                    "d(string.Format(\"ParamInfo{0}\", Guid.NewGuid()), null, new[] { typeof(IDbCommand" +
                    "), typeof(object) }, type, true);\r\n\r\n            var il = dm.GetILGenerator();\r\n" +
                    "\r\n            il.DeclareLocal(type); // 0\r\n            bool haveInt32Arg1 = fals" +
                    "e;\r\n            il.Emit(OpCodes.Ldarg_1); // stack is now [untyped-param]\r\n     " +
                    "       il.Emit(OpCodes.Unbox_Any, type); // stack is now [typed-param]\r\n        " +
                    "    il.Emit(OpCodes.Stloc_0);// stack is now empty\r\n\r\n            il.Emit(OpCode" +
                    "s.Ldarg_0); // stack is now [command]\r\n            il.EmitCall(OpCodes.Callvirt," +
                    " typeof(IDbCommand).GetProperty(\"Parameters\").GetGetMethod(), null); // stack is" +
                    " now [parameters]\r\n\r\n            IEnumerable<PropertyInfo> props = type.GetPrope" +
                    "rties().Where(p => p.GetIndexParameters().Length == 0).OrderBy(p => p.Name);\r\n  " +
                    "          if (filterParams)\r\n            {\r\n                props = FilterParame" +
                    "ters(props, identity.sql);\r\n            }\r\n            foreach (var prop in prop" +
                    "s)\r\n            {\r\n                if (filterParams)\r\n                {\r\n       " +
                    "             if (identity.sql.IndexOf(\"@\" + prop.Name, StringComparison.Invarian" +
                    "tCultureIgnoreCase) < 0\r\n                        && identity.sql.IndexOf(\":\" + p" +
                    "rop.Name, StringComparison.InvariantCultureIgnoreCase) < 0)\r\n                   " +
                    " { // can\'t see the parameter in the text (even in a comment, etc) - burn it wit" +
                    "h fire\r\n                        continue;\r\n                    }\r\n              " +
                    "  }\r\n                if (prop.PropertyType == typeof(DbString))\r\n               " +
                    " {\r\n                    il.Emit(OpCodes.Ldloc_0); // stack is now [parameters] [" +
                    "typed-param]\r\n                    il.Emit(OpCodes.Callvirt, prop.GetGetMethod())" +
                    "; // stack is [parameters] [dbstring]\r\n                    il.Emit(OpCodes.Ldarg" +
                    "_0); // stack is now [parameters] [dbstring] [command]\r\n                    il.E" +
                    "mit(OpCodes.Ldstr, prop.Name); // stack is now [parameters] [dbstring] [command]" +
                    " [name]\r\n                    il.EmitCall(OpCodes.Callvirt, typeof(DbString).GetM" +
                    "ethod(\"AddParameter\"), null); // stack is now [parameters]\r\n                    " +
                    "continue;\r\n                }\r\n                DbType dbType = LookupDbType(prop." +
                    "PropertyType, prop.Name);\r\n                if (dbType == DynamicParameters.Enume" +
                    "rableMultiParameter)\r\n                {\r\n                    // this actually re" +
                    "presents special handling for list types;\r\n                    il.Emit(OpCodes.L" +
                    "darg_0); // stack is now [parameters] [command]\r\n                    il.Emit(OpC" +
                    "odes.Ldstr, prop.Name); // stack is now [parameters] [command] [name]\r\n         " +
                    "           il.Emit(OpCodes.Ldloc_0); // stack is now [parameters] [command] [nam" +
                    "e] [typed-param]\r\n                    il.Emit(OpCodes.Callvirt, prop.GetGetMetho" +
                    "d()); // stack is [parameters] [command] [name] [typed-value]\r\n                 " +
                    "   if (prop.PropertyType.IsValueType)\r\n                    {\r\n                  " +
                    "      il.Emit(OpCodes.Box, prop.PropertyType); // stack is [parameters] [command" +
                    "] [name] [boxed-value]\r\n                    }\r\n                    il.EmitCall(O" +
                    "pCodes.Call, typeof(SqlMapper).GetMethod(\"PackListParameters\"), null); // stack " +
                    "is [parameters]\r\n                    continue;\r\n                }\r\n             " +
                    "   il.Emit(OpCodes.Dup); // stack is now [parameters] [parameters]\r\n\r\n          " +
                    "      il.Emit(OpCodes.Ldarg_0); // stack is now [parameters] [parameters] [comma" +
                    "nd]\r\n\r\n                if (checkForDuplicates)\r\n                {\r\n             " +
                    "       // need to be a little careful about adding; use a utility method\r\n      " +
                    "              il.Emit(OpCodes.Ldstr, prop.Name); // stack is now [parameters] [p" +
                    "arameters] [command] [name]\r\n                    il.EmitCall(OpCodes.Call, typeo" +
                    "f(SqlMapper).GetMethod(\"FindOrAddParameter\"), null); // stack is [parameters] [p" +
                    "arameter]\r\n                }\r\n                else\r\n                {\r\n         " +
                    "           // no risk of duplicates; just blindly add\r\n                    il.Em" +
                    "itCall(OpCodes.Callvirt, typeof(IDbCommand).GetMethod(\"CreateParameter\"), null);" +
                    "// stack is now [parameters] [parameters] [parameter]\r\n\r\n                    il." +
                    "Emit(OpCodes.Dup);// stack is now [parameters] [parameters] [parameter] [paramet" +
                    "er]\r\n                    il.Emit(OpCodes.Ldstr, prop.Name); // stack is now [par" +
                    "ameters] [parameters] [parameter] [parameter] [name]\r\n                    il.Emi" +
                    "tCall(OpCodes.Callvirt, typeof(IDataParameter).GetProperty(\"ParameterName\").GetS" +
                    "etMethod(), null);// stack is now [parameters] [parameters] [parameter]\r\n       " +
                    "         }\r\n                if (dbType != DbType.Time) // https://connect.micros" +
                    "oft.com/VisualStudio/feedback/details/381934/sqlparameter-dbtype-dbtype-time-set" +
                    "s-the-parameter-to-sqldbtype-datetime-instead-of-sqldbtype-time\r\n               " +
                    " {\r\n                    il.Emit(OpCodes.Dup);// stack is now [parameters] [[para" +
                    "meters]] [parameter] [parameter]\r\n                    EmitInt32(il, (int)dbType)" +
                    ";// stack is now [parameters] [[parameters]] [parameter] [parameter] [db-type]\r\n" +
                    "\r\n                    il.EmitCall(OpCodes.Callvirt, typeof(IDataParameter).GetPr" +
                    "operty(\"DbType\").GetSetMethod(), null);// stack is now [parameters] [[parameters" +
                    "]] [parameter]\r\n                }\r\n\r\n                il.Emit(OpCodes.Dup);// sta" +
                    "ck is now [parameters] [[parameters]] [parameter] [parameter]\r\n                E" +
                    "mitInt32(il, (int)ParameterDirection.Input);// stack is now [parameters] [[param" +
                    "eters]] [parameter] [parameter] [dir]\r\n                il.EmitCall(OpCodes.Callv" +
                    "irt, typeof(IDataParameter).GetProperty(\"Direction\").GetSetMethod(), null);// st" +
                    "ack is now [parameters] [[parameters]] [parameter]\r\n\r\n                il.Emit(Op" +
                    "Codes.Dup);// stack is now [parameters] [[parameters]] [parameter] [parameter]\r\n" +
                    "                il.Emit(OpCodes.Ldloc_0); // stack is now [parameters] [[paramet" +
                    "ers]] [parameter] [parameter] [typed-param]\r\n                il.Emit(OpCodes.Cal" +
                    "lvirt, prop.GetGetMethod()); // stack is [parameters] [[parameters]] [parameter]" +
                    " [parameter] [typed-value]\r\n                bool checkForNull = true;\r\n         " +
                    "       if (prop.PropertyType.IsValueType)\r\n                {\r\n                  " +
                    "  il.Emit(OpCodes.Box, prop.PropertyType); // stack is [parameters] [[parameters" +
                    "]] [parameter] [parameter] [boxed-value]\r\n                    if (Nullable.GetUn" +
                    "derlyingType(prop.PropertyType) == null)\r\n                    {   // struct but " +
                    "not Nullable<T>; boxed value cannot be null\r\n                        checkForNul" +
                    "l = false;\r\n                    }\r\n                }\r\n                if (checkF" +
                    "orNull)\r\n                {\r\n                    if (dbType == DbType.String && !" +
                    "haveInt32Arg1)\r\n                    {\r\n                        il.DeclareLocal(t" +
                    "ypeof(int));\r\n                        haveInt32Arg1 = true;\r\n                   " +
                    " }\r\n                    // relative stack: [boxed value]\r\n                    il" +
                    ".Emit(OpCodes.Dup);// relative stack: [boxed value] [boxed value]\r\n             " +
                    "       Label notNull = il.DefineLabel();\r\n                    Label? allDone = d" +
                    "bType == DbType.String ? il.DefineLabel() : (Label?)null;\r\n                    i" +
                    "l.Emit(OpCodes.Brtrue_S, notNull);\r\n                    // relative stack [boxed" +
                    " value = null]\r\n                    il.Emit(OpCodes.Pop); // relative stack empt" +
                    "y\r\n                    il.Emit(OpCodes.Ldsfld, typeof(DBNull).GetField(\"Value\"))" +
                    "; // relative stack [DBNull]\r\n                    if (dbType == DbType.String)\r\n" +
                    "                    {\r\n                        EmitInt32(il, 0);\r\n              " +
                    "          il.Emit(OpCodes.Stloc_1);\r\n                    }\r\n                    " +
                    "if (allDone != null) il.Emit(OpCodes.Br_S, allDone.Value);\r\n                    " +
                    "il.MarkLabel(notNull);\r\n                    if (prop.PropertyType == typeof(stri" +
                    "ng))\r\n                    {\r\n                        il.Emit(OpCodes.Dup); // [s" +
                    "tring] [string]\r\n                        il.EmitCall(OpCodes.Callvirt, typeof(st" +
                    "ring).GetProperty(\"Length\").GetGetMethod(), null); // [string] [length]\r\n       " +
                    "                 EmitInt32(il, 4000); // [string] [length] [4000]\r\n             " +
                    "           il.Emit(OpCodes.Cgt); // [string] [0 or 1]\r\n                        L" +
                    "abel isLong = il.DefineLabel(), lenDone = il.DefineLabel();\r\n                   " +
                    "     il.Emit(OpCodes.Brtrue_S, isLong);\r\n                        EmitInt32(il, 4" +
                    "000); // [string] [4000]\r\n                        il.Emit(OpCodes.Br_S, lenDone)" +
                    ";\r\n                        il.MarkLabel(isLong);\r\n                        EmitIn" +
                    "t32(il, -1); // [string] [-1]\r\n                        il.MarkLabel(lenDone);\r\n " +
                    "                       il.Emit(OpCodes.Stloc_1); // [string] \r\n                 " +
                    "   }\r\n                    if (prop.PropertyType.FullName == LinqBinary)\r\n       " +
                    "             {\r\n                        il.EmitCall(OpCodes.Callvirt, prop.Prope" +
                    "rtyType.GetMethod(\"ToArray\", BindingFlags.Public | BindingFlags.Instance), null)" +
                    ";\r\n                    }\r\n                    if (allDone != null) il.MarkLabel(" +
                    "allDone.Value);\r\n                    // relative stack [boxed value or DBNull]\r\n" +
                    "                }\r\n                il.EmitCall(OpCodes.Callvirt, typeof(IDataPar" +
                    "ameter).GetProperty(\"Value\").GetSetMethod(), null);// stack is now [parameters] " +
                    "[[parameters]] [parameter]\r\n\r\n                if (prop.PropertyType == typeof(st" +
                    "ring))\r\n                {\r\n                    var endOfSize = il.DefineLabel();" +
                    "\r\n                    // don\'t set if 0\r\n                    il.Emit(OpCodes.Ldl" +
                    "oc_1); // [parameters] [[parameters]] [parameter] [size]\r\n                    il" +
                    ".Emit(OpCodes.Brfalse_S, endOfSize); // [parameters] [[parameters]] [parameter]\r" +
                    "\n\r\n                    il.Emit(OpCodes.Dup);// stack is now [parameters] [[param" +
                    "eters]] [parameter] [parameter]\r\n                    il.Emit(OpCodes.Ldloc_1); /" +
                    "/ stack is now [parameters] [[parameters]] [parameter] [parameter] [size]\r\n     " +
                    "               il.EmitCall(OpCodes.Callvirt, typeof(IDbDataParameter).GetPropert" +
                    "y(\"Size\").GetSetMethod(), null); // stack is now [parameters] [[parameters]] [pa" +
                    "rameter]\r\n\r\n                    il.MarkLabel(endOfSize);\r\n                }\r\n   " +
                    "             if (checkForDuplicates)\r\n                {\r\n                    // " +
                    "stack is now [parameters] [parameter]\r\n                    il.Emit(OpCodes.Pop);" +
                    " // don\'t need parameter any more\r\n                }\r\n                else\r\n    " +
                    "            {\r\n                    // stack is now [parameters] [parameters] [pa" +
                    "rameter]\r\n                    // blindly add\r\n                    il.EmitCall(Op" +
                    "Codes.Callvirt, typeof(IList).GetMethod(\"Add\"), null); // stack is now [paramete" +
                    "rs]\r\n                    il.Emit(OpCodes.Pop); // IList.Add returns the new inde" +
                    "x (int); we don\'t care\r\n                }\r\n            }\r\n            // stack i" +
                    "s currently [parameters]\r\n            il.Emit(OpCodes.Pop); // stack is now empt" +
                    "y\r\n            il.Emit(OpCodes.Ret);\r\n            return (Action<IDbCommand, obj" +
                    "ect>)dm.CreateDelegate(typeof(Action<IDbCommand, object>));\r\n        }\r\n\r\n      " +
                    "  private static IDbCommand SetupCommand(IDbConnection cnn, IDbTransaction trans" +
                    "action, string sql, Action<IDbCommand, object> paramReader, object obj, int? com" +
                    "mandTimeout, CommandType? commandType)\r\n        {\r\n            var cmd = cnn.Cre" +
                    "ateCommand();\r\n            var bindByName = GetBindByName(cmd.GetType());\r\n     " +
                    "       if (bindByName != null) bindByName(cmd, true);\r\n            if (transacti" +
                    "on != null)\r\n                cmd.Transaction = transaction;\r\n            cmd.Com" +
                    "mandText = sql;\r\n            if (commandTimeout.HasValue)\r\n                cmd.C" +
                    "ommandTimeout = commandTimeout.Value;\r\n            if (commandType.HasValue)\r\n  " +
                    "              cmd.CommandType = commandType.Value;\r\n            if (paramReader " +
                    "!= null)\r\n            {\r\n                paramReader(cmd, obj);\r\n            }\r\n" +
                    "            return cmd;\r\n        }\r\n\r\n\r\n        private static int ExecuteComman" +
                    "d(IDbConnection cnn, IDbTransaction transaction, string sql, Action<IDbCommand, " +
                    "object> paramReader, object obj, int? commandTimeout, CommandType? commandType)\r" +
                    "\n        {\r\n            IDbCommand cmd = null;\r\n            bool wasClosed = cnn" +
                    ".State == ConnectionState.Closed;\r\n            try\r\n            {\r\n             " +
                    "   cmd = SetupCommand(cnn, transaction, sql, paramReader, obj, commandTimeout, c" +
                    "ommandType);\r\n                if (wasClosed) cnn.Open();\r\n                return" +
                    " cmd.ExecuteNonQuery();\r\n            }\r\n            finally\r\n            {\r\n    " +
                    "            if (wasClosed) cnn.Close();\r\n                if (cmd != null) cmd.Di" +
                    "spose();\r\n            }\r\n        }\r\n\r\n        private static Func<IDataReader, o" +
                    "bject> GetStructDeserializer(Type type, Type effectiveType, int index)\r\n        " +
                    "{\r\n            // no point using special per-type handling here; it boils down t" +
                    "o the same, plus not all are supported anyway (see: SqlDataReader.GetChar - not " +
                    "supported!)\r\n#pragma warning disable 618\r\n            if (type == typeof(char))\r" +
                    "\n            { // this *does* need special handling, though\r\n                ret" +
                    "urn r => SqlMapper.ReadChar(r.GetValue(index));\r\n            }\r\n            if (" +
                    "type == typeof(char?))\r\n            {\r\n                return r => SqlMapper.Rea" +
                    "dNullableChar(r.GetValue(index));\r\n            }\r\n            if (type.FullName " +
                    "== LinqBinary)\r\n            {\r\n                return r => Activator.CreateInsta" +
                    "nce(type, r.GetValue(index));\r\n            }\r\n#pragma warning restore 618\r\n\r\n   " +
                    "         if (effectiveType.IsEnum)\r\n            {   // assume the value is retur" +
                    "ned as the correct type (int/byte/etc), but box back to the typed enum\r\n        " +
                    "        return r =>\r\n                {\r\n                    var val = r.GetValue" +
                    "(index);\r\n                    return val is DBNull ? null : Enum.ToObject(effect" +
                    "iveType, val);\r\n                };\r\n            }\r\n            return r =>\r\n    " +
                    "        {\r\n                var val = r.GetValue(index);\r\n                return " +
                    "val is DBNull ? null : val;\r\n            };\r\n        }\r\n\r\n        static readonl" +
                    "y MethodInfo\r\n                    enumParse = typeof(Enum).GetMethod(\"Parse\", ne" +
                    "w Type[] { typeof(Type), typeof(string), typeof(bool) }),\r\n                    g" +
                    "etItem = typeof(IDataRecord).GetProperties(BindingFlags.Instance | BindingFlags." +
                    "Public)\r\n                        .Where(p => p.GetIndexParameters().Any() && p.G" +
                    "etIndexParameters()[0].ParameterType == typeof(int))\r\n                        .S" +
                    "elect(p => p.GetGetMethod()).First();\r\n\r\n        /// <summary>\r\n        /// Gets" +
                    " type-map for the given type\r\n        /// </summary>\r\n        /// <returns>Type " +
                    "map implementation, DefaultTypeMap instance if no override present</returns>\r\n  " +
                    "      public static ITypeMap GetTypeMap(Type type)\r\n        {\r\n            if (t" +
                    "ype == null) throw new ArgumentNullException(\"type\");\r\n            var map = (IT" +
                    "ypeMap)_typeMaps[type];\r\n            if (map == null)\r\n            {\r\n          " +
                    "      lock (_typeMaps)\r\n                {   // double-checked; store this to avo" +
                    "id reflection next time we see this type\r\n                    // since multiple " +
                    "queries commonly use the same domain-entity/DTO/view-model type\r\n               " +
                    "     map = (ITypeMap)_typeMaps[type];\r\n                    if (map == null)\r\n   " +
                    "                 {\r\n                        map = new DefaultTypeMap(type);\r\n   " +
                    "                     _typeMaps[type] = map;\r\n                    }\r\n            " +
                    "    }\r\n            }\r\n            return map;\r\n        }\r\n\r\n        // use Hasht" +
                    "able to get free lockless reading\r\n        private static readonly Hashtable _ty" +
                    "peMaps = new Hashtable();\r\n\r\n        /// <summary>\r\n        /// Set custom mappi" +
                    "ng for type deserializers\r\n        /// </summary>\r\n        /// <param name=\"type" +
                    "\">Entity type to override</param>\r\n        /// <param name=\"map\">Mapping rules i" +
                    "mpementation, null to remove custom map</param>\r\n        public static void SetT" +
                    "ypeMap(Type type, ITypeMap map)\r\n        {\r\n            if (type == null)\r\n     " +
                    "           throw new ArgumentNullException(\"type\");\r\n\r\n            if (map == nu" +
                    "ll || map is DefaultTypeMap)\r\n            {\r\n                lock (_typeMaps)\r\n " +
                    "               {\r\n                    _typeMaps.Remove(type);\r\n                }" +
                    "\r\n            }\r\n            else\r\n            {\r\n                lock (_typeMap" +
                    "s)\r\n                {\r\n                    _typeMaps[type] = map;\r\n             " +
                    "   }\r\n            }\r\n\r\n            PurgeQueryCacheByType(type);\r\n        }\r\n\r\n  " +
                    "      /// <summary>\r\n        /// Internal use only\r\n        /// </summary>\r\n    " +
                    "    /// <param name=\"type\"></param>\r\n        /// <param name=\"reader\"></param>\r\n" +
                    "        /// <param name=\"startBound\"></param>\r\n        /// <param name=\"length\">" +
                    "</param>\r\n        /// <param name=\"returnNullIfFirstMissing\"></param>\r\n        /" +
                    "// <returns></returns>\r\n        public static Func<IDataReader, object> GetTypeD" +
                    "eserializer(\r\n#if CSHARP30\r\n        Type type, IDataReader reader, int startBoun" +
                    "d, int length, bool returnNullIfFirstMissing\r\n#else\r\nType type, IDataReader read" +
                    "er, int startBound = 0, int length = -1, bool returnNullIfFirstMissing = false\r\n" +
                    "#endif\r\n)\r\n        {\r\n\r\n            var dm = new DynamicMethod(string.Format(\"De" +
                    "serialize{0}\", Guid.NewGuid()), typeof(object), new[] { typeof(IDataReader) }, t" +
                    "rue);\r\n            var il = dm.GetILGenerator();\r\n            il.DeclareLocal(ty" +
                    "peof(int));\r\n            il.DeclareLocal(type);\r\n            il.Emit(OpCodes.Ldc" +
                    "_I4_0);\r\n            il.Emit(OpCodes.Stloc_0);\r\n\r\n            if (length == -1)\r" +
                    "\n            {\r\n                length = reader.FieldCount - startBound;\r\n      " +
                    "      }\r\n\r\n            if (reader.FieldCount <= startBound)\r\n            {\r\n    " +
                    "            throw new ArgumentException(\"When using the multi-mapping APIs ensur" +
                    "e you set the splitOn param if you have keys other than Id\", \"splitOn\");\r\n      " +
                    "      }\r\n\r\n            var names = Enumerable.Range(startBound, length).Select(i" +
                    " => reader.GetName(i)).ToArray();\r\n\r\n            ITypeMap typeMap = GetTypeMap(t" +
                    "ype);\r\n\r\n            int index = startBound;\r\n\r\n            ConstructorInfo spec" +
                    "ializedConstructor = null;\r\n\r\n            if (type.IsValueType)\r\n            {\r\n" +
                    "                il.Emit(OpCodes.Ldloca_S, (byte)1);\r\n                il.Emit(OpC" +
                    "odes.Initobj, type);\r\n            }\r\n            else\r\n            {\r\n          " +
                    "      var types = new Type[length];\r\n                for (int i = startBound; i " +
                    "< startBound + length; i++)\r\n                {\r\n                    types[i - st" +
                    "artBound] = reader.GetFieldType(i);\r\n                }\r\n\r\n                if (ty" +
                    "pe.IsValueType)\r\n                {\r\n                    il.Emit(OpCodes.Ldloca_S" +
                    ", (byte)1);\r\n                    il.Emit(OpCodes.Initobj, type);\r\n              " +
                    "  }\r\n                else\r\n                {\r\n                    var ctor = typ" +
                    "eMap.FindConstructor(names, types);\r\n                    if (ctor == null)\r\n    " +
                    "                {\r\n                        string proposedTypes = \"(\" + String.J" +
                    "oin(\", \", types.Select((t, i) => t.FullName + \" \" + names[i]).ToArray()) + \")\";\r" +
                    "\n                        throw new InvalidOperationException(String.Format(\"A pa" +
                    "rameterless default constructor or one matching signature {0} is required for {1" +
                    "} materialization\", proposedTypes, type.FullName));\r\n                    }\r\n\r\n  " +
                    "                  if (ctor.GetParameters().Length == 0)\r\n                    {\r\n" +
                    "                        il.Emit(OpCodes.Newobj, ctor);\r\n                        " +
                    "il.Emit(OpCodes.Stloc_1);\r\n                    }\r\n                    else\r\n    " +
                    "                    specializedConstructor = ctor;\r\n                }\r\n         " +
                    "   }\r\n\r\n            il.BeginExceptionBlock();\r\n            if (type.IsValueType)" +
                    "\r\n            {\r\n                il.Emit(OpCodes.Ldloca_S, (byte)1);// [target]\r" +
                    "\n            }\r\n            else if (specializedConstructor == null)\r\n          " +
                    "  {\r\n                il.Emit(OpCodes.Ldloc_1);// [target]\r\n            }\r\n\r\n    " +
                    "        var members = (specializedConstructor != null\r\n                ? names.S" +
                    "elect(n => typeMap.GetConstructorParameter(specializedConstructor, n))\r\n        " +
                    "        : names.Select(n => typeMap.GetMember(n))).ToList();\r\n\r\n            // s" +
                    "tack is now [target]\r\n\r\n            bool first = true;\r\n            var allDone " +
                    "= il.DefineLabel();\r\n            int enumDeclareLocal = -1;\r\n            foreach" +
                    " (var item in members)\r\n            {\r\n                if (item != null)\r\n      " +
                    "          {\r\n                    if (specializedConstructor == null)\r\n          " +
                    "              il.Emit(OpCodes.Dup); // stack is now [target][target]\r\n          " +
                    "          Label isDbNullLabel = il.DefineLabel();\r\n                    Label fin" +
                    "ishLabel = il.DefineLabel();\r\n\r\n                    il.Emit(OpCodes.Ldarg_0); //" +
                    " stack is now [target][target][reader]\r\n                    EmitInt32(il, index)" +
                    "; // stack is now [target][target][reader][index]\r\n                    il.Emit(O" +
                    "pCodes.Dup);// stack is now [target][target][reader][index][index]\r\n            " +
                    "        il.Emit(OpCodes.Stloc_0);// stack is now [target][target][reader][index]" +
                    "\r\n                    il.Emit(OpCodes.Callvirt, getItem); // stack is now [targe" +
                    "t][target][value-as-object]\r\n\r\n                    Type memberType = item.Member" +
                    "Type;\r\n\r\n                    if (memberType == typeof(char) || memberType == typ" +
                    "eof(char?))\r\n                    {\r\n                        il.EmitCall(OpCodes." +
                    "Call, typeof(SqlMapper).GetMethod(\r\n                            memberType == ty" +
                    "peof(char) ? \"ReadChar\" : \"ReadNullableChar\", BindingFlags.Static | BindingFlags" +
                    ".Public), null); // stack is now [target][target][typed-value]\r\n                " +
                    "    }\r\n                    else\r\n                    {\r\n                        " +
                    "il.Emit(OpCodes.Dup); // stack is now [target][target][value][value]\r\n          " +
                    "              il.Emit(OpCodes.Isinst, typeof(DBNull)); // stack is now [target][" +
                    "target][value-as-object][DBNull or null]\r\n                        il.Emit(OpCode" +
                    "s.Brtrue_S, isDbNullLabel); // stack is now [target][target][value-as-object]\r\n\r" +
                    "\n                        // unbox nullable enums as the primitive, i.e. byte etc" +
                    "\r\n\r\n                        var nullUnderlyingType = Nullable.GetUnderlyingType(" +
                    "memberType);\r\n                        var unboxType = nullUnderlyingType != null" +
                    " && nullUnderlyingType.IsEnum ? nullUnderlyingType : memberType;\r\n\r\n            " +
                    "            if (unboxType.IsEnum)\r\n                        {\r\n                  " +
                    "          if (enumDeclareLocal == -1)\r\n                            {\r\n          " +
                    "                      enumDeclareLocal = il.DeclareLocal(typeof(string)).LocalIn" +
                    "dex;\r\n                            }\r\n\r\n                            Label isNotSt" +
                    "ring = il.DefineLabel();\r\n                            il.Emit(OpCodes.Dup); // s" +
                    "tack is now [target][target][value][value]\r\n                            il.Emit(" +
                    "OpCodes.Isinst, typeof(string)); // stack is now [target][target][value-as-objec" +
                    "t][string or null]\r\n                            il.Emit(OpCodes.Dup);// stack is" +
                    " now [target][target][value-as-object][string or null][string or null]\r\n        " +
                    "                    StoreLocal(il, enumDeclareLocal); // stack is now [target][t" +
                    "arget][value-as-object][string or null]\r\n                            il.Emit(OpC" +
                    "odes.Brfalse_S, isNotString); // stack is now [target][target][value-as-object]\r" +
                    "\n\r\n                            il.Emit(OpCodes.Pop); // stack is now [target][ta" +
                    "rget]\r\n\r\n                            il.Emit(OpCodes.Ldtoken, unboxType); // sta" +
                    "ck is now [target][target][enum-type-token]\r\n                            il.Emit" +
                    "Call(OpCodes.Call, typeof(Type).GetMethod(\"GetTypeFromHandle\"), null);// stack i" +
                    "s now [target][target][enum-type]\r\n                            il.Emit(OpCodes.L" +
                    "dloc_2); // stack is now [target][target][enum-type][string]\r\n                  " +
                    "          il.Emit(OpCodes.Ldc_I4_1); // stack is now [target][target][enum-type]" +
                    "[string][true]\r\n                            il.EmitCall(OpCodes.Call, enumParse," +
                    " null); // stack is now [target][target][enum-as-object]\r\n\r\n                    " +
                    "        il.MarkLabel(isNotString);\r\n\r\n                            il.Emit(OpCode" +
                    "s.Unbox_Any, unboxType); // stack is now [target][target][typed-value]\r\n\r\n      " +
                    "                      if (nullUnderlyingType != null)\r\n                         " +
                    "   {\r\n                                il.Emit(OpCodes.Newobj, memberType.GetCons" +
                    "tructor(new[] { nullUnderlyingType })); // stack is now [target][target][enum-va" +
                    "lue]\r\n                            }\r\n                        }\r\n                " +
                    "        else if (memberType.FullName == LinqBinary)\r\n                        {\r\n" +
                    "                            il.Emit(OpCodes.Unbox_Any, typeof(byte[])); // stack" +
                    " is now [target][target][byte-array]\r\n                            il.Emit(OpCode" +
                    "s.Newobj, memberType.GetConstructor(new Type[] { typeof(byte[]) }));// stack is " +
                    "now [target][target][binary]\r\n                        }\r\n                       " +
                    " else\r\n                        {\r\n                            Type dataType = re" +
                    "ader.GetFieldType(index);\r\n                            TypeCode dataTypeCode = T" +
                    "ype.GetTypeCode(dataType), unboxTypeCode = Type.GetTypeCode(unboxType);\r\n       " +
                    "                     if (dataType == unboxType || dataTypeCode == unboxTypeCode " +
                    "|| dataTypeCode == Type.GetTypeCode(nullUnderlyingType))\r\n                      " +
                    "      {\r\n                                il.Emit(OpCodes.Unbox_Any, unboxType); " +
                    "// stack is now [target][target][typed-value]\r\n                            }\r\n  " +
                    "                          else\r\n                            {\r\n                 " +
                    "               // not a direct match; need to tweak the unbox\r\n                 " +
                    "               bool handled = true;\r\n                                OpCode opCo" +
                    "de = default(OpCode);\r\n                                if (dataTypeCode == TypeC" +
                    "ode.Decimal || unboxTypeCode == TypeCode.Decimal)\r\n                             " +
                    "   {   // no IL level conversions to/from decimal; I guess we could use the stat" +
                    "ic operators, but\r\n                                    // this feels an edge-cas" +
                    "e\r\n                                    handled = false;\r\n                       " +
                    "         }\r\n                                else\r\n                              " +
                    "  {\r\n                                    switch (unboxTypeCode)\r\n               " +
                    "                     {\r\n                                        case TypeCode.By" +
                    "te:\r\n                                            opCode = OpCodes.Conv_Ovf_I1_Un" +
                    "; break;\r\n                                        case TypeCode.SByte:\r\n        " +
                    "                                    opCode = OpCodes.Conv_Ovf_I1; break;\r\n      " +
                    "                                  case TypeCode.UInt16:\r\n                       " +
                    "                     opCode = OpCodes.Conv_Ovf_I2_Un; break;\r\n                  " +
                    "                      case TypeCode.Int16:\r\n                                    " +
                    "        opCode = OpCodes.Conv_Ovf_I2; break;\r\n                                  " +
                    "      case TypeCode.UInt32:\r\n                                            opCode " +
                    "= OpCodes.Conv_Ovf_I4_Un; break;\r\n                                        case T" +
                    "ypeCode.Boolean: // boolean is basically an int, at least at this level\r\n       " +
                    "                                 case TypeCode.Int32:\r\n                         " +
                    "                   opCode = OpCodes.Conv_Ovf_I4; break;\r\n                       " +
                    "                 case TypeCode.UInt64:\r\n                                        " +
                    "    opCode = OpCodes.Conv_Ovf_I8_Un; break;\r\n                                   " +
                    "     case TypeCode.Int64:\r\n                                            opCode = " +
                    "OpCodes.Conv_Ovf_I8; break;\r\n                                        case TypeCo" +
                    "de.Single:\r\n                                            opCode = OpCodes.Conv_R4" +
                    "; break;\r\n                                        case TypeCode.Double:\r\n       " +
                    "                                     opCode = OpCodes.Conv_R8; break;\r\n         " +
                    "                               default:\r\n                                       " +
                    "     handled = false;\r\n                                            break;\r\n     " +
                    "                               }\r\n                                }\r\n           " +
                    "                     if (handled)\r\n                                { // unbox as" +
                    " the data-type, then use IL-level convert\r\n                                    i" +
                    "l.Emit(OpCodes.Unbox_Any, dataType); // stack is now [target][target][data-typed" +
                    "-value]\r\n                                    il.Emit(opCode); // stack is now [t" +
                    "arget][target][typed-value]\r\n                                    if (unboxTypeCo" +
                    "de == TypeCode.Boolean)\r\n                                    { // compare to zer" +
                    "o; I checked \"csc\" - this is the trick it uses; nice\r\n                          " +
                    "              il.Emit(OpCodes.Ldc_I4_0);\r\n                                      " +
                    "  il.Emit(OpCodes.Ceq);\r\n                                        il.Emit(OpCodes" +
                    ".Ldc_I4_0);\r\n                                        il.Emit(OpCodes.Ceq);\r\n    " +
                    "                                }\r\n                                }\r\n          " +
                    "                      else\r\n                                { // use flexible co" +
                    "nversion\r\n                                    il.Emit(OpCodes.Ldtoken, unboxType" +
                    "); // stack is now [target][target][value][member-type-token]\r\n                 " +
                    "                   il.EmitCall(OpCodes.Call, typeof(Type).GetMethod(\"GetTypeFrom" +
                    "Handle\"), null); // stack is now [target][target][value][member-type]\r\n         " +
                    "                           il.EmitCall(OpCodes.Call, typeof(Convert).GetMethod(\"" +
                    "ChangeType\", new Type[] { typeof(object), typeof(Type) }), null); // stack is no" +
                    "w [target][target][boxed-member-type-value]\r\n                                   " +
                    " il.Emit(OpCodes.Unbox_Any, unboxType); // stack is now [target][target][typed-v" +
                    "alue]\r\n                                }\r\n\r\n                            }\r\n\r\n   " +
                    "                     }\r\n                    }\r\n                    if (specializ" +
                    "edConstructor == null)\r\n                    {\r\n                        // Store " +
                    "the value in the property/field\r\n                        if (item.Property != nu" +
                    "ll)\r\n                        {\r\n                            if (type.IsValueType" +
                    ")\r\n                            {\r\n                                il.Emit(OpCode" +
                    "s.Call, DefaultTypeMap.GetPropertySetter(item.Property, type)); // stack is now " +
                    "[target]\r\n                            }\r\n                            else\r\n     " +
                    "                       {\r\n                                il.Emit(OpCodes.Callvi" +
                    "rt, DefaultTypeMap.GetPropertySetter(item.Property, type)); // stack is now [tar" +
                    "get]\r\n                            }\r\n                        }\r\n                " +
                    "        else\r\n                        {\r\n                            il.Emit(OpC" +
                    "odes.Stfld, item.Field); // stack is now [target]\r\n                        }\r\n  " +
                    "                  }\r\n\r\n                    il.Emit(OpCodes.Br_S, finishLabel); /" +
                    "/ stack is now [target]\r\n\r\n                    il.MarkLabel(isDbNullLabel); // i" +
                    "ncoming stack: [target][target][value]\r\n                    if (specializedConst" +
                    "ructor != null)\r\n                    {\r\n                        il.Emit(OpCodes." +
                    "Pop);\r\n                        if (item.MemberType.IsValueType)\r\n               " +
                    "         {\r\n                            int localIndex = il.DeclareLocal(item.Me" +
                    "mberType).LocalIndex;\r\n                            LoadLocalAddress(il, localInd" +
                    "ex);\r\n                            il.Emit(OpCodes.Initobj, item.MemberType);\r\n  " +
                    "                          LoadLocal(il, localIndex);\r\n                        }\r" +
                    "\n                        else\r\n                        {\r\n                      " +
                    "      il.Emit(OpCodes.Ldnull);\r\n                        }\r\n                    }" +
                    "\r\n                    else\r\n                    {\r\n                        il.Em" +
                    "it(OpCodes.Pop); // stack is now [target][target]\r\n                        il.Em" +
                    "it(OpCodes.Pop); // stack is now [target]\r\n                    }\r\n\r\n            " +
                    "        if (first && returnNullIfFirstMissing)\r\n                    {\r\n         " +
                    "               il.Emit(OpCodes.Pop);\r\n                        il.Emit(OpCodes.Ld" +
                    "null); // stack is now [null]\r\n                        il.Emit(OpCodes.Stloc_1);" +
                    "\r\n                        il.Emit(OpCodes.Br, allDone);\r\n                    }\r\n" +
                    "\r\n                    il.MarkLabel(finishLabel);\r\n                }\r\n           " +
                    "     first = false;\r\n                index += 1;\r\n            }\r\n            if " +
                    "(type.IsValueType)\r\n            {\r\n                il.Emit(OpCodes.Pop);\r\n      " +
                    "      }\r\n            else\r\n            {\r\n                if (specializedConstru" +
                    "ctor != null)\r\n                {\r\n                    il.Emit(OpCodes.Newobj, sp" +
                    "ecializedConstructor);\r\n                }\r\n                il.Emit(OpCodes.Stloc" +
                    "_1); // stack is empty\r\n            }\r\n            il.MarkLabel(allDone);\r\n     " +
                    "       il.BeginCatchBlock(typeof(Exception)); // stack is Exception\r\n           " +
                    " il.Emit(OpCodes.Ldloc_0); // stack is Exception, index\r\n            il.Emit(OpC" +
                    "odes.Ldarg_0); // stack is Exception, index, reader\r\n            il.EmitCall(OpC" +
                    "odes.Call, typeof(SqlMapper).GetMethod(\"ThrowDataException\"), null);\r\n          " +
                    "  il.EndExceptionBlock();\r\n\r\n            il.Emit(OpCodes.Ldloc_1); // stack is [" +
                    "rval]\r\n            if (type.IsValueType)\r\n            {\r\n                il.Emit" +
                    "(OpCodes.Box, type);\r\n            }\r\n            il.Emit(OpCodes.Ret);\r\n\r\n      " +
                    "      return (Func<IDataReader, object>)dm.CreateDelegate(typeof(Func<IDataReade" +
                    "r, object>));\r\n        }\r\n\r\n        private static void LoadLocal(ILGenerator il" +
                    ", int index)\r\n        {\r\n            if (index < 0 || index >= short.MaxValue) t" +
                    "hrow new ArgumentNullException(\"index\");\r\n            switch (index)\r\n          " +
                    "  {\r\n                case 0: il.Emit(OpCodes.Ldloc_0); break;\r\n                c" +
                    "ase 1: il.Emit(OpCodes.Ldloc_1); break;\r\n                case 2: il.Emit(OpCodes" +
                    ".Ldloc_2); break;\r\n                case 3: il.Emit(OpCodes.Ldloc_3); break;\r\n   " +
                    "             default:\r\n                    if (index <= 255)\r\n                  " +
                    "  {\r\n                        il.Emit(OpCodes.Ldloc_S, (byte)index);\r\n           " +
                    "         }\r\n                    else\r\n                    {\r\n                   " +
                    "     il.Emit(OpCodes.Ldloc, (short)index);\r\n                    }\r\n             " +
                    "       break;\r\n            }\r\n        }\r\n        private static void StoreLocal(" +
                    "ILGenerator il, int index)\r\n        {\r\n            if (index < 0 || index >= sho" +
                    "rt.MaxValue) throw new ArgumentNullException(\"index\");\r\n            switch (inde" +
                    "x)\r\n            {\r\n                case 0: il.Emit(OpCodes.Stloc_0); break;\r\n   " +
                    "             case 1: il.Emit(OpCodes.Stloc_1); break;\r\n                case 2: i" +
                    "l.Emit(OpCodes.Stloc_2); break;\r\n                case 3: il.Emit(OpCodes.Stloc_3" +
                    "); break;\r\n                default:\r\n                    if (index <= 255)\r\n    " +
                    "                {\r\n                        il.Emit(OpCodes.Stloc_S, (byte)index)" +
                    ";\r\n                    }\r\n                    else\r\n                    {\r\n     " +
                    "                   il.Emit(OpCodes.Stloc, (short)index);\r\n                    }\r" +
                    "\n                    break;\r\n            }\r\n        }\r\n        private static vo" +
                    "id LoadLocalAddress(ILGenerator il, int index)\r\n        {\r\n            if (index" +
                    " < 0 || index >= short.MaxValue) throw new ArgumentNullException(\"index\");\r\n\r\n  " +
                    "          if (index <= 255)\r\n            {\r\n                il.Emit(OpCodes.Ldlo" +
                    "ca_S, (byte)index);\r\n            }\r\n            else\r\n            {\r\n           " +
                    "     il.Emit(OpCodes.Ldloca, (short)index);\r\n            }\r\n        }\r\n        /" +
                    "// <summary>\r\n        /// Throws a data exception, only used internally\r\n       " +
                    " /// </summary>\r\n        /// <param name=\"ex\"></param>\r\n        /// <param name=" +
                    "\"index\"></param>\r\n        /// <param name=\"reader\"></param>\r\n        public stat" +
                    "ic void ThrowDataException(Exception ex, int index, IDataReader reader)\r\n       " +
                    " {\r\n            Exception toThrow;\r\n            try\r\n            {\r\n            " +
                    "    string name = \"(n/a)\", value = \"(n/a)\";\r\n                if (reader != null " +
                    "&& index >= 0 && index < reader.FieldCount)\r\n                {\r\n                " +
                    "    name = reader.GetName(index);\r\n                    object val = reader.GetVa" +
                    "lue(index);\r\n                    if (val == null || val is DBNull)\r\n            " +
                    "        {\r\n                        value = \"<null>\";\r\n                    }\r\n   " +
                    "                 else\r\n                    {\r\n                        value = Co" +
                    "nvert.ToString(val) + \" - \" + Type.GetTypeCode(val.GetType());\r\n                " +
                    "    }\r\n                }\r\n                toThrow = new DataException(string.For" +
                    "mat(\"Error parsing column {0} ({1}={2})\", index, name, value), ex);\r\n           " +
                    " }\r\n            catch\r\n            { // throw the **original** exception, wrappe" +
                    "d as DataException\r\n                toThrow = new DataException(ex.Message, ex);" +
                    "\r\n            }\r\n            throw toThrow;\r\n        }\r\n        private static v" +
                    "oid EmitInt32(ILGenerator il, int value)\r\n        {\r\n            switch (value)\r" +
                    "\n            {\r\n                case -1: il.Emit(OpCodes.Ldc_I4_M1); break;\r\n   " +
                    "             case 0: il.Emit(OpCodes.Ldc_I4_0); break;\r\n                case 1: " +
                    "il.Emit(OpCodes.Ldc_I4_1); break;\r\n                case 2: il.Emit(OpCodes.Ldc_I" +
                    "4_2); break;\r\n                case 3: il.Emit(OpCodes.Ldc_I4_3); break;\r\n       " +
                    "         case 4: il.Emit(OpCodes.Ldc_I4_4); break;\r\n                case 5: il.E" +
                    "mit(OpCodes.Ldc_I4_5); break;\r\n                case 6: il.Emit(OpCodes.Ldc_I4_6)" +
                    "; break;\r\n                case 7: il.Emit(OpCodes.Ldc_I4_7); break;\r\n           " +
                    "     case 8: il.Emit(OpCodes.Ldc_I4_8); break;\r\n                default:\r\n      " +
                    "              if (value >= -128 && value <= 127)\r\n                    {\r\n       " +
                    "                 il.Emit(OpCodes.Ldc_I4_S, (sbyte)value);\r\n                    }" +
                    "\r\n                    else\r\n                    {\r\n                        il.Em" +
                    "it(OpCodes.Ldc_I4, value);\r\n                    }\r\n                    break;\r\n " +
                    "           }\r\n        }\r\n\r\n        /// <summary>\r\n        /// The grid reader pr" +
                    "ovides interfaces for reading multiple result sets from a Dapper query \r\n       " +
                    " /// </summary>\r\n        public partial class GridReader : IDisposable\r\n        " +
                    "{\r\n            private IDataReader reader;\r\n            private IDbCommand comma" +
                    "nd;\r\n            private Identity identity;\r\n\r\n            internal GridReader(I" +
                    "DbCommand command, IDataReader reader, Identity identity)\r\n            {\r\n      " +
                    "          this.command = command;\r\n                this.reader = reader;\r\n      " +
                    "          this.identity = identity;\r\n            }\r\n\r\n#if !CSHARP30\r\n\r\n         " +
                    "   /// <summary>\r\n            /// Read the next grid of results, returned as a d" +
                    "ynamic object\r\n            /// </summary>\r\n            public IEnumerable<dynami" +
                    "c> Read(bool buffered = true)\r\n            {\r\n                return Read<Dapper" +
                    "Row>(buffered);\r\n            }\r\n#endif\r\n\r\n#if CSHARP30\r\n        /// <summary>\r\n " +
                    "       /// Read the next grid of results\r\n        /// </summary>\r\n        public" +
                    " IEnumerable<T> Read<T>()\r\n        {\r\n            return Read<T>(true);\r\n       " +
                    " }\r\n#endif\r\n            /// <summary>\r\n            /// Read the next grid of res" +
                    "ults\r\n            /// </summary>\r\n#if CSHARP30\r\n        public IEnumerable<T> Re" +
                    "ad<T>(bool buffered)\r\n#else\r\n            public IEnumerable<T> Read<T>(bool buff" +
                    "ered = true)\r\n#endif\r\n            {\r\n                if (reader == null) throw n" +
                    "ew ObjectDisposedException(GetType().FullName, \"The reader has been disposed; th" +
                    "is can happen after all data has been consumed\");\r\n                if (consumed)" +
                    " throw new InvalidOperationException(\"Query results must be consumed in the corr" +
                    "ect order, and each result can only be consumed once\");\r\n                var typ" +
                    "edIdentity = identity.ForGrid(typeof(T), gridIndex);\r\n                CacheInfo " +
                    "cache = GetCacheInfo(typedIdentity);\r\n                var deserializer = cache.D" +
                    "eserializer;\r\n\r\n                int hash = GetColumnHash(reader);\r\n             " +
                    "   if (deserializer.Func == null || deserializer.Hash != hash)\r\n                " +
                    "{\r\n                    deserializer = new DeserializerState(hash, GetDeserialize" +
                    "r(typeof(T), reader, 0, -1, false));\r\n                    cache.Deserializer = d" +
                    "eserializer;\r\n                }\r\n                consumed = true;\r\n             " +
                    "   var result = ReadDeferred<T>(gridIndex, deserializer.Func, typedIdentity);\r\n " +
                    "               return buffered ? result.ToList() : result;\r\n            }\r\n\r\n   " +
                    "         private IEnumerable<TReturn> MultiReadInternal<TFirst, TSecond, TThird," +
                    " TFourth, TFifth, TReturn>(object func, string splitOn)\r\n            {\r\n        " +
                    "        var identity = this.identity.ForGrid(typeof(TReturn), new Type[] {\r\n    " +
                    "            typeof(TFirst),\r\n                typeof(TSecond),\r\n                t" +
                    "ypeof(TThird),\r\n                typeof(TFourth),\r\n                typeof(TFifth)" +
                    "\r\n            }, gridIndex);\r\n                try\r\n                {\r\n          " +
                    "          foreach (var r in SqlMapper.MultiMapImpl<TFirst, TSecond, TThird, TFou" +
                    "rth, TFifth, TReturn>(null, null, func, null, null, splitOn, null, null, reader," +
                    " identity))\r\n                    {\r\n                        yield return r;\r\n   " +
                    "                 }\r\n                }\r\n                finally\r\n                " +
                    "{\r\n                    NextResult();\r\n                }\r\n            }\r\n\r\n#if CS" +
                    "HARP30\r\n        /// <summary>\r\n        /// Read multiple objects from a single r" +
                    "ecordset on the grid\r\n        /// </summary>\r\n        public IEnumerable<TReturn" +
                    "> Read<TFirst, TSecond, TReturn>(Func<TFirst, TSecond, TReturn> func, string spl" +
                    "itOn)\r\n        {\r\n            return Read<TFirst, TSecond, TReturn>(func, splitO" +
                    "n, true);\r\n        }\r\n#endif\r\n            /// <summary>\r\n            /// Read mu" +
                    "ltiple objects from a single recordset on the grid\r\n            /// </summary>\r\n" +
                    "#if CSHARP30\r\n        public IEnumerable<TReturn> Read<TFirst, TSecond, TReturn>" +
                    "(Func<TFirst, TSecond, TReturn> func, string splitOn, bool buffered)\r\n#else\r\n   " +
                    "         public IEnumerable<TReturn> Read<TFirst, TSecond, TReturn>(Func<TFirst," +
                    " TSecond, TReturn> func, string splitOn = \"id\", bool buffered = true)\r\n#endif\r\n " +
                    "           {\r\n                var result = MultiReadInternal<TFirst, TSecond, Do" +
                    "ntMap, DontMap, DontMap, TReturn>(func, splitOn);\r\n                return buffer" +
                    "ed ? result.ToList() : result;\r\n            }\r\n\r\n#if CSHARP30\r\n        /// <summ" +
                    "ary>\r\n        /// Read multiple objects from a single recordset on the grid\r\n   " +
                    "     /// </summary>\r\n        public IEnumerable<TReturn> Read<TFirst, TSecond, T" +
                    "Third, TReturn>(Func<TFirst, TSecond, TThird, TReturn> func, string splitOn)\r\n  " +
                    "      {\r\n            return Read<TFirst, TSecond, TThird, TReturn>(func, splitOn" +
                    ", true);\r\n        }\r\n#endif\r\n            /// <summary>\r\n            /// Read mul" +
                    "tiple objects from a single recordset on the grid\r\n            /// </summary>\r\n#" +
                    "if CSHARP30\r\n        public IEnumerable<TReturn> Read<TFirst, TSecond, TThird, T" +
                    "Return>(Func<TFirst, TSecond, TThird, TReturn> func, string splitOn, bool buffer" +
                    "ed)\r\n#else\r\n            public IEnumerable<TReturn> Read<TFirst, TSecond, TThird" +
                    ", TReturn>(Func<TFirst, TSecond, TThird, TReturn> func, string splitOn = \"id\", b" +
                    "ool buffered = true)\r\n#endif\r\n            {\r\n                var result = MultiR" +
                    "eadInternal<TFirst, TSecond, TThird, DontMap, DontMap, TReturn>(func, splitOn);\r" +
                    "\n                return buffered ? result.ToList() : result;\r\n            }\r\n\r\n#" +
                    "if CSHARP30\r\n        /// <summary>\r\n        /// Read multiple objects from a sin" +
                    "gle record set on the grid\r\n        /// </summary>\r\n        public IEnumerable<T" +
                    "Return> Read<TFirst, TSecond, TThird, TFourth, TReturn>(Func<TFirst, TSecond, TT" +
                    "hird, TFourth, TReturn> func, string splitOn)\r\n        {\r\n            return Rea" +
                    "d<TFirst, TSecond, TThird, TFourth, TReturn>(func, splitOn, true);\r\n        }\r\n#" +
                    "endif\r\n\r\n            /// <summary>\r\n            /// Read multiple objects from a" +
                    " single record set on the grid\r\n            /// </summary>\r\n#if CSHARP30\r\n      " +
                    "  public IEnumerable<TReturn> Read<TFirst, TSecond, TThird, TFourth, TReturn>(Fu" +
                    "nc<TFirst, TSecond, TThird, TFourth, TReturn> func, string splitOn, bool buffere" +
                    "d)\r\n#else\r\n            public IEnumerable<TReturn> Read<TFirst, TSecond, TThird," +
                    " TFourth, TReturn>(Func<TFirst, TSecond, TThird, TFourth, TReturn> func, string " +
                    "splitOn = \"id\", bool buffered = true)\r\n#endif\r\n            {\r\n                va" +
                    "r result = MultiReadInternal<TFirst, TSecond, TThird, TFourth, DontMap, TReturn>" +
                    "(func, splitOn);\r\n                return buffered ? result.ToList() : result;\r\n " +
                    "           }\r\n\r\n\r\n\r\n#if !CSHARP30\r\n            /// <summary>\r\n            /// Re" +
                    "ad multiple objects from a single record set on the grid\r\n            /// </summ" +
                    "ary>\r\n            public IEnumerable<TReturn> Read<TFirst, TSecond, TThird, TFou" +
                    "rth, TFifth, TReturn>(Func<TFirst, TSecond, TThird, TFourth, TFifth, TReturn> fu" +
                    "nc, string splitOn = \"id\", bool buffered = true)\r\n            {\r\n               " +
                    " var result = MultiReadInternal<TFirst, TSecond, TThird, TFourth, TFifth, TRetur" +
                    "n>(func, splitOn);\r\n                return buffered ? result.ToList() : result;\r" +
                    "\n            }\r\n#endif\r\n\r\n            private IEnumerable<T> ReadDeferred<T>(int" +
                    " index, Func<IDataReader, object> deserializer, Identity typedIdentity)\r\n       " +
                    "     {\r\n                try\r\n                {\r\n                    while (index" +
                    " == gridIndex && reader.Read())\r\n                    {\r\n                        " +
                    "yield return (T)deserializer(reader);\r\n                    }\r\n                }\r" +
                    "\n                finally // finally so that First etc progresses things even whe" +
                    "n multiple rows\r\n                {\r\n                    if (index == gridIndex)\r" +
                    "\n                    {\r\n                        NextResult();\r\n                 " +
                    "   }\r\n                }\r\n            }\r\n            private int gridIndex, readC" +
                    "ount;\r\n            private bool consumed;\r\n            private void NextResult()" +
                    "\r\n            {\r\n                if (reader.NextResult())\r\n                {\r\n  " +
                    "                  readCount++;\r\n                    gridIndex++;\r\n              " +
                    "      consumed = false;\r\n                }\r\n                else\r\n              " +
                    "  {\r\n                    // happy path; close the reader cleanly - no\r\n         " +
                    "           // need for \"Cancel\" etc\r\n                    reader.Dispose();\r\n    " +
                    "                reader = null;\r\n\r\n                    Dispose();\r\n              " +
                    "  }\r\n\r\n            }\r\n            /// <summary>\r\n            /// Dispose the gri" +
                    "d, closing and disposing both the underlying reader and command.\r\n            //" +
                    "/ </summary>\r\n            public void Dispose()\r\n            {\r\n                " +
                    "if (reader != null)\r\n                {\r\n                    if (!reader.IsClosed" +
                    " && command != null) command.Cancel();\r\n                    reader.Dispose();\r\n " +
                    "                   reader = null;\r\n                }\r\n                if (comman" +
                    "d != null)\r\n                {\r\n                    command.Dispose();\r\n         " +
                    "           command = null;\r\n                }\r\n            }\r\n        }\r\n    }\r\n" +
                    "\r\n}");
            return this.GenerationEnvironment.ToString();
        }
    }
    
    #line default
    #line hidden
    #region Base class
    /// <summary>
    /// Base class for this transformation
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "14.0.0.0")]
    public class SqlMapperBase
    {
        #region Fields
        private global::System.Text.StringBuilder generationEnvironmentField;
        private global::System.CodeDom.Compiler.CompilerErrorCollection errorsField;
        private global::System.Collections.Generic.List<int> indentLengthsField;
        private string currentIndentField = "";
        private bool endsWithNewline;
        private global::System.Collections.Generic.IDictionary<string, object> sessionField;
        #endregion
        #region Properties
        /// <summary>
        /// The string builder that generation-time code is using to assemble generated output
        /// </summary>
        protected System.Text.StringBuilder GenerationEnvironment
        {
            get
            {
                if ((this.generationEnvironmentField == null))
                {
                    this.generationEnvironmentField = new global::System.Text.StringBuilder();
                }
                return this.generationEnvironmentField;
            }
            set
            {
                this.generationEnvironmentField = value;
            }
        }
        /// <summary>
        /// The error collection for the generation process
        /// </summary>
        public System.CodeDom.Compiler.CompilerErrorCollection Errors
        {
            get
            {
                if ((this.errorsField == null))
                {
                    this.errorsField = new global::System.CodeDom.Compiler.CompilerErrorCollection();
                }
                return this.errorsField;
            }
        }
        /// <summary>
        /// A list of the lengths of each indent that was added with PushIndent
        /// </summary>
        private System.Collections.Generic.List<int> indentLengths
        {
            get
            {
                if ((this.indentLengthsField == null))
                {
                    this.indentLengthsField = new global::System.Collections.Generic.List<int>();
                }
                return this.indentLengthsField;
            }
        }
        /// <summary>
        /// Gets the current indent we use when adding lines to the output
        /// </summary>
        public string CurrentIndent
        {
            get
            {
                return this.currentIndentField;
            }
        }
        /// <summary>
        /// Current transformation session
        /// </summary>
        public virtual global::System.Collections.Generic.IDictionary<string, object> Session
        {
            get
            {
                return this.sessionField;
            }
            set
            {
                this.sessionField = value;
            }
        }
        #endregion
        #region Transform-time helpers
        /// <summary>
        /// Write text directly into the generated output
        /// </summary>
        public void Write(string textToAppend)
        {
            if (string.IsNullOrEmpty(textToAppend))
            {
                return;
            }
            // If we're starting off, or if the previous text ended with a newline,
            // we have to append the current indent first.
            if (((this.GenerationEnvironment.Length == 0) 
                        || this.endsWithNewline))
            {
                this.GenerationEnvironment.Append(this.currentIndentField);
                this.endsWithNewline = false;
            }
            // Check if the current text ends with a newline
            if (textToAppend.EndsWith(global::System.Environment.NewLine, global::System.StringComparison.CurrentCulture))
            {
                this.endsWithNewline = true;
            }
            // This is an optimization. If the current indent is "", then we don't have to do any
            // of the more complex stuff further down.
            if ((this.currentIndentField.Length == 0))
            {
                this.GenerationEnvironment.Append(textToAppend);
                return;
            }
            // Everywhere there is a newline in the text, add an indent after it
            textToAppend = textToAppend.Replace(global::System.Environment.NewLine, (global::System.Environment.NewLine + this.currentIndentField));
            // If the text ends with a newline, then we should strip off the indent added at the very end
            // because the appropriate indent will be added when the next time Write() is called
            if (this.endsWithNewline)
            {
                this.GenerationEnvironment.Append(textToAppend, 0, (textToAppend.Length - this.currentIndentField.Length));
            }
            else
            {
                this.GenerationEnvironment.Append(textToAppend);
            }
        }
        /// <summary>
        /// Write text directly into the generated output
        /// </summary>
        public void WriteLine(string textToAppend)
        {
            this.Write(textToAppend);
            this.GenerationEnvironment.AppendLine();
            this.endsWithNewline = true;
        }
        /// <summary>
        /// Write formatted text directly into the generated output
        /// </summary>
        public void Write(string format, params object[] args)
        {
            this.Write(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
        }
        /// <summary>
        /// Write formatted text directly into the generated output
        /// </summary>
        public void WriteLine(string format, params object[] args)
        {
            this.WriteLine(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
        }
        /// <summary>
        /// Raise an error
        /// </summary>
        public void Error(string message)
        {
            System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
            error.ErrorText = message;
            this.Errors.Add(error);
        }
        /// <summary>
        /// Raise a warning
        /// </summary>
        public void Warning(string message)
        {
            System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
            error.ErrorText = message;
            error.IsWarning = true;
            this.Errors.Add(error);
        }
        /// <summary>
        /// Increase the indent
        /// </summary>
        public void PushIndent(string indent)
        {
            if ((indent == null))
            {
                throw new global::System.ArgumentNullException("indent");
            }
            this.currentIndentField = (this.currentIndentField + indent);
            this.indentLengths.Add(indent.Length);
        }
        /// <summary>
        /// Remove the last indent that was added with PushIndent
        /// </summary>
        public string PopIndent()
        {
            string returnValue = "";
            if ((this.indentLengths.Count > 0))
            {
                int indentLength = this.indentLengths[(this.indentLengths.Count - 1)];
                this.indentLengths.RemoveAt((this.indentLengths.Count - 1));
                if ((indentLength > 0))
                {
                    returnValue = this.currentIndentField.Substring((this.currentIndentField.Length - indentLength));
                    this.currentIndentField = this.currentIndentField.Remove((this.currentIndentField.Length - indentLength));
                }
            }
            return returnValue;
        }
        /// <summary>
        /// Remove any indentation
        /// </summary>
        public void ClearIndent()
        {
            this.indentLengths.Clear();
            this.currentIndentField = "";
        }
        #endregion
        #region ToString Helpers
        /// <summary>
        /// Utility class to produce culture-oriented representation of an object as a string.
        /// </summary>
        public class ToStringInstanceHelper
        {
            private System.IFormatProvider formatProviderField  = global::System.Globalization.CultureInfo.InvariantCulture;
            /// <summary>
            /// Gets or sets format provider to be used by ToStringWithCulture method.
            /// </summary>
            public System.IFormatProvider FormatProvider
            {
                get
                {
                    return this.formatProviderField ;
                }
                set
                {
                    if ((value != null))
                    {
                        this.formatProviderField  = value;
                    }
                }
            }
            /// <summary>
            /// This is called from the compile/run appdomain to convert objects within an expression block to a string
            /// </summary>
            public string ToStringWithCulture(object objectToConvert)
            {
                if ((objectToConvert == null))
                {
                    throw new global::System.ArgumentNullException("objectToConvert");
                }
                System.Type t = objectToConvert.GetType();
                System.Reflection.MethodInfo method = t.GetMethod("ToString", new System.Type[] {
                            typeof(System.IFormatProvider)});
                if ((method == null))
                {
                    return objectToConvert.ToString();
                }
                else
                {
                    return ((string)(method.Invoke(objectToConvert, new object[] {
                                this.formatProviderField })));
                }
            }
        }
        private ToStringInstanceHelper toStringHelperField = new ToStringInstanceHelper();
        /// <summary>
        /// Helper to produce culture-oriented representation of an object as a string
        /// </summary>
        public ToStringInstanceHelper ToStringHelper
        {
            get
            {
                return this.toStringHelperField;
            }
        }
        #endregion
    }
    #endregion
}
