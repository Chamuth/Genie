// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 14.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace Genie.Templates.Dapper
{
    using Genie.Base;
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    
    #line 1 "D:\Projects\Genie\Genie\Templates\Dapper\SqlMapperExtensions.tt"
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "14.0.0.0")]
    public partial class SqlMapperExtensions : SqlMapperExtensionsBase
    {
#line hidden
        /// <summary>
        /// Create the template output
        /// </summary>
        public virtual string TransformText()
        {
            this.Write("using System;\r\nusing System.Collections.Concurrent;\r\nusing System.Collections.Gen" +
                    "eric;\r\nusing System.Data;\r\nusing System.Linq;\r\nusing System.Reflection;\r\nusing S" +
                    "ystem.Reflection.Emit;\r\nusing System.Text;\r\nusing System.Threading;\r\nusing ");
            
            #line 12 "D:\Projects\Genie\Genie\Templates\Dapper\SqlMapperExtensions.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(GenerationContext.BaseNamespace));
            
            #line default
            #line hidden
            this.Write(".Infrastructure.Enum;\r\nusing ");
            
            #line 13 "D:\Projects\Genie\Genie\Templates\Dapper\SqlMapperExtensions.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(GenerationContext.BaseNamespace));
            
            #line default
            #line hidden
            this.Write(".Infrastructure.Models;\r\n\r\nnamespace ");
            
            #line 15 "D:\Projects\Genie\Genie\Templates\Dapper\SqlMapperExtensions.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(GenerationContext.BaseNamespace));
            
            #line default
            #line hidden
            this.Write(".Dapper\r\n{\r\n\tpublic static class SqlMapperExtensions\r\n    {\r\n        public inter" +
                    "face IProxy\r\n        {\r\n            bool IsDirty { get; set; }\r\n        }\r\n\r\n\r\n " +
                    "       public class SqlWhereOrderCache\r\n        {\r\n            public string Sql" +
                    " { get; set; }\r\n            public IEnumerable<string> Where { get; set; }\r\n    " +
                    "        public IEnumerable<string> Order { get; set; }\r\n        }\r\n\r\n        pri" +
                    "vate static readonly ConcurrentDictionary<RuntimeTypeHandle, IEnumerable<Propert" +
                    "yInfo>> KeyProperties = new ConcurrentDictionary<RuntimeTypeHandle, IEnumerable<" +
                    "PropertyInfo>>();\r\n        private static readonly ConcurrentDictionary<RuntimeT" +
                    "ypeHandle, IEnumerable<PropertyInfo>> TypeProperties = new ConcurrentDictionary<" +
                    "RuntimeTypeHandle, IEnumerable<PropertyInfo>>();\r\n        private static readonl" +
                    "y ConcurrentDictionary<RuntimeTypeHandle, string> GetQueries = new ConcurrentDic" +
                    "tionary<RuntimeTypeHandle, string>();\r\n        private static readonly Concurren" +
                    "tDictionary<RuntimeTypeHandle, string> TypeTableName = new ConcurrentDictionary<" +
                    "RuntimeTypeHandle, string>();\r\n        private static readonly ConcurrentDiction" +
                    "ary<RuntimeTypeHandle, string> GetQueriesAll = new ConcurrentDictionary<RuntimeT" +
                    "ypeHandle, string>();\r\n        private static readonly ConcurrentDictionary<int," +
                    " SqlWhereOrderCache> GetQueriesWhereOrder = new ConcurrentDictionary<int, SqlWhe" +
                    "reOrderCache>();\r\n\r\n\r\n        private static readonly Dictionary<string, ISqlAda" +
                    "pter> AdapterDictionary = new Dictionary<string, ISqlAdapter>() {\r\n             " +
                    "                                                                           {\"sql" +
                    "connection\", new SqlServerAdapter()},\r\n                                         " +
                    "                                               {\"npgsqlconnection\", new Postgres" +
                    "Adapter()}\r\n                                                                    " +
                    "                };\r\n\r\n        private static IEnumerable<PropertyInfo> KeyProper" +
                    "tiesCache(Type type)\r\n        {\r\n\r\n            IEnumerable<PropertyInfo> pi;\r\n  " +
                    "          if (KeyProperties.TryGetValue(type.TypeHandle, out pi))\r\n            {" +
                    "\r\n                return pi;\r\n            }\r\n\r\n            var allProperties = T" +
                    "ypePropertiesCache(type);\r\n            var keyProperties = allProperties.Where(p" +
                    " => p.GetCustomAttributes(true).Any(a => a is KeyAttribute)).ToList();\r\n\r\n      " +
                    "      if (keyProperties.Count == 0)\r\n            {\r\n                var idProp =" +
                    " allProperties.Where(p => p.Name.ToLower() == \"id\").FirstOrDefault();\r\n         " +
                    "       if (idProp != null)\r\n                {\r\n                    keyProperties" +
                    ".Add(idProp);\r\n                }\r\n            }\r\n\r\n            KeyProperties[typ" +
                    "e.TypeHandle] = keyProperties;\r\n            return keyProperties;\r\n        }\r\n  " +
                    "      private static IEnumerable<PropertyInfo> TypePropertiesCache(Type type)\r\n " +
                    "       {\r\n            IEnumerable<PropertyInfo> pis;\r\n            if (TypeProper" +
                    "ties.TryGetValue(type.TypeHandle, out pis))\r\n            {\r\n                retu" +
                    "rn pis;\r\n            }\r\n\r\n            var properties = type.GetProperties().Wher" +
                    "e(IsWriteable);\r\n            TypeProperties[type.TypeHandle] = properties;\r\n    " +
                    "        return properties;\r\n        }\r\n\r\n        public static bool IsWriteable(" +
                    "PropertyInfo pi)\r\n        {\r\n            object[] attributes = pi.GetCustomAttri" +
                    "butes(typeof(WriteAttribute), false);\r\n            if (attributes.Length == 1)\r\n" +
                    "            {\r\n                WriteAttribute write = (WriteAttribute)attributes" +
                    "[0];\r\n                return write.Write;\r\n            }\r\n            return tru" +
                    "e;\r\n        }\r\n\r\n\r\n        /// <summary>\r\n        /// </summary>\r\n        /// <t" +
                    "ypeparam name=\"T\">Interface type to create and populate</typeparam>\r\n        ///" +
                    " <param name=\"connection\">Open SqlConnection</param>\r\n        /// <param name=\"t" +
                    "ransaction\"></param>\r\n        /// <param name=\"commandTimeout\"></param>\r\n       " +
                    " /// <returns>Entity of T</returns>\r\n        public static IEnumerable<T> GetAll" +
                    "<T>(this IDbConnection connection, IDbTransaction transaction = null, int? comma" +
                    "ndTimeout = null) where T : class\r\n        {\r\n            var type = typeof(T);\r" +
                    "\n            string sql;\r\n            if (!GetQueriesAll.TryGetValue(type.TypeHa" +
                    "ndle, out sql))\r\n            {\r\n                var name = GetTableName(type);\r\n" +
                    "\r\n                // TODO: pluralizer \r\n                // TODO: query informati" +
                    "on schema and only select fields that are both in information schema and underly" +
                    "ing class / interface \r\n                sql = string.Format(\"select * from {0}\"," +
                    " name);\r\n                GetQueriesAll[type.TypeHandle] = sql;\r\n            }\r\n\r" +
                    "\n            IEnumerable<T> obj = null;\r\n\r\n            if (type.IsInterface)\r\n  " +
                    "          {\r\n                var res = connection.Query(sql);\r\n                i" +
                    "f (!res.Any())\r\n                    return (IEnumerable<T>)((object)null);\r\n    " +
                    "            var objList = new List<T>();\r\n                foreach (var item in r" +
                    "es)\r\n                {\r\n                    T objItem = ProxyGenerator.GetInterf" +
                    "aceProxy<T>();\r\n\r\n                    foreach (var property in TypePropertiesCac" +
                    "he(type))\r\n                    {\r\n                        var val = item[propert" +
                    "y.Name];\r\n                        property.SetValue(objItem, val, null);\r\n      " +
                    "              }\r\n\r\n                    ((IProxy)objItem).IsDirty = false;   //re" +
                    "set change tracking and return   \r\n                    objList.Add(objItem);\r\n  " +
                    "              }\r\n                obj = objList.AsEnumerable();\r\n            }\r\n " +
                    "           else\r\n            {\r\n                obj = connection.Query<T>(sql, t" +
                    "ransaction: transaction, commandTimeout: commandTimeout);\r\n            }\r\n      " +
                    "      return obj;\r\n        }\r\n\r\n        /// <summary>\r\n        /// </summary>\r\n " +
                    "       /// <typeparam name=\"T\">Interface type to create and populate</typeparam>" +
                    "\r\n        /// <param name=\"connection\">Open SqlConnection</param>\r\n        /// <" +
                    "param name=\"where\"></param>\r\n        /// <param name=\"order\"></param>\r\n\t    /// " +
                    "<param name=\"pageSize\">Size of the page </param>\r\n\t    /// <param name=\"page\">pa" +
                    "ge if paging is required</param>\r\n        /// <returns>Entity of T</returns>\r\n  " +
                    "      public static IEnumerable<T> GetBy<T>(this IDbConnection connection, objec" +
                    "t where = null, object order = null, int? pageSize = null, int? page = null, IDb" +
                    "Transaction transaction = null, int? commandTimeout = null, bool first = false) " +
                    "where T : class\r\n        {\r\n            var type = typeof(T);\r\n            var i" +
                    "sUseWhere = where != null;\r\n            var isUseOrder = order != null;\r\n       " +
                    "     if (!isUseWhere && !isUseOrder)\r\n            {\r\n                return GetA" +
                    "ll<T>(connection, transaction, commandTimeout);\r\n            }\r\n            var " +
                    "whereType = isUseWhere ? where.GetType() : null;\r\n            var orderType = is" +
                    "UseOrder ? order.GetType() : null;\r\n            SqlWhereOrderCache cache;\r\n     " +
                    "       var key = GetKeyTypeWhereOrder(type, whereType, orderType);\r\n            " +
                    "if (!GetQueriesWhereOrder.TryGetValue(key, out cache))\r\n            {\r\n         " +
                    "       cache = new SqlWhereOrderCache();\r\n                if (isUseWhere)\r\n     " +
                    "           {\r\n                    cache.Where = GetListOfNames(whereType.GetProp" +
                    "erties());\r\n                }\r\n                if (isUseOrder)\r\n                " +
                    "{\r\n                    cache.Order = GetListOfNames(orderType.GetProperties());\r" +
                    "\n                }\r\n                var name = GetTableName(type);\r\n            " +
                    "    var sb = new StringBuilder();\r\n                sb.AppendFormat(\"select {1} *" +
                    " from {0}\", name, first ? \"top 1\" : \"\");\r\n                int cnt, last, i;\r\n   " +
                    "             if (isUseWhere)\r\n                {\r\n                    sb.Append(\"" +
                    " where \");\r\n                    cnt = cache.Where.Count();\r\n                    " +
                    "last = cnt - 1;\r\n                    for (i = 0; i < cnt; i++)\r\n                " +
                    "    {\r\n                        var prop = cache.Where.ElementAt(i);\r\n           " +
                    "             sb.AppendFormat(\"[{0}]=@{1}\", prop, prop);\r\n                       " +
                    " if (i != last)\r\n                        {\r\n                            sb.Appen" +
                    "d(\" and \");\r\n                        }\r\n\r\n                    }\r\n               " +
                    " }\r\n                if (isUseOrder)\r\n                {\r\n                    sb.A" +
                    "ppend(\" order by \");\r\n                    cnt = cache.Order.Count();\r\n          " +
                    "          last = cnt - 1;\r\n                    for (i = 0; i < cnt; i++)\r\n      " +
                    "              {\r\n                        var prop = cache.Order.ElementAt(i);\r\n " +
                    "                       sb.AppendFormat(\"[{0}] #{1}\", prop, prop);\r\n             " +
                    "           if (i != last)\r\n                        {\r\n                          " +
                    "  sb.Append(\", \");\r\n                        }\r\n                    }\r\n          " +
                    "      }\r\n\r\n                // Paging required\r\n                if (page != null " +
                    "&& pageSize != null)\r\n                {\r\n                    sb.Append(string.Fo" +
                    "rmat(\" OFFSET ({0}) ROWS \" +\r\n                                            \" FETC" +
                    "H NEXT {1} ROWS ONLY \", page * pageSize, pageSize));\r\n                }\r\n\r\n     " +
                    "           cache.Sql = sb.ToString();\r\n                GetQueriesWhereOrder[key]" +
                    " = cache;\r\n            }\r\n\r\n            IEnumerable<T> obj;\r\n            var dyn" +
                    "Parms = new DynamicParameters();\r\n            if (isUseWhere)\r\n            {\r\n  " +
                    "              foreach (var name in cache.Where)\r\n                {\r\n            " +
                    "        dynParms.Add(name, whereType.GetProperty(name).GetValue(where, null));\r\n" +
                    "                }\r\n            }\r\n            if (isUseOrder)\r\n            {\r\n  " +
                    "              foreach (var name in cache.Order)\r\n                {\r\n            " +
                    "        var enumVal = (SortAs)orderType.GetProperty(name).GetValue(order, null);" +
                    "\r\n                    switch (enumVal)\r\n                    {\r\n                 " +
                    "       case SortAs.Asc:\r\n                            cache.Sql = cache.Sql.Repla" +
                    "ce(\"#\" + name, \"ASC\");\r\n                            break;\r\n                    " +
                    "    case SortAs.Desc:\r\n                            cache.Sql = cache.Sql.Replace" +
                    "(\"#\" + name, \"DESC\");\r\n                            break;\r\n                     " +
                    "   default:\r\n                            throw new ArgumentOutOfRangeException()" +
                    ";\r\n                    }\r\n                }\r\n            }\r\n            if (type" +
                    ".IsInterface)\r\n            {\r\n                var res = connection.Query(cache.S" +
                    "ql);\r\n                if (!res.Any())\r\n                    return (IEnumerable<T" +
                    ">)((object)null);\r\n                var objList = new List<T>();\r\n               " +
                    " foreach (var item in res)\r\n                {\r\n                    T objItem = P" +
                    "roxyGenerator.GetInterfaceProxy<T>();\r\n\r\n                    foreach (var proper" +
                    "ty in TypePropertiesCache(type))\r\n                    {\r\n                       " +
                    " var val = item[property.Name];\r\n                        property.SetValue(objIt" +
                    "em, val, null);\r\n                    }\r\n\r\n                    ((IProxy)objItem)." +
                    "IsDirty = false;   //reset change tracking and return   \r\n                    ob" +
                    "jList.Add(objItem);\r\n                }\r\n                obj = objList.AsEnumerab" +
                    "le();\r\n            }\r\n            else\r\n            {\r\n                obj = con" +
                    "nection.Query<T>(cache.Sql, dynParms, transaction: transaction, commandTimeout: " +
                    "commandTimeout);\r\n            }\r\n            return obj;\r\n        }\r\n\r\n\r\n       " +
                    " /// <summary>\r\n        /// Returns a single entity by a single id from table \"T" +
                    "s\". T must be of interface type. \r\n        /// Id must be marked with [Key] attr" +
                    "ibute.\r\n        /// Created entity is tracked/intercepted for changes and used b" +
                    "y the Update() extension. \r\n        /// </summary>\r\n        /// <typeparam name=" +
                    "\"T\">Interface type to create and populate</typeparam>\r\n        /// <param name=\"" +
                    "connection\">Open SqlConnection</param>\r\n        /// <param name=\"id\">Id of the e" +
                    "ntity to get, must be marked with [Key] attribute</param>\r\n        /// <returns>" +
                    "Entity of T</returns>\r\n        public static T Get<T>(this IDbConnection connect" +
                    "ion, dynamic id, IDbTransaction transaction = null, int? commandTimeout = null) " +
                    "where T : BaseModel\r\n        {\r\n            var type = typeof(T);\r\n            s" +
                    "tring sql;\r\n            if (!GetQueries.TryGetValue(type.TypeHandle, out sql))\r\n" +
                    "            {\r\n                var keys = KeyPropertiesCache(type);\r\n           " +
                    "     if (keys.Count() > 1)\r\n                    throw new DataException(\"Get<T> " +
                    "only supports an entity with a single [Key] property\");\r\n                if (key" +
                    "s.Count() == 0)\r\n                    throw new DataException(\"Get<T> only suppor" +
                    "ts en entity with a [Key] property\");\r\n\r\n                var onlyKey = keys.Firs" +
                    "t();\r\n\r\n                var name = GetTableName(type);\r\n\r\n                // TOD" +
                    "O: pluralizer \r\n                // TODO: query information schema and only selec" +
                    "t fields that are both in information schema and underlying class / interface \r\n" +
                    "                sql = \"select * from \" + name + \" where [\" + onlyKey.Name + \"] =" +
                    " @id\";\r\n                GetQueries[type.TypeHandle] = sql;\r\n            }\r\n\r\n   " +
                    "         var dynParms = new DynamicParameters();\r\n            dynParms.Add(\"@id\"" +
                    ", id);\r\n\r\n            T obj = null;\r\n\r\n            if (type.IsInterface)\r\n      " +
                    "      {\r\n                var res = connection.Query(sql, dynParms).FirstOrDefaul" +
                    "t() as IDictionary<string, object>;\r\n\r\n                if (res == null)\r\n       " +
                    "             return (T)((object)null);\r\n\r\n                obj = ProxyGenerator.G" +
                    "etInterfaceProxy<T>();\r\n\r\n                foreach (var property in TypePropertie" +
                    "sCache(type))\r\n                {\r\n                    var val = res[property.Nam" +
                    "e];\r\n                    property.SetValue(obj, val, null);\r\n                }\r\n" +
                    "\r\n                ((IProxy)obj).IsDirty = false;   //reset change tracking and r" +
                    "eturn\r\n            }\r\n            else\r\n            {\r\n                obj = con" +
                    "nection.Query<T>(sql, dynParms, transaction: transaction, commandTimeout: comman" +
                    "dTimeout).FirstOrDefault();\r\n            }\r\n            return obj;\r\n        }\r\n" +
                    "\r\n\t     /// <summary>\r\n\t    /// Return all  \r\n\t    /// </summary>\r\n\t    /// <typ" +
                    "eparam name=\"T\">Interface type to create and populate</typeparam>\r\n\t    /// <par" +
                    "am name=\"connection\">Open SqlConnection</param>\r\n\t    /// <param name=\"target\"><" +
                    "/param>\r\n\t    /// <param name=\"where\"></param>\r\n\t    /// <param name=\"order\"></p" +
                    "aram>\r\n\t    /// <param name=\"limit\"></param>\r\n\t    /// <param name=\"tramTransact" +
                    "ion\"></param>\r\n\t    /// <param name=\"pageSize\"></param>\r\n\t    /// <param name=\"p" +
                    "age\"></param>\r\n\t    /// <returns>Entity of T</returns>\r\n\t    public static IEnum" +
                    "erable<T> Get<T>(this IDbConnection connection, string target, Queue<string> whe" +
                    "re, Queue<string> order, int? pageSize = null, int? page = null, int? limit = nu" +
                    "ll, int? skip = null, int? take = null, IDbTransaction tramTransaction = null, b" +
                    "ool isCount = false )\r\n        {\r\n\t        return connection.Query<T>(GetRetrive" +
                    "Query(target, where, order, pageSize, page, limit, skip, take), transaction: tra" +
                    "mTransaction);\r\n        }\r\n\r\n\r\n        /// <summary>\r\n\t    /// Returns count of " +
                    "rows\r\n\t    /// </summary>\r\n\t    /// <typeparam name=\"T\">Interface type to create" +
                    " and populate</typeparam>\r\n\t    /// <param name=\"connection\">Open SqlConnection<" +
                    "/param>\r\n\t    /// <param name=\"target\"></param>\r\n\t    /// <param name=\"where\"></" +
                    "param>\r\n\t    /// <param name=\"order\"></param>\r\n\t    /// <param name=\"limit\"></pa" +
                    "ram>\r\n\t    /// <param name=\"tramTransaction\"></param>\r\n\t    /// <param name=\"pag" +
                    "eSize\"></param>\r\n\t    /// <param name=\"page\"></param>\r\n\t    /// <returns>Entity " +
                    "of T</returns>\r\n\t    public static int Count(this IDbConnection connection, stri" +
                    "ng target, Queue<string> where, Queue<string> order, int? pageSize = null, int? " +
                    "page = null, int? limit = null, int? skip = null, int? take = null, IDbTransacti" +
                    "on tramTransaction = null)\r\n        {\r\n            return connection.Query<int>(" +
                    "GetRetriveQuery(target, where, order, pageSize, page, limit, skip, take, true), " +
                    "transaction: tramTransaction).FirstOrDefault();\r\n        }\r\n\r\n\r\n\t    private sta" +
                    "tic string GetRetriveQuery(string target, Queue<string> where, Queue<string> ord" +
                    "er, int? pageSize = null, int? page = null, int? limit = null, int? skip = null," +
                    " int? take = null, bool isCount = false)\r\n\t    {\r\n            var queryBuilder =" +
                    " new StringBuilder(string.Format(\"select {0} {1} from \" + target, limit != null " +
                    "? \" top \" + limit : \"\", isCount ? \"count(*)\" : \"*\"));\r\n            \r\n           " +
                    " if (where != null && where.Count > 0)\r\n            {\r\n                queryBuil" +
                    "der.Append(\" where \");\r\n\r\n                var first = true;\r\n                var" +
                    " previous = \"\";\r\n\r\n                while (where.Count > 0)\r\n                {\r\n " +
                    "                   var current = where.Dequeue();\r\n\r\n                    if (And" +
                    "OrOr(current))\r\n                    {\r\n                        if (first)\r\n     " +
                    "                   {\r\n                            first = false;\r\n              " +
                    "              continue;\r\n                        }\r\n\r\n                        if" +
                    " (AndOrOr(previous))\r\n                        {\r\n                            fir" +
                    "st = false;\r\n                            continue;\r\n                        }\r\n\r" +
                    "\n                        previous = current;\r\n                        queryBuild" +
                    "er.Append(string.Format(\" {0} \", current));\r\n                    }\r\n            " +
                    "        else\r\n                    {\r\n                        if (!first && !AndO" +
                    "rOr(previous))\r\n                        {\r\n                            queryBuil" +
                    "der.Append(string.Format(\" {0} \", \"and\"));\r\n                        }\r\n\r\n       " +
                    "                 previous = current;\r\n                        queryBuilder.Appen" +
                    "d(string.Format(\" {0} \", current));\r\n                    }\r\n\r\n                  " +
                    "  first = false;\r\n                }\r\n            }\r\n\r\n            if (order != n" +
                    "ull && order.Count > 0)\r\n            {\r\n                queryBuilder.Append(\" or" +
                    "der by \");\r\n                while (order.Count > 0)\r\n                {\r\n        " +
                    "            var item = order.Dequeue();\r\n                    queryBuilder.Append" +
                    "(string.Format(\" {0} \", item));\r\n                }\r\n            }\r\n\r\n           " +
                    " if (page != null && pageSize != null)\r\n            {\r\n                queryBuil" +
                    "der.Append(string.Format(\" OFFSET ({0}) ROWS \" +\r\n                              " +
                    "             \" FETCH NEXT {1} ROWS ONLY \", page * pageSize, pageSize));\r\n       " +
                    "     }\r\n            else\r\n            {\r\n                if (skip != null)\r\n    " +
                    "                queryBuilder.Append(string.Format(\" OFFSET ({0}) ROWS \", skip));" +
                    "\r\n\r\n                if (take != null)\r\n                    queryBuilder.Append(s" +
                    "tring.Format(\" FETCH NEXT {0} ROWS ONLY \", take));\r\n            }\r\n\r\n\t        re" +
                    "turn queryBuilder.ToString();\r\n\t    }\r\n\r\n        private static bool AndOrOr(str" +
                    "ing str)\r\n\t    {\r\n\t        return str == \"and\" || str == \"or\";\r\n\t    }\r\n\r\n\r\n\r\n  " +
                    "      private static int GetKeyTypeWhereOrder(Type type, Type where, Type order)" +
                    "\r\n        {\r\n            var handler = type.TypeHandle;\r\n            string wher" +
                    "eCondition = @where != null ? @where.TypeHandle.Value.ToString() : string.Empty;" +
                    "\r\n            string orderCondition = order != null ? order.TypeHandle.Value.ToS" +
                    "tring() : string.Empty; ;\r\n            var str = string.Format(\"{0}{1}{2}\", hand" +
                    "ler.Value, whereCondition, orderCondition);\r\n            return str.GetHashCode(" +
                    ");\r\n        }\r\n\r\n        private static IEnumerable<string> GetListOfNames(Prope" +
                    "rtyInfo[] list)\r\n        {\r\n            List<string> lst = new List<string>();\r\n" +
                    "            foreach (PropertyInfo info in list)\r\n            {\r\n                " +
                    "lst.Add(info.Name);\r\n            }\r\n            return lst.AsEnumerable();\r\n    " +
                    "    }\r\n\r\n        private static string GetTableName(Type type)\r\n        {\r\n     " +
                    "       string name;\r\n            if (!TypeTableName.TryGetValue(type.TypeHandle," +
                    " out name))\r\n            {\r\n                name = type.Name + \"s\";\r\n           " +
                    "     if (type.IsInterface && name.StartsWith(\"I\"))\r\n                    name = n" +
                    "ame.Substring(1);\r\n\r\n                //NOTE: This as dynamic trick should be abl" +
                    "e to handle both our own Table-attribute as well as the one in EntityFramework \r" +
                    "\n                var tableattr = type.GetCustomAttributes(false).Where(attr => a" +
                    "ttr.GetType().Name == \"TableAttribute\").SingleOrDefault() as\r\n                  " +
                    "  dynamic;\r\n                if (tableattr != null)\r\n                    name = t" +
                    "ableattr.Name;\r\n                TypeTableName[type.TypeHandle] = name;\r\n        " +
                    "    }\r\n            return name;\r\n        }\r\n\r\n        /// <summary>\r\n        ///" +
                    " Inserts an entity into table \"Ts\" and returns identity id.\r\n        /// </summa" +
                    "ry>\r\n        /// <param name=\"connection\">Open SqlConnection</param>\r\n        //" +
                    "/ <param name=\"entityToInsert\">Entity to insert</param>\r\n        /// <returns>Id" +
                    "entity of inserted entity</returns>\r\n        public static long Insert<T>(this I" +
                    "DbConnection connection, T entityToInsert, IDbTransaction transaction = null, in" +
                    "t? commandTimeout = null) where T : class\r\n        {\r\n\r\n            var type = t" +
                    "ypeof(T);\r\n\r\n            var name = GetTableName(type);\r\n\r\n            var sbCol" +
                    "umnList = new StringBuilder(null);\r\n\r\n            var allProperties = TypeProper" +
                    "tiesCache(type);\r\n            var keyProperties = KeyPropertiesCache(type);\r\n   " +
                    "         var allPropertiesExceptKey = allProperties.Except(keyProperties);\r\n\r\n  " +
                    "          for (var i = 0; i < allPropertiesExceptKey.Count(); i++)\r\n            " +
                    "{\r\n                var property = allPropertiesExceptKey.ElementAt(i);\r\n        " +
                    "        sbColumnList.AppendFormat(\"[{0}]\", property.Name);\r\n                if (" +
                    "i < allPropertiesExceptKey.Count() - 1)\r\n                    sbColumnList.Append" +
                    "(\", \");\r\n            }\r\n\r\n            var sbParameterList = new StringBuilder(nu" +
                    "ll);\r\n            for (var i = 0; i < allPropertiesExceptKey.Count(); i++)\r\n    " +
                    "        {\r\n                var property = allPropertiesExceptKey.ElementAt(i);\r\n" +
                    "                sbParameterList.AppendFormat(\"@{0}\", property.Name);\r\n          " +
                    "      if (i < allPropertiesExceptKey.Count() - 1)\r\n                    sbParamet" +
                    "erList.Append(\", \");\r\n            }\r\n            ISqlAdapter adapter = GetFormat" +
                    "ter(connection);\r\n            int id = adapter.Insert(connection, transaction, c" +
                    "ommandTimeout, name, sbColumnList.ToString(), sbParameterList.ToString(), keyPro" +
                    "perties, entityToInsert);\r\n            return id;\r\n        }\r\n\r\n        /// <sum" +
                    "mary>\r\n        /// Updates entity in table \"Ts\", checks if the entity is modifie" +
                    "d if the entity is tracked by the Get() extension.\r\n        /// </summary>\r\n    " +
                    "    /// <typeparam name=\"T\">Type to be updated</typeparam>\r\n        /// <param n" +
                    "ame=\"connection\">Open SqlConnection</param>\r\n        /// <param name=\"entityToUp" +
                    "date\">Entity to be updated</param>\r\n        /// <returns>true if updated, false " +
                    "if not found or not modified (tracked entities)</returns>\r\n        public static" +
                    " bool Update<T>(this IDbConnection connection, T entityToUpdate, IDbTransaction " +
                    "transaction = null, int? commandTimeout = null) where T : BaseModel\r\n        {\r\n" +
                    "            if (entityToUpdate.DatabaseModelStatus != ModelStatus.Retrieved)\r\n  " +
                    "              return false;\r\n\r\n            if (entityToUpdate.UpdatedProperties." +
                    "Count < 1)\r\n                return false;\r\n\r\n            var type = typeof(T);\r\n" +
                    "\r\n            var keyProperties = KeyPropertiesCache(type).ToList();\r\n          " +
                    "  if (!keyProperties.Any())\r\n                throw new ArgumentException(\"Entity" +
                    " must have at least one [Key] property\");\r\n\r\n            var name = GetTableName" +
                    "(type);\r\n\r\n            var sb = new StringBuilder();\r\n            sb.AppendForma" +
                    "t(\"update {0} set \", name);\r\n\r\n            var allProperties = TypePropertiesCac" +
                    "he(type);\r\n            var nonIdProps = allProperties.Where(a => !keyProperties." +
                    "Contains(a) && entityToUpdate.UpdatedProperties.Contains(a.Name)).ToList(); // O" +
                    "nly updated properties\r\n\r\n\r\n            for (var i = 0; i < nonIdProps.Count(); " +
                    "i++)\r\n            {\r\n                var property = nonIdProps.ElementAt(i);\r\n  " +
                    "              sb.AppendFormat(\"[{0}] = @{1}\", property.Name, property.Name);\r\n  " +
                    "              if (i < nonIdProps.Count() - 1)\r\n                    sb.AppendForm" +
                    "at(\", \");\r\n            }\r\n\r\n            sb.Append(\" where \");\r\n            for (" +
                    "var i = 0; i < keyProperties.Count(); i++)\r\n            {\r\n                var p" +
                    "roperty = keyProperties.ElementAt(i);\r\n                sb.AppendFormat(\"[{0}] = " +
                    "@{1}\", property.Name, property.Name);\r\n                if (i < keyProperties.Cou" +
                    "nt() - 1)\r\n                    sb.AppendFormat(\" and \");\r\n            }\r\n       " +
                    "     var updated = connection.Execute(sb.ToString(), entityToUpdate, commandTime" +
                    "out: commandTimeout, transaction: transaction);\r\n            return updated > 0;" +
                    "\r\n        }\r\n\r\n        /// <summary>\r\n        /// Delete entity in table \"Ts\".\r\n" +
                    "        /// </summary>\r\n        /// <typeparam name=\"T\">Type of entity</typepara" +
                    "m>\r\n        /// <param name=\"connection\">Open SqlConnection</param>\r\n        ///" +
                    " <param name=\"entityToDelete\">Entity to delete</param>\r\n        /// <returns>tru" +
                    "e if deleted, false if not found</returns>\r\n        public static bool Delete<T>" +
                    "(this IDbConnection connection, T entityToDelete, IDbTransaction transaction = n" +
                    "ull, int? commandTimeout = null) where T : BaseModel\r\n        {\r\n            if " +
                    "(entityToDelete == null)\r\n                throw new ArgumentException(\"Cannot De" +
                    "lete null Object\", \"entityToDelete\");\r\n\r\n            var type = typeof(T);\r\n\r\n  " +
                    "          var keyProperties = KeyPropertiesCache(type).ToList();\r\n\r\n            " +
                    "if (!keyProperties.Any())\r\n                throw new ArgumentException(\"Entity m" +
                    "ust have at least one [Key] property\");\r\n\r\n            var name = GetTableName(t" +
                    "ype);\r\n\r\n            var sb = new StringBuilder();\r\n            sb.AppendFormat(" +
                    "\"delete from {0} where \", name);\r\n\r\n            for (var i = 0; i < keyPropertie" +
                    "s.Count(); i++)\r\n            {\r\n                var property = keyProperties.Ele" +
                    "mentAt(i);\r\n                sb.AppendFormat(\"[{0}] = @{1}\", property.Name, prope" +
                    "rty.Name);\r\n                if (i < keyProperties.Count() - 1)\r\n                " +
                    "    sb.AppendFormat(\" and \");\r\n            }\r\n            var deleted = connecti" +
                    "on.Execute(sb.ToString(), entityToDelete, transaction: transaction, commandTimeo" +
                    "ut: commandTimeout) > 0;\r\n            if(deleted) { entityToDelete.DatabaseModel" +
                    "Status = ModelStatus.Deleted; }\r\n            return deleted;\r\n        }\r\n\r\n     " +
                    "   public static ISqlAdapter GetFormatter(IDbConnection connection)\r\n        {\r\n" +
                    "            string name = connection.GetType().Name.ToLower();\r\n            if (" +
                    "!AdapterDictionary.ContainsKey(name))\r\n                return new SqlServerAdapt" +
                    "er();\r\n            return AdapterDictionary[name];\r\n        }\r\n\r\n        class P" +
                    "roxyGenerator\r\n        {\r\n            private static readonly Dictionary<Type, o" +
                    "bject> TypeCache = new Dictionary<Type, object>();\r\n\r\n            private static" +
                    " AssemblyBuilder GetAsmBuilder(string name)\r\n            {\r\n                var " +
                    "assemblyBuilder = Thread.GetDomain().DefineDynamicAssembly(new AssemblyName { Na" +
                    "me = name },\r\n                    AssemblyBuilderAccess.Run);       //NOTE: to s" +
                    "ave, use RunAndSave\r\n\r\n                return assemblyBuilder;\r\n            }\r\n\r" +
                    "\n            public static T GetClassProxy<T>()\r\n            {\r\n                " +
                    "// A class proxy could be implemented if all properties are virtual\r\n           " +
                    "     //  otherwise there is a pretty dangerous case where internal actions will " +
                    "not update dirty tracking\r\n                throw new NotImplementedException();\r" +
                    "\n            }\r\n\r\n\r\n            public static T GetInterfaceProxy<T>()\r\n        " +
                    "    {\r\n                Type typeOfT = typeof(T);\r\n\r\n                object k;\r\n " +
                    "               if (TypeCache.TryGetValue(typeOfT, out k))\r\n                {\r\n  " +
                    "                  return (T)k;\r\n                }\r\n                var assemblyB" +
                    "uilder = GetAsmBuilder(typeOfT.Name);\r\n\r\n                var moduleBuilder = ass" +
                    "emblyBuilder.DefineDynamicModule(\"SqlMapperExtensions.\" + typeOfT.Name); //NOTE:" +
                    " to save, add \"asdasd.dll\" parameter\r\n\r\n                var interfaceType = type" +
                    "of(IProxy);\r\n                var typeBuilder = moduleBuilder.DefineType(typeOfT." +
                    "Name + \"_\" + Guid.NewGuid(),\r\n                    TypeAttributes.Public | TypeAt" +
                    "tributes.Class);\r\n                typeBuilder.AddInterfaceImplementation(typeOfT" +
                    ");\r\n                typeBuilder.AddInterfaceImplementation(interfaceType);\r\n\r\n  " +
                    "              //create our _isDirty field, which implements IProxy\r\n            " +
                    "    var setIsDirtyMethod = CreateIsDirtyProperty(typeBuilder);\r\n\r\n              " +
                    "  // Generate a field for each property, which implements the T\r\n               " +
                    " foreach (var property in typeof(T).GetProperties())\r\n                {\r\n       " +
                    "             var isId = property.GetCustomAttributes(true).Any(a => a is KeyAttr" +
                    "ibute);\r\n                    CreateProperty<T>(typeBuilder, property.Name, prope" +
                    "rty.PropertyType, setIsDirtyMethod, isId);\r\n                }\r\n\r\n               " +
                    " var generatedType = typeBuilder.CreateType();\r\n\r\n                //assemblyBuil" +
                    "der.Save(name + \".dll\");  //NOTE: to save, uncomment\r\n\r\n                var gene" +
                    "ratedObject = Activator.CreateInstance(generatedType);\r\n\r\n                TypeCa" +
                    "che.Add(typeOfT, generatedObject);\r\n                return (T)generatedObject;\r\n" +
                    "            }\r\n\r\n\r\n            private static MethodInfo CreateIsDirtyProperty(T" +
                    "ypeBuilder typeBuilder)\r\n            {\r\n                var propType = typeof(bo" +
                    "ol);\r\n                var field = typeBuilder.DefineField(\"_\" + \"IsDirty\", propT" +
                    "ype, FieldAttributes.Private);\r\n                var property = typeBuilder.Defin" +
                    "eProperty(\"IsDirty\",\r\n                                                System.Ref" +
                    "lection.PropertyAttributes.None,\r\n                                              " +
                    "  propType,\r\n                                                new Type[] { propTy" +
                    "pe });\r\n\r\n                const MethodAttributes getSetAttr = MethodAttributes.P" +
                    "ublic | MethodAttributes.NewSlot | MethodAttributes.SpecialName |\r\n             " +
                    "                                       MethodAttributes.Final | MethodAttributes" +
                    ".Virtual | MethodAttributes.HideBySig;\r\n\r\n                // Define the \"get\" an" +
                    "d \"set\" accessor methods\r\n                var currGetPropMthdBldr = typeBuilder." +
                    "DefineMethod(\"get_\" + \"IsDirty\",\r\n                                              " +
                    "  getSetAttr,\r\n                                                propType,\r\n      " +
                    "                                          Type.EmptyTypes);\r\n                var" +
                    " currGetIL = currGetPropMthdBldr.GetILGenerator();\r\n                currGetIL.Em" +
                    "it(OpCodes.Ldarg_0);\r\n                currGetIL.Emit(OpCodes.Ldfld, field);\r\n   " +
                    "             currGetIL.Emit(OpCodes.Ret);\r\n                var currSetPropMthdBl" +
                    "dr = typeBuilder.DefineMethod(\"set_\" + \"IsDirty\",\r\n                             " +
                    "                   getSetAttr,\r\n                                                " +
                    "null,\r\n                                                new Type[] { propType });" +
                    "\r\n                var currSetIL = currSetPropMthdBldr.GetILGenerator();\r\n       " +
                    "         currSetIL.Emit(OpCodes.Ldarg_0);\r\n                currSetIL.Emit(OpCode" +
                    "s.Ldarg_1);\r\n                currSetIL.Emit(OpCodes.Stfld, field);\r\n            " +
                    "    currSetIL.Emit(OpCodes.Ret);\r\n\r\n                property.SetGetMethod(currGe" +
                    "tPropMthdBldr);\r\n                property.SetSetMethod(currSetPropMthdBldr);\r\n  " +
                    "              var getMethod = typeof(IProxy).GetMethod(\"get_\" + \"IsDirty\");\r\n   " +
                    "             var setMethod = typeof(IProxy).GetMethod(\"set_\" + \"IsDirty\");\r\n    " +
                    "            typeBuilder.DefineMethodOverride(currGetPropMthdBldr, getMethod);\r\n " +
                    "               typeBuilder.DefineMethodOverride(currSetPropMthdBldr, setMethod);" +
                    "\r\n\r\n                return currSetPropMthdBldr;\r\n            }\r\n\r\n            pr" +
                    "ivate static void CreateProperty<T>(TypeBuilder typeBuilder, string propertyName" +
                    ", Type propType, MethodInfo setIsDirtyMethod, bool isIdentity)\r\n            {\r\n " +
                    "               //Define the field and the property \r\n                var field =" +
                    " typeBuilder.DefineField(\"_\" + propertyName, propType, FieldAttributes.Private);" +
                    "\r\n                var property = typeBuilder.DefineProperty(propertyName,\r\n     " +
                    "                                           System.Reflection.PropertyAttributes." +
                    "None,\r\n                                                propType,\r\n              " +
                    "                                  new Type[] { propType });\r\n\r\n                c" +
                    "onst MethodAttributes getSetAttr = MethodAttributes.Public | MethodAttributes.Vi" +
                    "rtual |\r\n                                                    MethodAttributes.Hi" +
                    "deBySig;\r\n\r\n                // Define the \"get\" and \"set\" accessor methods\r\n    " +
                    "            var currGetPropMthdBldr = typeBuilder.DefineMethod(\"get_\" + property" +
                    "Name,\r\n                                                getSetAttr,\r\n            " +
                    "                                    propType,\r\n                                 " +
                    "               Type.EmptyTypes);\r\n\r\n                var currGetIL = currGetPropM" +
                    "thdBldr.GetILGenerator();\r\n                currGetIL.Emit(OpCodes.Ldarg_0);\r\n   " +
                    "             currGetIL.Emit(OpCodes.Ldfld, field);\r\n                currGetIL.Em" +
                    "it(OpCodes.Ret);\r\n\r\n                var currSetPropMthdBldr = typeBuilder.Define" +
                    "Method(\"set_\" + propertyName,\r\n                                                g" +
                    "etSetAttr,\r\n                                                null,\r\n             " +
                    "                                   new Type[] { propType });\r\n\r\n                " +
                    "//store value in private field and set the isdirty flag\r\n                var cur" +
                    "rSetIL = currSetPropMthdBldr.GetILGenerator();\r\n                currSetIL.Emit(O" +
                    "pCodes.Ldarg_0);\r\n                currSetIL.Emit(OpCodes.Ldarg_1);\r\n            " +
                    "    currSetIL.Emit(OpCodes.Stfld, field);\r\n                currSetIL.Emit(OpCode" +
                    "s.Ldarg_0);\r\n                currSetIL.Emit(OpCodes.Ldc_I4_1);\r\n                " +
                    "currSetIL.Emit(OpCodes.Call, setIsDirtyMethod);\r\n                currSetIL.Emit(" +
                    "OpCodes.Ret);\r\n\r\n                //TODO: Should copy all attributes defined by t" +
                    "he interface?\r\n                if (isIdentity)\r\n                {\r\n             " +
                    "       var keyAttribute = typeof(KeyAttribute);\r\n                    var myConst" +
                    "ructorInfo = keyAttribute.GetConstructor(new Type[] { });\r\n                    v" +
                    "ar attributeBuilder = new CustomAttributeBuilder(myConstructorInfo, new object[]" +
                    " { });\r\n                    property.SetCustomAttribute(attributeBuilder);\r\n    " +
                    "            }\r\n\r\n                property.SetGetMethod(currGetPropMthdBldr);\r\n  " +
                    "              property.SetSetMethod(currSetPropMthdBldr);\r\n                var g" +
                    "etMethod = typeof(T).GetMethod(\"get_\" + propertyName);\r\n                var setM" +
                    "ethod = typeof(T).GetMethod(\"set_\" + propertyName);\r\n                typeBuilder" +
                    ".DefineMethodOverride(currGetPropMthdBldr, getMethod);\r\n                typeBuil" +
                    "der.DefineMethodOverride(currSetPropMthdBldr, setMethod);\r\n            }\r\n\r\n    " +
                    "    }\r\n    }\r\n}");
            return this.GenerationEnvironment.ToString();
        }
    }
    
    #line default
    #line hidden
    #region Base class
    /// <summary>
    /// Base class for this transformation
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "14.0.0.0")]
    public class SqlMapperExtensionsBase
    {
        #region Fields
        private global::System.Text.StringBuilder generationEnvironmentField;
        private global::System.CodeDom.Compiler.CompilerErrorCollection errorsField;
        private global::System.Collections.Generic.List<int> indentLengthsField;
        private string currentIndentField = "";
        private bool endsWithNewline;
        private global::System.Collections.Generic.IDictionary<string, object> sessionField;
        #endregion
        #region Properties
        /// <summary>
        /// The string builder that generation-time code is using to assemble generated output
        /// </summary>
        protected System.Text.StringBuilder GenerationEnvironment
        {
            get
            {
                if ((this.generationEnvironmentField == null))
                {
                    this.generationEnvironmentField = new global::System.Text.StringBuilder();
                }
                return this.generationEnvironmentField;
            }
            set
            {
                this.generationEnvironmentField = value;
            }
        }
        /// <summary>
        /// The error collection for the generation process
        /// </summary>
        public System.CodeDom.Compiler.CompilerErrorCollection Errors
        {
            get
            {
                if ((this.errorsField == null))
                {
                    this.errorsField = new global::System.CodeDom.Compiler.CompilerErrorCollection();
                }
                return this.errorsField;
            }
        }
        /// <summary>
        /// A list of the lengths of each indent that was added with PushIndent
        /// </summary>
        private System.Collections.Generic.List<int> indentLengths
        {
            get
            {
                if ((this.indentLengthsField == null))
                {
                    this.indentLengthsField = new global::System.Collections.Generic.List<int>();
                }
                return this.indentLengthsField;
            }
        }
        /// <summary>
        /// Gets the current indent we use when adding lines to the output
        /// </summary>
        public string CurrentIndent
        {
            get
            {
                return this.currentIndentField;
            }
        }
        /// <summary>
        /// Current transformation session
        /// </summary>
        public virtual global::System.Collections.Generic.IDictionary<string, object> Session
        {
            get
            {
                return this.sessionField;
            }
            set
            {
                this.sessionField = value;
            }
        }
        #endregion
        #region Transform-time helpers
        /// <summary>
        /// Write text directly into the generated output
        /// </summary>
        public void Write(string textToAppend)
        {
            if (string.IsNullOrEmpty(textToAppend))
            {
                return;
            }
            // If we're starting off, or if the previous text ended with a newline,
            // we have to append the current indent first.
            if (((this.GenerationEnvironment.Length == 0) 
                        || this.endsWithNewline))
            {
                this.GenerationEnvironment.Append(this.currentIndentField);
                this.endsWithNewline = false;
            }
            // Check if the current text ends with a newline
            if (textToAppend.EndsWith(global::System.Environment.NewLine, global::System.StringComparison.CurrentCulture))
            {
                this.endsWithNewline = true;
            }
            // This is an optimization. If the current indent is "", then we don't have to do any
            // of the more complex stuff further down.
            if ((this.currentIndentField.Length == 0))
            {
                this.GenerationEnvironment.Append(textToAppend);
                return;
            }
            // Everywhere there is a newline in the text, add an indent after it
            textToAppend = textToAppend.Replace(global::System.Environment.NewLine, (global::System.Environment.NewLine + this.currentIndentField));
            // If the text ends with a newline, then we should strip off the indent added at the very end
            // because the appropriate indent will be added when the next time Write() is called
            if (this.endsWithNewline)
            {
                this.GenerationEnvironment.Append(textToAppend, 0, (textToAppend.Length - this.currentIndentField.Length));
            }
            else
            {
                this.GenerationEnvironment.Append(textToAppend);
            }
        }
        /// <summary>
        /// Write text directly into the generated output
        /// </summary>
        public void WriteLine(string textToAppend)
        {
            this.Write(textToAppend);
            this.GenerationEnvironment.AppendLine();
            this.endsWithNewline = true;
        }
        /// <summary>
        /// Write formatted text directly into the generated output
        /// </summary>
        public void Write(string format, params object[] args)
        {
            this.Write(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
        }
        /// <summary>
        /// Write formatted text directly into the generated output
        /// </summary>
        public void WriteLine(string format, params object[] args)
        {
            this.WriteLine(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
        }
        /// <summary>
        /// Raise an error
        /// </summary>
        public void Error(string message)
        {
            System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
            error.ErrorText = message;
            this.Errors.Add(error);
        }
        /// <summary>
        /// Raise a warning
        /// </summary>
        public void Warning(string message)
        {
            System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
            error.ErrorText = message;
            error.IsWarning = true;
            this.Errors.Add(error);
        }
        /// <summary>
        /// Increase the indent
        /// </summary>
        public void PushIndent(string indent)
        {
            if ((indent == null))
            {
                throw new global::System.ArgumentNullException("indent");
            }
            this.currentIndentField = (this.currentIndentField + indent);
            this.indentLengths.Add(indent.Length);
        }
        /// <summary>
        /// Remove the last indent that was added with PushIndent
        /// </summary>
        public string PopIndent()
        {
            string returnValue = "";
            if ((this.indentLengths.Count > 0))
            {
                int indentLength = this.indentLengths[(this.indentLengths.Count - 1)];
                this.indentLengths.RemoveAt((this.indentLengths.Count - 1));
                if ((indentLength > 0))
                {
                    returnValue = this.currentIndentField.Substring((this.currentIndentField.Length - indentLength));
                    this.currentIndentField = this.currentIndentField.Remove((this.currentIndentField.Length - indentLength));
                }
            }
            return returnValue;
        }
        /// <summary>
        /// Remove any indentation
        /// </summary>
        public void ClearIndent()
        {
            this.indentLengths.Clear();
            this.currentIndentField = "";
        }
        #endregion
        #region ToString Helpers
        /// <summary>
        /// Utility class to produce culture-oriented representation of an object as a string.
        /// </summary>
        public class ToStringInstanceHelper
        {
            private System.IFormatProvider formatProviderField  = global::System.Globalization.CultureInfo.InvariantCulture;
            /// <summary>
            /// Gets or sets format provider to be used by ToStringWithCulture method.
            /// </summary>
            public System.IFormatProvider FormatProvider
            {
                get
                {
                    return this.formatProviderField ;
                }
                set
                {
                    if ((value != null))
                    {
                        this.formatProviderField  = value;
                    }
                }
            }
            /// <summary>
            /// This is called from the compile/run appdomain to convert objects within an expression block to a string
            /// </summary>
            public string ToStringWithCulture(object objectToConvert)
            {
                if ((objectToConvert == null))
                {
                    throw new global::System.ArgumentNullException("objectToConvert");
                }
                System.Type t = objectToConvert.GetType();
                System.Reflection.MethodInfo method = t.GetMethod("ToString", new System.Type[] {
                            typeof(System.IFormatProvider)});
                if ((method == null))
                {
                    return objectToConvert.ToString();
                }
                else
                {
                    return ((string)(method.Invoke(objectToConvert, new object[] {
                                this.formatProviderField })));
                }
            }
        }
        private ToStringInstanceHelper toStringHelperField = new ToStringInstanceHelper();
        /// <summary>
        /// Helper to produce culture-oriented representation of an object as a string
        /// </summary>
        public ToStringInstanceHelper ToStringHelper
        {
            get
            {
                return this.toStringHelperField;
            }
        }
        #endregion
    }
    #endregion
}
